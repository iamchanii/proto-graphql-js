// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`'testapis.custom_types' > generates files by plugin 'with graphql_type layout' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/custom_types/date.proto

/* eslint-disable */

import { Date } from "@testapis/ts-proto/testapis/custom_types/date";
import { builder } from "../../builder";

export const Date$Ref = builder.objectRef<Date>("Date");
builder.objectType(Date$Ref, {
  name: "Date",
  fields: (t) => ({
    year: t.expose("year", {
      type: "Int",
      nullable: false,
      extensions: { protobufField: { name: "year", typeFullName: "uint32" } },
    }),
    month: t.expose("month", {
      type: "Int",
      nullable: false,
      extensions: { protobufField: { name: "month", typeFullName: "uint32" } },
    }),
    day: t.expose("day", {
      type: "Int",
      nullable: false,
      extensions: { protobufField: { name: "day", typeFullName: "uint32" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Date | { $type: string & {}; }).$type ===
      "testapis.custom_types.Date";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.custom_types.Date",
      name: "Date",
      package: "testapis.custom_types",
    },
  },
});
",
    "name": "testapis/custom_types/Date.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/custom_types/date.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { Date } from "@testapis/ts-proto/testapis/custom_types/date";
import { builder } from "../../builder";

export type DateInput$Shape = {
  year: Date["year"];
  month: Date["month"];
  day: Date["day"];
};

export const DateInput$Ref: InputObjectRef<DateInput$Shape> = builder.inputRef<
  DateInput$Shape
>("DateInput").implement({
  fields: (t) => ({
    year: t.field({
      type: "Int",
      required: true,
      extensions: { protobufField: { name: "year", typeFullName: "uint32" } },
    }),
    month: t.field({
      type: "Int",
      required: true,
      extensions: { protobufField: { name: "month", typeFullName: "uint32" } },
    }),
    day: t.field({
      type: "Int",
      required: true,
      extensions: { protobufField: { name: "day", typeFullName: "uint32" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.custom_types.Date",
      name: "Date",
      package: "testapis.custom_types",
    },
  },
});
",
    "name": "testapis/custom_types/DateInput.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/custom_types/post.proto

/* eslint-disable */

import { Post } from "@testapis/ts-proto/testapis/custom_types/post";
import { builder } from "../../builder";
import { Date$Ref } from "./Date.pothos";

export const Post$Ref = builder.objectRef<Post>("Post");
builder.objectType(Post$Ref, {
  name: "Post",
  fields: (t) => ({
    title: t.expose("title", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "title", typeFullName: "string" } },
    }),
    publishedDate: t.expose("publishedDate", {
      type: Date$Ref,
      nullable: true,
      description: "Optional.",
      extensions: {
        protobufField: {
          name: "published_date",
          typeFullName: "testapis.custom_types.Date",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Post | { $type: string & {}; }).$type ===
      "testapis.custom_types.Post";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.custom_types.Post",
      name: "Post",
      package: "testapis.custom_types",
    },
  },
});
",
    "name": "testapis/custom_types/Post.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/custom_types/post.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { Post } from "@testapis/ts-proto/testapis/custom_types/post";
import { builder } from "../../builder";
import { DateInput$Ref, DateInput$Shape } from "./DateInput.pothos";

export type PostInput$Shape = {
  title: Post["title"];
  publishedDate?: DateInput$Shape | null;
};

export const PostInput$Ref: InputObjectRef<PostInput$Shape> = builder.inputRef<
  PostInput$Shape
>("PostInput").implement({
  fields: (t) => ({
    title: t.field({
      type: "String",
      required: true,
      description: "Required.",
      extensions: { protobufField: { name: "title", typeFullName: "string" } },
    }),
    publishedDate: t.field({
      type: DateInput$Ref,
      required: false,
      description: "Optional.",
      extensions: {
        protobufField: {
          name: "published_date",
          typeFullName: "testapis.custom_types.Date",
        },
      },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.custom_types.Post",
      name: "Post",
      package: "testapis.custom_types",
    },
  },
});
",
    "name": "testapis/custom_types/PostInput.pothos.ts",
  },
]
`;

exports[`'testapis.custom_types' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/custom_types/date.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { Date } from "@testapis/ts-proto/testapis/custom_types/date";
import { builder } from "../../builder";

export const Date$Ref = builder.objectRef<Date>("Date");
builder.objectType(Date$Ref, {
  name: "Date",
  fields: (t) => ({
    year: t.expose("year", {
      type: "Int",
      nullable: false,
      extensions: { protobufField: { name: "year", typeFullName: "uint32" } },
    }),
    month: t.expose("month", {
      type: "Int",
      nullable: false,
      extensions: { protobufField: { name: "month", typeFullName: "uint32" } },
    }),
    day: t.expose("day", {
      type: "Int",
      nullable: false,
      extensions: { protobufField: { name: "day", typeFullName: "uint32" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Date | { $type: string & {}; }).$type ===
      "testapis.custom_types.Date";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.custom_types.Date",
      name: "Date",
      package: "testapis.custom_types",
    },
  },
});

export type DateInput$Shape = {
  year: Date["year"];
  month: Date["month"];
  day: Date["day"];
};

export const DateInput$Ref: InputObjectRef<DateInput$Shape> = builder.inputRef<
  DateInput$Shape
>("DateInput").implement({
  fields: (t) => ({
    year: t.field({
      type: "Int",
      required: true,
      extensions: { protobufField: { name: "year", typeFullName: "uint32" } },
    }),
    month: t.field({
      type: "Int",
      required: true,
      extensions: { protobufField: { name: "month", typeFullName: "uint32" } },
    }),
    day: t.field({
      type: "Int",
      required: true,
      extensions: { protobufField: { name: "day", typeFullName: "uint32" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.custom_types.Date",
      name: "Date",
      package: "testapis.custom_types",
    },
  },
});
",
    "name": "testapis/custom_types/date.pb.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/custom_types/post.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { Post } from "@testapis/ts-proto/testapis/custom_types/post";
import { builder } from "../../builder";
import { Date$Ref, DateInput$Ref, DateInput$Shape } from "./date.pb.pothos";

export const Post$Ref = builder.objectRef<Post>("Post");
builder.objectType(Post$Ref, {
  name: "Post",
  fields: (t) => ({
    title: t.expose("title", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "title", typeFullName: "string" } },
    }),
    publishedDate: t.expose("publishedDate", {
      type: Date$Ref,
      nullable: true,
      description: "Optional.",
      extensions: {
        protobufField: {
          name: "published_date",
          typeFullName: "testapis.custom_types.Date",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Post | { $type: string & {}; }).$type ===
      "testapis.custom_types.Post";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.custom_types.Post",
      name: "Post",
      package: "testapis.custom_types",
    },
  },
});

export type PostInput$Shape = {
  title: Post["title"];
  publishedDate?: DateInput$Shape | null;
};

export const PostInput$Ref: InputObjectRef<PostInput$Shape> = builder.inputRef<
  PostInput$Shape
>("PostInput").implement({
  fields: (t) => ({
    title: t.field({
      type: "String",
      required: true,
      description: "Required.",
      extensions: { protobufField: { name: "title", typeFullName: "string" } },
    }),
    publishedDate: t.field({
      type: DateInput$Ref,
      required: false,
      description: "Optional.",
      extensions: {
        protobufField: {
          name: "published_date",
          typeFullName: "testapis.custom_types.Date",
        },
      },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.custom_types.Post",
      name: "Post",
      package: "testapis.custom_types",
    },
  },
});
",
    "name": "testapis/custom_types/post.pb.pothos.ts",
  },
]
`;

exports[`'testapis.custom_types' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/custom_types/date.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { Date } from "@testapis/ts-proto/testapis/custom_types/date";
import { builder } from "../../builder";

export const Date$Ref = builder.objectRef<Date>("Date");
builder.objectType(Date$Ref, {
  name: "Date",
  fields: (t) => ({
    year: t.expose("year", {
      type: "Int",
      nullable: false,
      extensions: { protobufField: { name: "year", typeFullName: "uint32" } },
    }),
    month: t.expose("month", {
      type: "Int",
      nullable: false,
      extensions: { protobufField: { name: "month", typeFullName: "uint32" } },
    }),
    day: t.expose("day", {
      type: "Int",
      nullable: false,
      extensions: { protobufField: { name: "day", typeFullName: "uint32" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Date | { $type: string & {}; }).$type ===
      "testapis.custom_types.Date";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.custom_types.Date",
      name: "Date",
      package: "testapis.custom_types",
    },
  },
});

export type DateInput$Shape = {
  year: Date["year"];
  month: Date["month"];
  day: Date["day"];
};

export const DateInput$Ref: InputObjectRef<DateInput$Shape> = builder.inputRef<
  DateInput$Shape
>("DateInput").implement({
  fields: (t) => ({
    year: t.field({
      type: "Int",
      required: true,
      extensions: { protobufField: { name: "year", typeFullName: "uint32" } },
    }),
    month: t.field({
      type: "Int",
      required: true,
      extensions: { protobufField: { name: "month", typeFullName: "uint32" } },
    }),
    day: t.field({
      type: "Int",
      required: true,
      extensions: { protobufField: { name: "day", typeFullName: "uint32" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.custom_types.Date",
      name: "Date",
      package: "testapis.custom_types",
    },
  },
});

export type DatePartialInput$Shape = {
  year?: Date["year"] | null;
  month?: Date["month"] | null;
  day?: Date["day"] | null;
};

export const DatePartialInput$Ref: InputObjectRef<DatePartialInput$Shape> =
  builder.inputRef<DatePartialInput$Shape>("DatePartialInput").implement({
    fields: (t) => ({
      year: t.field({
        type: "Int",
        required: false,
        extensions: { protobufField: { name: "year", typeFullName: "uint32" } },
      }),
      month: t.field({
        type: "Int",
        required: false,
        extensions: {
          protobufField: { name: "month", typeFullName: "uint32" },
        },
      }),
      day: t.field({
        type: "Int",
        required: false,
        extensions: { protobufField: { name: "day", typeFullName: "uint32" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.custom_types.Date",
        name: "Date",
        package: "testapis.custom_types",
      },
    },
  });
",
    "name": "testapis/custom_types/date.pb.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/custom_types/post.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { Post } from "@testapis/ts-proto/testapis/custom_types/post";
import { builder } from "../../builder";
import {
  Date$Ref,
  DateInput$Ref,
  DateInput$Shape,
  DatePartialInput$Ref,
  DatePartialInput$Shape,
} from "./date.pb.pothos";

export const Post$Ref = builder.objectRef<Post>("Post");
builder.objectType(Post$Ref, {
  name: "Post",
  fields: (t) => ({
    title: t.expose("title", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "title", typeFullName: "string" } },
    }),
    publishedDate: t.expose("publishedDate", {
      type: Date$Ref,
      nullable: true,
      description: "Optional.",
      extensions: {
        protobufField: {
          name: "published_date",
          typeFullName: "testapis.custom_types.Date",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Post | { $type: string & {}; }).$type ===
      "testapis.custom_types.Post";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.custom_types.Post",
      name: "Post",
      package: "testapis.custom_types",
    },
  },
});

export type PostInput$Shape = {
  title: Post["title"];
  publishedDate?: DateInput$Shape | null;
};

export const PostInput$Ref: InputObjectRef<PostInput$Shape> = builder.inputRef<
  PostInput$Shape
>("PostInput").implement({
  fields: (t) => ({
    title: t.field({
      type: "String",
      required: true,
      description: "Required.",
      extensions: { protobufField: { name: "title", typeFullName: "string" } },
    }),
    publishedDate: t.field({
      type: DateInput$Ref,
      required: false,
      description: "Optional.",
      extensions: {
        protobufField: {
          name: "published_date",
          typeFullName: "testapis.custom_types.Date",
        },
      },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.custom_types.Post",
      name: "Post",
      package: "testapis.custom_types",
    },
  },
});

export type PostPartialInput$Shape = {
  title?: Post["title"] | null;
  publishedDate?: DatePartialInput$Shape | null;
};

export const PostPartialInput$Ref: InputObjectRef<PostPartialInput$Shape> =
  builder.inputRef<PostPartialInput$Shape>("PostPartialInput").implement({
    fields: (t) => ({
      title: t.field({
        type: "String",
        required: false,
        description: "Required.",
        extensions: {
          protobufField: { name: "title", typeFullName: "string" },
        },
      }),
      publishedDate: t.field({
        type: DatePartialInput$Ref,
        required: false,
        description: "Optional.",
        extensions: {
          protobufField: {
            name: "published_date",
            typeFullName: "testapis.custom_types.Date",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.custom_types.Post",
        name: "Post",
        package: "testapis.custom_types",
      },
    },
  });
",
    "name": "testapis/custom_types/post.pb.pothos.ts",
  },
]
`;

exports[`'testapis.custom_types' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/custom_types/date.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import { Date } from "./testapis/custom_types/date";

export const Date$Ref = builder.objectRef<Date>("Date");
builder.objectType(Date$Ref, {
  name: "Date",
  fields: (t) => ({
    year: t.expose("year", {
      type: "Int",
      nullable: false,
      extensions: { protobufField: { name: "year", typeFullName: "uint32" } },
    }),
    month: t.expose("month", {
      type: "Int",
      nullable: false,
      extensions: { protobufField: { name: "month", typeFullName: "uint32" } },
    }),
    day: t.expose("day", {
      type: "Int",
      nullable: false,
      extensions: { protobufField: { name: "day", typeFullName: "uint32" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Date | { $type: string & {}; }).$type ===
      "testapis.custom_types.Date";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.custom_types.Date",
      name: "Date",
      package: "testapis.custom_types",
    },
  },
});

export type DateInput$Shape = {
  year: Date["year"];
  month: Date["month"];
  day: Date["day"];
};

export const DateInput$Ref: InputObjectRef<DateInput$Shape> = builder.inputRef<
  DateInput$Shape
>("DateInput").implement({
  fields: (t) => ({
    year: t.field({
      type: "Int",
      required: true,
      extensions: { protobufField: { name: "year", typeFullName: "uint32" } },
    }),
    month: t.field({
      type: "Int",
      required: true,
      extensions: { protobufField: { name: "month", typeFullName: "uint32" } },
    }),
    day: t.field({
      type: "Int",
      required: true,
      extensions: { protobufField: { name: "day", typeFullName: "uint32" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.custom_types.Date",
      name: "Date",
      package: "testapis.custom_types",
    },
  },
});
",
    "name": "testapis/custom_types/date.pb.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/custom_types/post.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import { Date$Ref, DateInput$Ref, DateInput$Shape } from "./date.pb.pothos";
import { Post } from "./testapis/custom_types/post";

export const Post$Ref = builder.objectRef<Post>("Post");
builder.objectType(Post$Ref, {
  name: "Post",
  fields: (t) => ({
    title: t.expose("title", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "title", typeFullName: "string" } },
    }),
    publishedDate: t.expose("publishedDate", {
      type: Date$Ref,
      nullable: true,
      description: "Optional.",
      extensions: {
        protobufField: {
          name: "published_date",
          typeFullName: "testapis.custom_types.Date",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Post | { $type: string & {}; }).$type ===
      "testapis.custom_types.Post";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.custom_types.Post",
      name: "Post",
      package: "testapis.custom_types",
    },
  },
});

export type PostInput$Shape = {
  title: Post["title"];
  publishedDate?: DateInput$Shape | null;
};

export const PostInput$Ref: InputObjectRef<PostInput$Shape> = builder.inputRef<
  PostInput$Shape
>("PostInput").implement({
  fields: (t) => ({
    title: t.field({
      type: "String",
      required: true,
      description: "Required.",
      extensions: { protobufField: { name: "title", typeFullName: "string" } },
    }),
    publishedDate: t.field({
      type: DateInput$Ref,
      required: false,
      description: "Optional.",
      extensions: {
        protobufField: {
          name: "published_date",
          typeFullName: "testapis.custom_types.Date",
        },
      },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.custom_types.Post",
      name: "Post",
      package: "testapis.custom_types",
    },
  },
});
",
    "name": "testapis/custom_types/post.pb.pothos.ts",
  },
]
`;

exports[`'testapis.deprecation' > generates files by plugin 'with graphql_type layout' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/deprecation/deprecation.proto

/* eslint-disable */

import {
  DeprecatedMessage,
  NotDeprecatedEnum,
} from "@testapis/ts-proto/testapis/deprecation/deprecation";
import { builder } from "../../builder";
import { NotDeprecatedEnum$Ref } from "./NotDeprecatedEnum.pothos";

export const DeprecatedMessage$Ref = builder.objectRef<DeprecatedMessage>(
  "DeprecatedMessage",
);
builder.objectType(DeprecatedMessage$Ref, {
  name: "DeprecatedMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    enum: t.field({
      type: NotDeprecatedEnum$Ref,
      nullable: true,
      deprecationReason:
        "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
      resolve: (source) => {
        if (source.enum === NotDeprecatedEnum.NOT_DEPRECATED_ENUM_UNSPECIFIED) {
          return null;
        }

        return source.enum;
      },
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.deprecation.NotDeprecatedEnum",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as DeprecatedMessage | { $type: string & {}; }).$type ===
      "testapis.deprecation.DeprecatedMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedMessage",
      name: "DeprecatedMessage",
      package: "testapis.deprecation",
      options: { deprecated: true },
    },
  },
});
",
    "name": "testapis/deprecation/DeprecatedMessage.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/deprecation/deprecation.proto

/* eslint-disable */

import {
  DeprecatedEnum,
  NotDeprecatedMessage,
} from "@testapis/ts-proto/testapis/deprecation/deprecation";
import { builder } from "../../builder";
import { DeprecatedEnum$Ref } from "./DeprecatedEnum.pothos";

export const NotDeprecatedMessage$Ref = builder.objectRef<NotDeprecatedMessage>(
  "NotDeprecatedMessage",
);
builder.objectType(NotDeprecatedMessage$Ref, {
  name: "NotDeprecatedMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis.deprecation.NotDeprecatedMessage.body is mark as deprecated in a *.proto file.",
      extensions: {
        protobufField: {
          name: "body",
          typeFullName: "string",
          options: { deprecated: true },
        },
      },
    }),
    enum: t.field({
      type: DeprecatedEnum$Ref,
      nullable: true,
      deprecationReason:
        "testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.",
      resolve: (source) => {
        if (source.enum === DeprecatedEnum.DEPRECATED_ENUM_UNSPECIFIED) {
          return null;
        }

        return source.enum;
      },
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.deprecation.DeprecatedEnum",
        },
      },
    }),
    notDeprecatedOneof: t.field({
      type: NotDeprecatedMessageNotDeprecatedOneof$Ref,
      nullable: true,
      resolve: (source) => {
        const value = source.msg1 ?? source.msg2;
        if (value == null) {
          return null;
        }
        return value;
      },
      extensions: { protobufField: { name: "not_deprecated_oneof" } },
    }),
    deprecatedOneof: t.field({
      type: NotDeprecatedMessageDeprecatedOneof$Ref,
      nullable: true,
      deprecationReason:
        "testapis.deprecation.NotDeprecatedMessage.deprecated_oneof is mark as deprecated in a *.proto file.",
      resolve: (source) => {
        const value = source.msg3 ?? source.msg4;
        if (value == null) {
          return null;
        }
        return value;
      },
      extensions: { protobufField: { name: "deprecated_oneof" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as NotDeprecatedMessage | { $type: string & {}; }).$type ===
      "testapis.deprecation.NotDeprecatedMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.NotDeprecatedMessage",
      name: "NotDeprecatedMessage",
      package: "testapis.deprecation",
    },
  },
});
",
    "name": "testapis/deprecation/NotDeprecatedMessage.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/deprecation/deprecation.proto

/* eslint-disable */

import { DeprecatedMessage_InnerMessage } from "@testapis/ts-proto/testapis/deprecation/deprecation";
import { builder } from "../../builder";

export const DeprecatedMessageInnerMessage$Ref = builder.objectRef<
  DeprecatedMessage_InnerMessage
>("DeprecatedMessageInnerMessage");
builder.objectType(DeprecatedMessageInnerMessage$Ref, {
  name: "DeprecatedMessageInnerMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as DeprecatedMessage_InnerMessage | { $type: string & {}; })
      .$type === "testapis.deprecation.DeprecatedMessage.InnerMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.deprecation",
    },
  },
});
",
    "name": "testapis/deprecation/DeprecatedMessageInnerMessage.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/deprecation/deprecation.proto

/* eslint-disable */

import { NotDeprecatedMessage_InnerMessage1 } from "@testapis/ts-proto/testapis/deprecation/deprecation";
import { builder } from "../../builder";

export const NotDeprecatedMessageInnerMessage1$Ref = builder.objectRef<
  NotDeprecatedMessage_InnerMessage1
>("NotDeprecatedMessageInnerMessage1");
builder.objectType(NotDeprecatedMessageInnerMessage1$Ref, {
  name: "NotDeprecatedMessageInnerMessage1",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as NotDeprecatedMessage_InnerMessage1 | {
      $type: string & {};
    }).$type === "testapis.deprecation.NotDeprecatedMessage.InnerMessage1";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
      name: "InnerMessage1",
      package: "testapis.deprecation",
    },
  },
});
",
    "name": "testapis/deprecation/NotDeprecatedMessageInnerMessage1.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/deprecation/deprecation.proto

/* eslint-disable */

import { NotDeprecatedMessage_InnerMessage2 } from "@testapis/ts-proto/testapis/deprecation/deprecation";
import { builder } from "../../builder";

export const NotDeprecatedMessageInnerMessage2$Ref = builder.objectRef<
  NotDeprecatedMessage_InnerMessage2
>("NotDeprecatedMessageInnerMessage2");
builder.objectType(NotDeprecatedMessageInnerMessage2$Ref, {
  name: "NotDeprecatedMessageInnerMessage2",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as NotDeprecatedMessage_InnerMessage2 | {
      $type: string & {};
    }).$type === "testapis.deprecation.NotDeprecatedMessage.InnerMessage2";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
      name: "InnerMessage2",
      package: "testapis.deprecation",
    },
  },
});
",
    "name": "testapis/deprecation/NotDeprecatedMessageInnerMessage2.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/deprecation/deprecation.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { DeprecatedMessage } from "@testapis/ts-proto/testapis/deprecation/deprecation";
import { builder } from "../../builder";
import { NotDeprecatedEnum$Ref } from "./NotDeprecatedEnum.pothos";

export type DeprecatedMessageInput$Shape = {
  body?: DeprecatedMessage["body"] | null;
  enum?: DeprecatedMessage["enum"] | null;
};

export const DeprecatedMessageInput$Ref: InputObjectRef<
  DeprecatedMessageInput$Shape
> = builder.inputRef<DeprecatedMessageInput$Shape>("DeprecatedMessageInput")
  .implement({
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        deprecationReason:
          "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
      enum: t.field({
        type: NotDeprecatedEnum$Ref,
        required: false,
        deprecationReason:
          "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "enum",
            typeFullName: "testapis.deprecation.NotDeprecatedEnum",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.DeprecatedMessage",
        name: "DeprecatedMessage",
        package: "testapis.deprecation",
        options: { deprecated: true },
      },
    },
  });
",
    "name": "testapis/deprecation/DeprecatedMessageInput.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/deprecation/deprecation.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { NotDeprecatedMessage } from "@testapis/ts-proto/testapis/deprecation/deprecation";
import { builder } from "../../builder";
import { DeprecatedEnum$Ref } from "./DeprecatedEnum.pothos";
import {
  NotDeprecatedMessageInnerMessage1Input$Ref,
  NotDeprecatedMessageInnerMessage1Input$Shape,
} from "./NotDeprecatedMessageInnerMessage1Input.pothos";
import {
  NotDeprecatedMessageInnerMessage2Input$Ref,
  NotDeprecatedMessageInnerMessage2Input$Shape,
} from "./NotDeprecatedMessageInnerMessage2Input.pothos";

export type NotDeprecatedMessageInput$Shape = {
  body?: NotDeprecatedMessage["body"] | null;
  enum?: NotDeprecatedMessage["enum"] | null;
  msg1?: NotDeprecatedMessageInnerMessage1Input$Shape | null;
  msg2?: NotDeprecatedMessageInnerMessage2Input$Shape | null;
  msg3?: NotDeprecatedMessageInnerMessage1Input$Shape | null;
  msg4?: NotDeprecatedMessageInnerMessage2Input$Shape | null;
};

export const NotDeprecatedMessageInput$Ref: InputObjectRef<
  NotDeprecatedMessageInput$Shape
> = builder.inputRef<NotDeprecatedMessageInput$Shape>(
  "NotDeprecatedMessageInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: false,
      deprecationReason:
        "testapis.deprecation.NotDeprecatedMessage.body is mark as deprecated in a *.proto file.",
      extensions: {
        protobufField: {
          name: "body",
          typeFullName: "string",
          options: { deprecated: true },
        },
      },
    }),
    enum: t.field({
      type: DeprecatedEnum$Ref,
      required: false,
      deprecationReason:
        "testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.",
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.deprecation.DeprecatedEnum",
        },
      },
    }),
    msg1: t.field({
      type: NotDeprecatedMessageInnerMessage1Input$Ref,
      required: false,
      deprecationReason:
        "testapis.deprecation.NotDeprecatedMessage.msg1 is mark as deprecated in a *.proto file.",
      extensions: {
        protobufField: {
          name: "msg1",
          typeFullName:
            "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
          options: { deprecated: true },
        },
      },
    }),
    msg2: t.field({
      type: NotDeprecatedMessageInnerMessage2Input$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "msg2",
          typeFullName:
            "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
        },
      },
    }),
    msg3: t.field({
      type: NotDeprecatedMessageInnerMessage1Input$Ref,
      required: false,
      deprecationReason:
        "testapis.deprecation.NotDeprecatedMessage.msg3 is mark as deprecated in a *.proto file.",
      extensions: {
        protobufField: {
          name: "msg3",
          typeFullName:
            "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
          options: { deprecated: true },
        },
      },
    }),
    msg4: t.field({
      type: NotDeprecatedMessageInnerMessage2Input$Ref,
      required: false,
      deprecationReason:
        "testapis.deprecation.NotDeprecatedMessage.msg4 is mark as deprecated in a *.proto file.",
      extensions: {
        protobufField: {
          name: "msg4",
          typeFullName:
            "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
          options: { deprecated: true },
        },
      },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.NotDeprecatedMessage",
      name: "NotDeprecatedMessage",
      package: "testapis.deprecation",
    },
  },
});
",
    "name": "testapis/deprecation/NotDeprecatedMessageInput.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/deprecation/deprecation.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { DeprecatedMessage_InnerMessage } from "@testapis/ts-proto/testapis/deprecation/deprecation";
import { builder } from "../../builder";

export type DeprecatedMessageInnerMessageInput$Shape = {
  body?: DeprecatedMessage_InnerMessage["body"] | null;
};

export const DeprecatedMessageInnerMessageInput$Ref: InputObjectRef<
  DeprecatedMessageInnerMessageInput$Shape
> = builder.inputRef<DeprecatedMessageInnerMessageInput$Shape>(
  "DeprecatedMessageInnerMessageInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: false,
      deprecationReason:
        "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.deprecation",
    },
  },
});
",
    "name": "testapis/deprecation/DeprecatedMessageInnerMessageInput.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/deprecation/deprecation.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { NotDeprecatedMessage_InnerMessage1 } from "@testapis/ts-proto/testapis/deprecation/deprecation";
import { builder } from "../../builder";

export type NotDeprecatedMessageInnerMessage1Input$Shape = {
  body: NotDeprecatedMessage_InnerMessage1["body"];
};

export const NotDeprecatedMessageInnerMessage1Input$Ref: InputObjectRef<
  NotDeprecatedMessageInnerMessage1Input$Shape
> = builder.inputRef<NotDeprecatedMessageInnerMessage1Input$Shape>(
  "NotDeprecatedMessageInnerMessage1Input",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
      name: "InnerMessage1",
      package: "testapis.deprecation",
    },
  },
});
",
    "name": "testapis/deprecation/NotDeprecatedMessageInnerMessage1Input.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/deprecation/deprecation.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { NotDeprecatedMessage_InnerMessage2 } from "@testapis/ts-proto/testapis/deprecation/deprecation";
import { builder } from "../../builder";

export type NotDeprecatedMessageInnerMessage2Input$Shape = {
  body: NotDeprecatedMessage_InnerMessage2["body"];
};

export const NotDeprecatedMessageInnerMessage2Input$Ref: InputObjectRef<
  NotDeprecatedMessageInnerMessage2Input$Shape
> = builder.inputRef<NotDeprecatedMessageInnerMessage2Input$Shape>(
  "NotDeprecatedMessageInnerMessage2Input",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
      name: "InnerMessage2",
      package: "testapis.deprecation",
    },
  },
});
",
    "name": "testapis/deprecation/NotDeprecatedMessageInnerMessage2Input.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/deprecation/deprecation.proto

/* eslint-disable */

import { builder } from "../../builder";

export const NotDeprecatedMessageNotDeprecatedOneof$Ref = builder.unionType(
  "NotDeprecatedMessageNotDeprecatedOneof",
  {
    types: [
      NotDeprecatedMessageInnerMessage1$Ref,
      NotDeprecatedMessageInnerMessage2$Ref,
    ],
    extensions: {
      protobufOneof: {
        fullName:
          "testapis.deprecation.NotDeprecatedMessage.not_deprecated_oneof",
        name: "not_deprecated_oneof",
        messageName: "NotDeprecatedMessage",
        package: "testapis.deprecation",
        fields: [{
          name: "msg1",
          type: "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
        }, {
          name: "msg2",
          type: "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
        }],
      },
    },
  },
);
",
    "name": "testapis/deprecation/NotDeprecatedMessageNotDeprecatedOneof.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/deprecation/deprecation.proto

/* eslint-disable */

import { builder } from "../../builder";

export const NotDeprecatedMessageDeprecatedOneof$Ref = builder.unionType(
  "NotDeprecatedMessageDeprecatedOneof",
  {
    types: [
      NotDeprecatedMessageInnerMessage1$Ref,
      NotDeprecatedMessageInnerMessage2$Ref,
    ],
    extensions: {
      protobufOneof: {
        fullName: "testapis.deprecation.NotDeprecatedMessage.deprecated_oneof",
        name: "deprecated_oneof",
        messageName: "NotDeprecatedMessage",
        package: "testapis.deprecation",
        fields: [{
          name: "msg3",
          type: "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
        }, {
          name: "msg4",
          type: "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
        }],
      },
    },
  },
);
",
    "name": "testapis/deprecation/NotDeprecatedMessageDeprecatedOneof.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/deprecation/deprecation.proto

/* eslint-disable */

import { builder } from "../../builder";

export const NotDeprecatedEnum$Ref = builder.enumType("NotDeprecatedEnum", {
  values: {
    NOT_DEPRECATED_FOO: {
      value: 1,
      extensions: { protobufEnumValue: { name: "NOT_DEPRECATED_FOO" } },
    },
    DEPRECATED_BAR: {
      deprecationReason:
        "testapis.deprecation.NotDeprecatedEnum.DEPRECATED_BAR is mark as deprecated in a *.proto file.",
      value: 2,
      extensions: {
        protobufEnumValue: {
          name: "DEPRECATED_BAR",
          options: { deprecated: true },
        },
      },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "NotDeprecatedEnum",
      fullName: "testapis.deprecation.NotDeprecatedEnum",
      package: "testapis.deprecation",
    },
  },
});
",
    "name": "testapis/deprecation/NotDeprecatedEnum.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/deprecation/deprecation.proto

/* eslint-disable */

import { builder } from "../../builder";

export const DeprecatedEnum$Ref = builder.enumType("DeprecatedEnum", {
  values: {
    DEPRECATED_BAZ: {
      deprecationReason:
        "testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.",
      value: 1,
      extensions: { protobufEnumValue: { name: "DEPRECATED_BAZ" } },
    },
    DEPRECATED_QUX: {
      deprecationReason:
        "testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.",
      value: 2,
      extensions: { protobufEnumValue: { name: "DEPRECATED_QUX" } },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "DeprecatedEnum",
      fullName: "testapis.deprecation.DeprecatedEnum",
      package: "testapis.deprecation",
      options: { deprecated: true },
    },
  },
});
",
    "name": "testapis/deprecation/DeprecatedEnum.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/deprecation/file_deprecation.proto

/* eslint-disable */

import {
  DeprecatedFileEnum,
  DeprecatedFileMessage,
} from "@testapis/ts-proto/testapis/deprecation/file_deprecation";
import { builder } from "../../builder";
import { DeprecatedFileEnum$Ref } from "./DeprecatedFileEnum.pothos";

export const DeprecatedFileMessage$Ref = builder.objectRef<
  DeprecatedFileMessage
>("DeprecatedFileMessage");
builder.objectType(DeprecatedFileMessage$Ref, {
  name: "DeprecatedFileMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    enum: t.field({
      type: DeprecatedFileEnum$Ref,
      nullable: true,
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      resolve: (source) => {
        if (
          source.enum === DeprecatedFileEnum.DEPRECATED_FILE_ENUM_UNSPECIFIED
        ) {
          return null;
        }

        return source.enum;
      },
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.deprecation.DeprecatedFileEnum",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as DeprecatedFileMessage | { $type: string & {}; }).$type ===
      "testapis.deprecation.DeprecatedFileMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedFileMessage",
      name: "DeprecatedFileMessage",
      package: "testapis.deprecation",
    },
  },
});
",
    "name": "testapis/deprecation/DeprecatedFileMessage.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/deprecation/file_deprecation.proto

/* eslint-disable */

import { DeprecatedFileMessage_InnerMessage } from "@testapis/ts-proto/testapis/deprecation/file_deprecation";
import { builder } from "../../builder";

export const DeprecatedFileMessageInnerMessage$Ref = builder.objectRef<
  DeprecatedFileMessage_InnerMessage
>("DeprecatedFileMessageInnerMessage");
builder.objectType(DeprecatedFileMessageInnerMessage$Ref, {
  name: "DeprecatedFileMessageInnerMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as DeprecatedFileMessage_InnerMessage | {
      $type: string & {};
    }).$type === "testapis.deprecation.DeprecatedFileMessage.InnerMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedFileMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.deprecation",
    },
  },
});
",
    "name": "testapis/deprecation/DeprecatedFileMessageInnerMessage.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/deprecation/file_deprecation.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { DeprecatedFileMessage } from "@testapis/ts-proto/testapis/deprecation/file_deprecation";
import { builder } from "../../builder";
import { DeprecatedFileEnum$Ref } from "./DeprecatedFileEnum.pothos";

export type DeprecatedFileMessageInput$Shape = {
  body?: DeprecatedFileMessage["body"] | null;
  enum?: DeprecatedFileMessage["enum"] | null;
};

export const DeprecatedFileMessageInput$Ref: InputObjectRef<
  DeprecatedFileMessageInput$Shape
> = builder.inputRef<DeprecatedFileMessageInput$Shape>(
  "DeprecatedFileMessageInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: false,
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    enum: t.field({
      type: DeprecatedFileEnum$Ref,
      required: false,
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.deprecation.DeprecatedFileEnum",
        },
      },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedFileMessage",
      name: "DeprecatedFileMessage",
      package: "testapis.deprecation",
    },
  },
});
",
    "name": "testapis/deprecation/DeprecatedFileMessageInput.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/deprecation/file_deprecation.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { DeprecatedFileMessage_InnerMessage } from "@testapis/ts-proto/testapis/deprecation/file_deprecation";
import { builder } from "../../builder";

export type DeprecatedFileMessageInnerMessageInput$Shape = {
  body?: DeprecatedFileMessage_InnerMessage["body"] | null;
};

export const DeprecatedFileMessageInnerMessageInput$Ref: InputObjectRef<
  DeprecatedFileMessageInnerMessageInput$Shape
> = builder.inputRef<DeprecatedFileMessageInnerMessageInput$Shape>(
  "DeprecatedFileMessageInnerMessageInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: false,
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedFileMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.deprecation",
    },
  },
});
",
    "name": "testapis/deprecation/DeprecatedFileMessageInnerMessageInput.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/deprecation/file_deprecation.proto

/* eslint-disable */

import { builder } from "../../builder";

export const DeprecatedFileEnum$Ref = builder.enumType("DeprecatedFileEnum", {
  values: {
    DEPRECATED_FILE_FOO: {
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      value: 1,
      extensions: { protobufEnumValue: { name: "DEPRECATED_FILE_FOO" } },
    },
    DEPRECATED_FILE_BAR: {
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      value: 2,
      extensions: { protobufEnumValue: { name: "DEPRECATED_FILE_BAR" } },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "DeprecatedFileEnum",
      fullName: "testapis.deprecation.DeprecatedFileEnum",
      package: "testapis.deprecation",
    },
  },
});
",
    "name": "testapis/deprecation/DeprecatedFileEnum.pothos.ts",
  },
]
`;

exports[`'testapis.deprecation' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/deprecation/deprecation.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import {
  DeprecatedEnum,
  DeprecatedMessage,
  DeprecatedMessage_InnerMessage,
  NotDeprecatedEnum,
  NotDeprecatedMessage,
  NotDeprecatedMessage_InnerMessage1,
  NotDeprecatedMessage_InnerMessage2,
} from "@testapis/ts-proto/testapis/deprecation/deprecation";
import { builder } from "../../builder";

export const DeprecatedMessage$Ref = builder.objectRef<DeprecatedMessage>(
  "DeprecatedMessage",
);
builder.objectType(DeprecatedMessage$Ref, {
  name: "DeprecatedMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    enum: t.field({
      type: NotDeprecatedEnum$Ref,
      nullable: true,
      deprecationReason:
        "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
      resolve: (source) => {
        if (source.enum === NotDeprecatedEnum.NOT_DEPRECATED_ENUM_UNSPECIFIED) {
          return null;
        }

        return source.enum;
      },
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.deprecation.NotDeprecatedEnum",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as DeprecatedMessage | { $type: string & {}; }).$type ===
      "testapis.deprecation.DeprecatedMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedMessage",
      name: "DeprecatedMessage",
      package: "testapis.deprecation",
      options: { deprecated: true },
    },
  },
});

export const NotDeprecatedMessage$Ref = builder.objectRef<NotDeprecatedMessage>(
  "NotDeprecatedMessage",
);
builder.objectType(NotDeprecatedMessage$Ref, {
  name: "NotDeprecatedMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis.deprecation.NotDeprecatedMessage.body is mark as deprecated in a *.proto file.",
      extensions: {
        protobufField: {
          name: "body",
          typeFullName: "string",
          options: { deprecated: true },
        },
      },
    }),
    enum: t.field({
      type: DeprecatedEnum$Ref,
      nullable: true,
      deprecationReason:
        "testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.",
      resolve: (source) => {
        if (source.enum === DeprecatedEnum.DEPRECATED_ENUM_UNSPECIFIED) {
          return null;
        }

        return source.enum;
      },
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.deprecation.DeprecatedEnum",
        },
      },
    }),
    notDeprecatedOneof: t.field({
      type: NotDeprecatedMessageNotDeprecatedOneof$Ref,
      nullable: true,
      resolve: (source) => {
        const value = source.msg1 ?? source.msg2;
        if (value == null) {
          return null;
        }
        return value;
      },
      extensions: { protobufField: { name: "not_deprecated_oneof" } },
    }),
    deprecatedOneof: t.field({
      type: NotDeprecatedMessageDeprecatedOneof$Ref,
      nullable: true,
      deprecationReason:
        "testapis.deprecation.NotDeprecatedMessage.deprecated_oneof is mark as deprecated in a *.proto file.",
      resolve: (source) => {
        const value = source.msg3 ?? source.msg4;
        if (value == null) {
          return null;
        }
        return value;
      },
      extensions: { protobufField: { name: "deprecated_oneof" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as NotDeprecatedMessage | { $type: string & {}; }).$type ===
      "testapis.deprecation.NotDeprecatedMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.NotDeprecatedMessage",
      name: "NotDeprecatedMessage",
      package: "testapis.deprecation",
    },
  },
});

export const DeprecatedMessageInnerMessage$Ref = builder.objectRef<
  DeprecatedMessage_InnerMessage
>("DeprecatedMessageInnerMessage");
builder.objectType(DeprecatedMessageInnerMessage$Ref, {
  name: "DeprecatedMessageInnerMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as DeprecatedMessage_InnerMessage | { $type: string & {}; })
      .$type === "testapis.deprecation.DeprecatedMessage.InnerMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.deprecation",
    },
  },
});

export const NotDeprecatedMessageInnerMessage1$Ref = builder.objectRef<
  NotDeprecatedMessage_InnerMessage1
>("NotDeprecatedMessageInnerMessage1");
builder.objectType(NotDeprecatedMessageInnerMessage1$Ref, {
  name: "NotDeprecatedMessageInnerMessage1",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as NotDeprecatedMessage_InnerMessage1 | {
      $type: string & {};
    }).$type === "testapis.deprecation.NotDeprecatedMessage.InnerMessage1";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
      name: "InnerMessage1",
      package: "testapis.deprecation",
    },
  },
});

export const NotDeprecatedMessageInnerMessage2$Ref = builder.objectRef<
  NotDeprecatedMessage_InnerMessage2
>("NotDeprecatedMessageInnerMessage2");
builder.objectType(NotDeprecatedMessageInnerMessage2$Ref, {
  name: "NotDeprecatedMessageInnerMessage2",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as NotDeprecatedMessage_InnerMessage2 | {
      $type: string & {};
    }).$type === "testapis.deprecation.NotDeprecatedMessage.InnerMessage2";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
      name: "InnerMessage2",
      package: "testapis.deprecation",
    },
  },
});

export type DeprecatedMessageInput$Shape = {
  body?: DeprecatedMessage["body"] | null;
  enum?: DeprecatedMessage["enum"] | null;
};

export const DeprecatedMessageInput$Ref: InputObjectRef<
  DeprecatedMessageInput$Shape
> = builder.inputRef<DeprecatedMessageInput$Shape>("DeprecatedMessageInput")
  .implement({
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        deprecationReason:
          "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
      enum: t.field({
        type: NotDeprecatedEnum$Ref,
        required: false,
        deprecationReason:
          "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "enum",
            typeFullName: "testapis.deprecation.NotDeprecatedEnum",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.DeprecatedMessage",
        name: "DeprecatedMessage",
        package: "testapis.deprecation",
        options: { deprecated: true },
      },
    },
  });

export type NotDeprecatedMessageInput$Shape = {
  body?: NotDeprecatedMessage["body"] | null;
  enum?: NotDeprecatedMessage["enum"] | null;
  msg1?: NotDeprecatedMessageInnerMessage1Input$Shape | null;
  msg2?: NotDeprecatedMessageInnerMessage2Input$Shape | null;
  msg3?: NotDeprecatedMessageInnerMessage1Input$Shape | null;
  msg4?: NotDeprecatedMessageInnerMessage2Input$Shape | null;
};

export const NotDeprecatedMessageInput$Ref: InputObjectRef<
  NotDeprecatedMessageInput$Shape
> = builder.inputRef<NotDeprecatedMessageInput$Shape>(
  "NotDeprecatedMessageInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: false,
      deprecationReason:
        "testapis.deprecation.NotDeprecatedMessage.body is mark as deprecated in a *.proto file.",
      extensions: {
        protobufField: {
          name: "body",
          typeFullName: "string",
          options: { deprecated: true },
        },
      },
    }),
    enum: t.field({
      type: DeprecatedEnum$Ref,
      required: false,
      deprecationReason:
        "testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.",
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.deprecation.DeprecatedEnum",
        },
      },
    }),
    msg1: t.field({
      type: NotDeprecatedMessageInnerMessage1Input$Ref,
      required: false,
      deprecationReason:
        "testapis.deprecation.NotDeprecatedMessage.msg1 is mark as deprecated in a *.proto file.",
      extensions: {
        protobufField: {
          name: "msg1",
          typeFullName:
            "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
          options: { deprecated: true },
        },
      },
    }),
    msg2: t.field({
      type: NotDeprecatedMessageInnerMessage2Input$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "msg2",
          typeFullName:
            "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
        },
      },
    }),
    msg3: t.field({
      type: NotDeprecatedMessageInnerMessage1Input$Ref,
      required: false,
      deprecationReason:
        "testapis.deprecation.NotDeprecatedMessage.msg3 is mark as deprecated in a *.proto file.",
      extensions: {
        protobufField: {
          name: "msg3",
          typeFullName:
            "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
          options: { deprecated: true },
        },
      },
    }),
    msg4: t.field({
      type: NotDeprecatedMessageInnerMessage2Input$Ref,
      required: false,
      deprecationReason:
        "testapis.deprecation.NotDeprecatedMessage.msg4 is mark as deprecated in a *.proto file.",
      extensions: {
        protobufField: {
          name: "msg4",
          typeFullName:
            "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
          options: { deprecated: true },
        },
      },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.NotDeprecatedMessage",
      name: "NotDeprecatedMessage",
      package: "testapis.deprecation",
    },
  },
});

export type DeprecatedMessageInnerMessageInput$Shape = {
  body?: DeprecatedMessage_InnerMessage["body"] | null;
};

export const DeprecatedMessageInnerMessageInput$Ref: InputObjectRef<
  DeprecatedMessageInnerMessageInput$Shape
> = builder.inputRef<DeprecatedMessageInnerMessageInput$Shape>(
  "DeprecatedMessageInnerMessageInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: false,
      deprecationReason:
        "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.deprecation",
    },
  },
});

export type NotDeprecatedMessageInnerMessage1Input$Shape = {
  body: NotDeprecatedMessage_InnerMessage1["body"];
};

export const NotDeprecatedMessageInnerMessage1Input$Ref: InputObjectRef<
  NotDeprecatedMessageInnerMessage1Input$Shape
> = builder.inputRef<NotDeprecatedMessageInnerMessage1Input$Shape>(
  "NotDeprecatedMessageInnerMessage1Input",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
      name: "InnerMessage1",
      package: "testapis.deprecation",
    },
  },
});

export type NotDeprecatedMessageInnerMessage2Input$Shape = {
  body: NotDeprecatedMessage_InnerMessage2["body"];
};

export const NotDeprecatedMessageInnerMessage2Input$Ref: InputObjectRef<
  NotDeprecatedMessageInnerMessage2Input$Shape
> = builder.inputRef<NotDeprecatedMessageInnerMessage2Input$Shape>(
  "NotDeprecatedMessageInnerMessage2Input",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
      name: "InnerMessage2",
      package: "testapis.deprecation",
    },
  },
});

export const NotDeprecatedMessageNotDeprecatedOneof$Ref = builder.unionType(
  "NotDeprecatedMessageNotDeprecatedOneof",
  {
    types: [
      NotDeprecatedMessageInnerMessage1$Ref,
      NotDeprecatedMessageInnerMessage2$Ref,
    ],
    extensions: {
      protobufOneof: {
        fullName:
          "testapis.deprecation.NotDeprecatedMessage.not_deprecated_oneof",
        name: "not_deprecated_oneof",
        messageName: "NotDeprecatedMessage",
        package: "testapis.deprecation",
        fields: [{
          name: "msg1",
          type: "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
        }, {
          name: "msg2",
          type: "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
        }],
      },
    },
  },
);

export const NotDeprecatedMessageDeprecatedOneof$Ref = builder.unionType(
  "NotDeprecatedMessageDeprecatedOneof",
  {
    types: [
      NotDeprecatedMessageInnerMessage1$Ref,
      NotDeprecatedMessageInnerMessage2$Ref,
    ],
    extensions: {
      protobufOneof: {
        fullName: "testapis.deprecation.NotDeprecatedMessage.deprecated_oneof",
        name: "deprecated_oneof",
        messageName: "NotDeprecatedMessage",
        package: "testapis.deprecation",
        fields: [{
          name: "msg3",
          type: "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
        }, {
          name: "msg4",
          type: "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
        }],
      },
    },
  },
);

export const NotDeprecatedEnum$Ref = builder.enumType("NotDeprecatedEnum", {
  values: {
    NOT_DEPRECATED_FOO: {
      value: 1,
      extensions: { protobufEnumValue: { name: "NOT_DEPRECATED_FOO" } },
    },
    DEPRECATED_BAR: {
      deprecationReason:
        "testapis.deprecation.NotDeprecatedEnum.DEPRECATED_BAR is mark as deprecated in a *.proto file.",
      value: 2,
      extensions: {
        protobufEnumValue: {
          name: "DEPRECATED_BAR",
          options: { deprecated: true },
        },
      },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "NotDeprecatedEnum",
      fullName: "testapis.deprecation.NotDeprecatedEnum",
      package: "testapis.deprecation",
    },
  },
});

export const DeprecatedEnum$Ref = builder.enumType("DeprecatedEnum", {
  values: {
    DEPRECATED_BAZ: {
      deprecationReason:
        "testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.",
      value: 1,
      extensions: { protobufEnumValue: { name: "DEPRECATED_BAZ" } },
    },
    DEPRECATED_QUX: {
      deprecationReason:
        "testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.",
      value: 2,
      extensions: { protobufEnumValue: { name: "DEPRECATED_QUX" } },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "DeprecatedEnum",
      fullName: "testapis.deprecation.DeprecatedEnum",
      package: "testapis.deprecation",
      options: { deprecated: true },
    },
  },
});
",
    "name": "testapis/deprecation/deprecation.pb.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/deprecation/file_deprecation.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import {
  DeprecatedFileEnum,
  DeprecatedFileMessage,
  DeprecatedFileMessage_InnerMessage,
} from "@testapis/ts-proto/testapis/deprecation/file_deprecation";
import { builder } from "../../builder";

export const DeprecatedFileMessage$Ref = builder.objectRef<
  DeprecatedFileMessage
>("DeprecatedFileMessage");
builder.objectType(DeprecatedFileMessage$Ref, {
  name: "DeprecatedFileMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    enum: t.field({
      type: DeprecatedFileEnum$Ref,
      nullable: true,
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      resolve: (source) => {
        if (
          source.enum === DeprecatedFileEnum.DEPRECATED_FILE_ENUM_UNSPECIFIED
        ) {
          return null;
        }

        return source.enum;
      },
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.deprecation.DeprecatedFileEnum",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as DeprecatedFileMessage | { $type: string & {}; }).$type ===
      "testapis.deprecation.DeprecatedFileMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedFileMessage",
      name: "DeprecatedFileMessage",
      package: "testapis.deprecation",
    },
  },
});

export const DeprecatedFileMessageInnerMessage$Ref = builder.objectRef<
  DeprecatedFileMessage_InnerMessage
>("DeprecatedFileMessageInnerMessage");
builder.objectType(DeprecatedFileMessageInnerMessage$Ref, {
  name: "DeprecatedFileMessageInnerMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as DeprecatedFileMessage_InnerMessage | {
      $type: string & {};
    }).$type === "testapis.deprecation.DeprecatedFileMessage.InnerMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedFileMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.deprecation",
    },
  },
});

export type DeprecatedFileMessageInput$Shape = {
  body?: DeprecatedFileMessage["body"] | null;
  enum?: DeprecatedFileMessage["enum"] | null;
};

export const DeprecatedFileMessageInput$Ref: InputObjectRef<
  DeprecatedFileMessageInput$Shape
> = builder.inputRef<DeprecatedFileMessageInput$Shape>(
  "DeprecatedFileMessageInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: false,
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    enum: t.field({
      type: DeprecatedFileEnum$Ref,
      required: false,
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.deprecation.DeprecatedFileEnum",
        },
      },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedFileMessage",
      name: "DeprecatedFileMessage",
      package: "testapis.deprecation",
    },
  },
});

export type DeprecatedFileMessageInnerMessageInput$Shape = {
  body?: DeprecatedFileMessage_InnerMessage["body"] | null;
};

export const DeprecatedFileMessageInnerMessageInput$Ref: InputObjectRef<
  DeprecatedFileMessageInnerMessageInput$Shape
> = builder.inputRef<DeprecatedFileMessageInnerMessageInput$Shape>(
  "DeprecatedFileMessageInnerMessageInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: false,
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedFileMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.deprecation",
    },
  },
});

export const DeprecatedFileEnum$Ref = builder.enumType("DeprecatedFileEnum", {
  values: {
    DEPRECATED_FILE_FOO: {
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      value: 1,
      extensions: { protobufEnumValue: { name: "DEPRECATED_FILE_FOO" } },
    },
    DEPRECATED_FILE_BAR: {
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      value: 2,
      extensions: { protobufEnumValue: { name: "DEPRECATED_FILE_BAR" } },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "DeprecatedFileEnum",
      fullName: "testapis.deprecation.DeprecatedFileEnum",
      package: "testapis.deprecation",
    },
  },
});
",
    "name": "testapis/deprecation/file_deprecation.pb.pothos.ts",
  },
]
`;

exports[`'testapis.deprecation' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/deprecation/deprecation.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import {
  DeprecatedEnum,
  DeprecatedMessage,
  DeprecatedMessage_InnerMessage,
  NotDeprecatedEnum,
  NotDeprecatedMessage,
  NotDeprecatedMessage_InnerMessage1,
  NotDeprecatedMessage_InnerMessage2,
} from "@testapis/ts-proto/testapis/deprecation/deprecation";
import { builder } from "../../builder";

export const DeprecatedMessage$Ref = builder.objectRef<DeprecatedMessage>(
  "DeprecatedMessage",
);
builder.objectType(DeprecatedMessage$Ref, {
  name: "DeprecatedMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    enum: t.field({
      type: NotDeprecatedEnum$Ref,
      nullable: true,
      deprecationReason:
        "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
      resolve: (source) => {
        if (source.enum === NotDeprecatedEnum.NOT_DEPRECATED_ENUM_UNSPECIFIED) {
          return null;
        }

        return source.enum;
      },
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.deprecation.NotDeprecatedEnum",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as DeprecatedMessage | { $type: string & {}; }).$type ===
      "testapis.deprecation.DeprecatedMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedMessage",
      name: "DeprecatedMessage",
      package: "testapis.deprecation",
      options: { deprecated: true },
    },
  },
});

export const NotDeprecatedMessage$Ref = builder.objectRef<NotDeprecatedMessage>(
  "NotDeprecatedMessage",
);
builder.objectType(NotDeprecatedMessage$Ref, {
  name: "NotDeprecatedMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis.deprecation.NotDeprecatedMessage.body is mark as deprecated in a *.proto file.",
      extensions: {
        protobufField: {
          name: "body",
          typeFullName: "string",
          options: { deprecated: true },
        },
      },
    }),
    enum: t.field({
      type: DeprecatedEnum$Ref,
      nullable: true,
      deprecationReason:
        "testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.",
      resolve: (source) => {
        if (source.enum === DeprecatedEnum.DEPRECATED_ENUM_UNSPECIFIED) {
          return null;
        }

        return source.enum;
      },
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.deprecation.DeprecatedEnum",
        },
      },
    }),
    notDeprecatedOneof: t.field({
      type: NotDeprecatedMessageNotDeprecatedOneof$Ref,
      nullable: true,
      resolve: (source) => {
        const value = source.msg1 ?? source.msg2;
        if (value == null) {
          return null;
        }
        return value;
      },
      extensions: { protobufField: { name: "not_deprecated_oneof" } },
    }),
    deprecatedOneof: t.field({
      type: NotDeprecatedMessageDeprecatedOneof$Ref,
      nullable: true,
      deprecationReason:
        "testapis.deprecation.NotDeprecatedMessage.deprecated_oneof is mark as deprecated in a *.proto file.",
      resolve: (source) => {
        const value = source.msg3 ?? source.msg4;
        if (value == null) {
          return null;
        }
        return value;
      },
      extensions: { protobufField: { name: "deprecated_oneof" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as NotDeprecatedMessage | { $type: string & {}; }).$type ===
      "testapis.deprecation.NotDeprecatedMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.NotDeprecatedMessage",
      name: "NotDeprecatedMessage",
      package: "testapis.deprecation",
    },
  },
});

export const DeprecatedMessageInnerMessage$Ref = builder.objectRef<
  DeprecatedMessage_InnerMessage
>("DeprecatedMessageInnerMessage");
builder.objectType(DeprecatedMessageInnerMessage$Ref, {
  name: "DeprecatedMessageInnerMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as DeprecatedMessage_InnerMessage | { $type: string & {}; })
      .$type === "testapis.deprecation.DeprecatedMessage.InnerMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.deprecation",
    },
  },
});

export const NotDeprecatedMessageInnerMessage1$Ref = builder.objectRef<
  NotDeprecatedMessage_InnerMessage1
>("NotDeprecatedMessageInnerMessage1");
builder.objectType(NotDeprecatedMessageInnerMessage1$Ref, {
  name: "NotDeprecatedMessageInnerMessage1",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as NotDeprecatedMessage_InnerMessage1 | {
      $type: string & {};
    }).$type === "testapis.deprecation.NotDeprecatedMessage.InnerMessage1";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
      name: "InnerMessage1",
      package: "testapis.deprecation",
    },
  },
});

export const NotDeprecatedMessageInnerMessage2$Ref = builder.objectRef<
  NotDeprecatedMessage_InnerMessage2
>("NotDeprecatedMessageInnerMessage2");
builder.objectType(NotDeprecatedMessageInnerMessage2$Ref, {
  name: "NotDeprecatedMessageInnerMessage2",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as NotDeprecatedMessage_InnerMessage2 | {
      $type: string & {};
    }).$type === "testapis.deprecation.NotDeprecatedMessage.InnerMessage2";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
      name: "InnerMessage2",
      package: "testapis.deprecation",
    },
  },
});

export type DeprecatedMessageInput$Shape = {
  body?: DeprecatedMessage["body"] | null;
  enum?: DeprecatedMessage["enum"] | null;
};

export const DeprecatedMessageInput$Ref: InputObjectRef<
  DeprecatedMessageInput$Shape
> = builder.inputRef<DeprecatedMessageInput$Shape>("DeprecatedMessageInput")
  .implement({
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        deprecationReason:
          "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
      enum: t.field({
        type: NotDeprecatedEnum$Ref,
        required: false,
        deprecationReason:
          "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "enum",
            typeFullName: "testapis.deprecation.NotDeprecatedEnum",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.DeprecatedMessage",
        name: "DeprecatedMessage",
        package: "testapis.deprecation",
        options: { deprecated: true },
      },
    },
  });

export type DeprecatedMessagePartialInput$Shape = {
  body?: DeprecatedMessage["body"] | null;
  enum?: DeprecatedMessage["enum"] | null;
};

export const DeprecatedMessagePartialInput$Ref: InputObjectRef<
  DeprecatedMessagePartialInput$Shape
> = builder.inputRef<DeprecatedMessagePartialInput$Shape>(
  "DeprecatedMessagePartialInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: false,
      deprecationReason:
        "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    enum: t.field({
      type: NotDeprecatedEnum$Ref,
      required: false,
      deprecationReason:
        "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.deprecation.NotDeprecatedEnum",
        },
      },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedMessage",
      name: "DeprecatedMessage",
      package: "testapis.deprecation",
      options: { deprecated: true },
    },
  },
});

export type NotDeprecatedMessageInput$Shape = {
  body?: NotDeprecatedMessage["body"] | null;
  enum?: NotDeprecatedMessage["enum"] | null;
  msg1?: NotDeprecatedMessageInnerMessage1Input$Shape | null;
  msg2?: NotDeprecatedMessageInnerMessage2Input$Shape | null;
  msg3?: NotDeprecatedMessageInnerMessage1Input$Shape | null;
  msg4?: NotDeprecatedMessageInnerMessage2Input$Shape | null;
};

export const NotDeprecatedMessageInput$Ref: InputObjectRef<
  NotDeprecatedMessageInput$Shape
> = builder.inputRef<NotDeprecatedMessageInput$Shape>(
  "NotDeprecatedMessageInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: false,
      deprecationReason:
        "testapis.deprecation.NotDeprecatedMessage.body is mark as deprecated in a *.proto file.",
      extensions: {
        protobufField: {
          name: "body",
          typeFullName: "string",
          options: { deprecated: true },
        },
      },
    }),
    enum: t.field({
      type: DeprecatedEnum$Ref,
      required: false,
      deprecationReason:
        "testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.",
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.deprecation.DeprecatedEnum",
        },
      },
    }),
    msg1: t.field({
      type: NotDeprecatedMessageInnerMessage1Input$Ref,
      required: false,
      deprecationReason:
        "testapis.deprecation.NotDeprecatedMessage.msg1 is mark as deprecated in a *.proto file.",
      extensions: {
        protobufField: {
          name: "msg1",
          typeFullName:
            "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
          options: { deprecated: true },
        },
      },
    }),
    msg2: t.field({
      type: NotDeprecatedMessageInnerMessage2Input$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "msg2",
          typeFullName:
            "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
        },
      },
    }),
    msg3: t.field({
      type: NotDeprecatedMessageInnerMessage1Input$Ref,
      required: false,
      deprecationReason:
        "testapis.deprecation.NotDeprecatedMessage.msg3 is mark as deprecated in a *.proto file.",
      extensions: {
        protobufField: {
          name: "msg3",
          typeFullName:
            "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
          options: { deprecated: true },
        },
      },
    }),
    msg4: t.field({
      type: NotDeprecatedMessageInnerMessage2Input$Ref,
      required: false,
      deprecationReason:
        "testapis.deprecation.NotDeprecatedMessage.msg4 is mark as deprecated in a *.proto file.",
      extensions: {
        protobufField: {
          name: "msg4",
          typeFullName:
            "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
          options: { deprecated: true },
        },
      },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.NotDeprecatedMessage",
      name: "NotDeprecatedMessage",
      package: "testapis.deprecation",
    },
  },
});

export type NotDeprecatedMessagePartialInput$Shape = {
  body?: NotDeprecatedMessage["body"] | null;
  enum?: NotDeprecatedMessage["enum"] | null;
  msg1?: NotDeprecatedMessageInnerMessage1PartialInput$Shape | null;
  msg2?: NotDeprecatedMessageInnerMessage2PartialInput$Shape | null;
  msg3?: NotDeprecatedMessageInnerMessage1PartialInput$Shape | null;
  msg4?: NotDeprecatedMessageInnerMessage2PartialInput$Shape | null;
};

export const NotDeprecatedMessagePartialInput$Ref: InputObjectRef<
  NotDeprecatedMessagePartialInput$Shape
> = builder.inputRef<NotDeprecatedMessagePartialInput$Shape>(
  "NotDeprecatedMessagePartialInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: false,
      deprecationReason:
        "testapis.deprecation.NotDeprecatedMessage.body is mark as deprecated in a *.proto file.",
      extensions: {
        protobufField: {
          name: "body",
          typeFullName: "string",
          options: { deprecated: true },
        },
      },
    }),
    enum: t.field({
      type: DeprecatedEnum$Ref,
      required: false,
      deprecationReason:
        "testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.",
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.deprecation.DeprecatedEnum",
        },
      },
    }),
    msg1: t.field({
      type: NotDeprecatedMessageInnerMessage1PartialInput$Ref,
      required: false,
      deprecationReason:
        "testapis.deprecation.NotDeprecatedMessage.msg1 is mark as deprecated in a *.proto file.",
      extensions: {
        protobufField: {
          name: "msg1",
          typeFullName:
            "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
          options: { deprecated: true },
        },
      },
    }),
    msg2: t.field({
      type: NotDeprecatedMessageInnerMessage2PartialInput$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "msg2",
          typeFullName:
            "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
        },
      },
    }),
    msg3: t.field({
      type: NotDeprecatedMessageInnerMessage1PartialInput$Ref,
      required: false,
      deprecationReason:
        "testapis.deprecation.NotDeprecatedMessage.msg3 is mark as deprecated in a *.proto file.",
      extensions: {
        protobufField: {
          name: "msg3",
          typeFullName:
            "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
          options: { deprecated: true },
        },
      },
    }),
    msg4: t.field({
      type: NotDeprecatedMessageInnerMessage2PartialInput$Ref,
      required: false,
      deprecationReason:
        "testapis.deprecation.NotDeprecatedMessage.msg4 is mark as deprecated in a *.proto file.",
      extensions: {
        protobufField: {
          name: "msg4",
          typeFullName:
            "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
          options: { deprecated: true },
        },
      },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.NotDeprecatedMessage",
      name: "NotDeprecatedMessage",
      package: "testapis.deprecation",
    },
  },
});

export type DeprecatedMessageInnerMessageInput$Shape = {
  body?: DeprecatedMessage_InnerMessage["body"] | null;
};

export const DeprecatedMessageInnerMessageInput$Ref: InputObjectRef<
  DeprecatedMessageInnerMessageInput$Shape
> = builder.inputRef<DeprecatedMessageInnerMessageInput$Shape>(
  "DeprecatedMessageInnerMessageInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: false,
      deprecationReason:
        "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.deprecation",
    },
  },
});

export type DeprecatedMessageInnerMessagePartialInput$Shape = {
  body?: DeprecatedMessage_InnerMessage["body"] | null;
};

export const DeprecatedMessageInnerMessagePartialInput$Ref: InputObjectRef<
  DeprecatedMessageInnerMessagePartialInput$Shape
> = builder.inputRef<DeprecatedMessageInnerMessagePartialInput$Shape>(
  "DeprecatedMessageInnerMessagePartialInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: false,
      deprecationReason:
        "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.deprecation",
    },
  },
});

export type NotDeprecatedMessageInnerMessage1Input$Shape = {
  body: NotDeprecatedMessage_InnerMessage1["body"];
};

export const NotDeprecatedMessageInnerMessage1Input$Ref: InputObjectRef<
  NotDeprecatedMessageInnerMessage1Input$Shape
> = builder.inputRef<NotDeprecatedMessageInnerMessage1Input$Shape>(
  "NotDeprecatedMessageInnerMessage1Input",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
      name: "InnerMessage1",
      package: "testapis.deprecation",
    },
  },
});

export type NotDeprecatedMessageInnerMessage1PartialInput$Shape = {
  body?: NotDeprecatedMessage_InnerMessage1["body"] | null;
};

export const NotDeprecatedMessageInnerMessage1PartialInput$Ref: InputObjectRef<
  NotDeprecatedMessageInnerMessage1PartialInput$Shape
> = builder.inputRef<NotDeprecatedMessageInnerMessage1PartialInput$Shape>(
  "NotDeprecatedMessageInnerMessage1PartialInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
      name: "InnerMessage1",
      package: "testapis.deprecation",
    },
  },
});

export type NotDeprecatedMessageInnerMessage2Input$Shape = {
  body: NotDeprecatedMessage_InnerMessage2["body"];
};

export const NotDeprecatedMessageInnerMessage2Input$Ref: InputObjectRef<
  NotDeprecatedMessageInnerMessage2Input$Shape
> = builder.inputRef<NotDeprecatedMessageInnerMessage2Input$Shape>(
  "NotDeprecatedMessageInnerMessage2Input",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
      name: "InnerMessage2",
      package: "testapis.deprecation",
    },
  },
});

export type NotDeprecatedMessageInnerMessage2PartialInput$Shape = {
  body?: NotDeprecatedMessage_InnerMessage2["body"] | null;
};

export const NotDeprecatedMessageInnerMessage2PartialInput$Ref: InputObjectRef<
  NotDeprecatedMessageInnerMessage2PartialInput$Shape
> = builder.inputRef<NotDeprecatedMessageInnerMessage2PartialInput$Shape>(
  "NotDeprecatedMessageInnerMessage2PartialInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
      name: "InnerMessage2",
      package: "testapis.deprecation",
    },
  },
});

export const NotDeprecatedMessageNotDeprecatedOneof$Ref = builder.unionType(
  "NotDeprecatedMessageNotDeprecatedOneof",
  {
    types: [
      NotDeprecatedMessageInnerMessage1$Ref,
      NotDeprecatedMessageInnerMessage2$Ref,
    ],
    extensions: {
      protobufOneof: {
        fullName:
          "testapis.deprecation.NotDeprecatedMessage.not_deprecated_oneof",
        name: "not_deprecated_oneof",
        messageName: "NotDeprecatedMessage",
        package: "testapis.deprecation",
        fields: [{
          name: "msg1",
          type: "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
        }, {
          name: "msg2",
          type: "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
        }],
      },
    },
  },
);

export const NotDeprecatedMessageDeprecatedOneof$Ref = builder.unionType(
  "NotDeprecatedMessageDeprecatedOneof",
  {
    types: [
      NotDeprecatedMessageInnerMessage1$Ref,
      NotDeprecatedMessageInnerMessage2$Ref,
    ],
    extensions: {
      protobufOneof: {
        fullName: "testapis.deprecation.NotDeprecatedMessage.deprecated_oneof",
        name: "deprecated_oneof",
        messageName: "NotDeprecatedMessage",
        package: "testapis.deprecation",
        fields: [{
          name: "msg3",
          type: "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
        }, {
          name: "msg4",
          type: "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
        }],
      },
    },
  },
);

export const NotDeprecatedEnum$Ref = builder.enumType("NotDeprecatedEnum", {
  values: {
    NOT_DEPRECATED_FOO: {
      value: 1,
      extensions: { protobufEnumValue: { name: "NOT_DEPRECATED_FOO" } },
    },
    DEPRECATED_BAR: {
      deprecationReason:
        "testapis.deprecation.NotDeprecatedEnum.DEPRECATED_BAR is mark as deprecated in a *.proto file.",
      value: 2,
      extensions: {
        protobufEnumValue: {
          name: "DEPRECATED_BAR",
          options: { deprecated: true },
        },
      },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "NotDeprecatedEnum",
      fullName: "testapis.deprecation.NotDeprecatedEnum",
      package: "testapis.deprecation",
    },
  },
});

export const DeprecatedEnum$Ref = builder.enumType("DeprecatedEnum", {
  values: {
    DEPRECATED_BAZ: {
      deprecationReason:
        "testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.",
      value: 1,
      extensions: { protobufEnumValue: { name: "DEPRECATED_BAZ" } },
    },
    DEPRECATED_QUX: {
      deprecationReason:
        "testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.",
      value: 2,
      extensions: { protobufEnumValue: { name: "DEPRECATED_QUX" } },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "DeprecatedEnum",
      fullName: "testapis.deprecation.DeprecatedEnum",
      package: "testapis.deprecation",
      options: { deprecated: true },
    },
  },
});
",
    "name": "testapis/deprecation/deprecation.pb.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/deprecation/file_deprecation.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import {
  DeprecatedFileEnum,
  DeprecatedFileMessage,
  DeprecatedFileMessage_InnerMessage,
} from "@testapis/ts-proto/testapis/deprecation/file_deprecation";
import { builder } from "../../builder";

export const DeprecatedFileMessage$Ref = builder.objectRef<
  DeprecatedFileMessage
>("DeprecatedFileMessage");
builder.objectType(DeprecatedFileMessage$Ref, {
  name: "DeprecatedFileMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    enum: t.field({
      type: DeprecatedFileEnum$Ref,
      nullable: true,
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      resolve: (source) => {
        if (
          source.enum === DeprecatedFileEnum.DEPRECATED_FILE_ENUM_UNSPECIFIED
        ) {
          return null;
        }

        return source.enum;
      },
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.deprecation.DeprecatedFileEnum",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as DeprecatedFileMessage | { $type: string & {}; }).$type ===
      "testapis.deprecation.DeprecatedFileMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedFileMessage",
      name: "DeprecatedFileMessage",
      package: "testapis.deprecation",
    },
  },
});

export const DeprecatedFileMessageInnerMessage$Ref = builder.objectRef<
  DeprecatedFileMessage_InnerMessage
>("DeprecatedFileMessageInnerMessage");
builder.objectType(DeprecatedFileMessageInnerMessage$Ref, {
  name: "DeprecatedFileMessageInnerMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as DeprecatedFileMessage_InnerMessage | {
      $type: string & {};
    }).$type === "testapis.deprecation.DeprecatedFileMessage.InnerMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedFileMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.deprecation",
    },
  },
});

export type DeprecatedFileMessageInput$Shape = {
  body?: DeprecatedFileMessage["body"] | null;
  enum?: DeprecatedFileMessage["enum"] | null;
};

export const DeprecatedFileMessageInput$Ref: InputObjectRef<
  DeprecatedFileMessageInput$Shape
> = builder.inputRef<DeprecatedFileMessageInput$Shape>(
  "DeprecatedFileMessageInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: false,
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    enum: t.field({
      type: DeprecatedFileEnum$Ref,
      required: false,
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.deprecation.DeprecatedFileEnum",
        },
      },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedFileMessage",
      name: "DeprecatedFileMessage",
      package: "testapis.deprecation",
    },
  },
});

export type DeprecatedFileMessagePartialInput$Shape = {
  body?: DeprecatedFileMessage["body"] | null;
  enum?: DeprecatedFileMessage["enum"] | null;
};

export const DeprecatedFileMessagePartialInput$Ref: InputObjectRef<
  DeprecatedFileMessagePartialInput$Shape
> = builder.inputRef<DeprecatedFileMessagePartialInput$Shape>(
  "DeprecatedFileMessagePartialInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: false,
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    enum: t.field({
      type: DeprecatedFileEnum$Ref,
      required: false,
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.deprecation.DeprecatedFileEnum",
        },
      },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedFileMessage",
      name: "DeprecatedFileMessage",
      package: "testapis.deprecation",
    },
  },
});

export type DeprecatedFileMessageInnerMessageInput$Shape = {
  body?: DeprecatedFileMessage_InnerMessage["body"] | null;
};

export const DeprecatedFileMessageInnerMessageInput$Ref: InputObjectRef<
  DeprecatedFileMessageInnerMessageInput$Shape
> = builder.inputRef<DeprecatedFileMessageInnerMessageInput$Shape>(
  "DeprecatedFileMessageInnerMessageInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: false,
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedFileMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.deprecation",
    },
  },
});

export type DeprecatedFileMessageInnerMessagePartialInput$Shape = {
  body?: DeprecatedFileMessage_InnerMessage["body"] | null;
};

export const DeprecatedFileMessageInnerMessagePartialInput$Ref: InputObjectRef<
  DeprecatedFileMessageInnerMessagePartialInput$Shape
> = builder.inputRef<DeprecatedFileMessageInnerMessagePartialInput$Shape>(
  "DeprecatedFileMessageInnerMessagePartialInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: false,
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedFileMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.deprecation",
    },
  },
});

export const DeprecatedFileEnum$Ref = builder.enumType("DeprecatedFileEnum", {
  values: {
    DEPRECATED_FILE_FOO: {
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      value: 1,
      extensions: { protobufEnumValue: { name: "DEPRECATED_FILE_FOO" } },
    },
    DEPRECATED_FILE_BAR: {
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      value: 2,
      extensions: { protobufEnumValue: { name: "DEPRECATED_FILE_BAR" } },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "DeprecatedFileEnum",
      fullName: "testapis.deprecation.DeprecatedFileEnum",
      package: "testapis.deprecation",
    },
  },
});
",
    "name": "testapis/deprecation/file_deprecation.pb.pothos.ts",
  },
]
`;

exports[`'testapis.deprecation' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/deprecation/deprecation.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import {
  DeprecatedEnum,
  DeprecatedMessage,
  DeprecatedMessage_InnerMessage,
  NotDeprecatedEnum,
  NotDeprecatedMessage,
  NotDeprecatedMessage_InnerMessage1,
  NotDeprecatedMessage_InnerMessage2,
} from "./testapis/deprecation/deprecation";

export const DeprecatedMessage$Ref = builder.objectRef<DeprecatedMessage>(
  "DeprecatedMessage",
);
builder.objectType(DeprecatedMessage$Ref, {
  name: "DeprecatedMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    enum: t.field({
      type: NotDeprecatedEnum$Ref,
      nullable: true,
      deprecationReason:
        "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
      resolve: (source) => {
        if (source.enum === NotDeprecatedEnum.NOT_DEPRECATED_ENUM_UNSPECIFIED) {
          return null;
        }

        return source.enum;
      },
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.deprecation.NotDeprecatedEnum",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as DeprecatedMessage | { $type: string & {}; }).$type ===
      "testapis.deprecation.DeprecatedMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedMessage",
      name: "DeprecatedMessage",
      package: "testapis.deprecation",
      options: { deprecated: true },
    },
  },
});

export const NotDeprecatedMessage$Ref = builder.objectRef<NotDeprecatedMessage>(
  "NotDeprecatedMessage",
);
builder.objectType(NotDeprecatedMessage$Ref, {
  name: "NotDeprecatedMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis.deprecation.NotDeprecatedMessage.body is mark as deprecated in a *.proto file.",
      extensions: {
        protobufField: {
          name: "body",
          typeFullName: "string",
          options: { deprecated: true },
        },
      },
    }),
    enum: t.field({
      type: DeprecatedEnum$Ref,
      nullable: true,
      deprecationReason:
        "testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.",
      resolve: (source) => {
        if (source.enum === DeprecatedEnum.DEPRECATED_ENUM_UNSPECIFIED) {
          return null;
        }

        return source.enum;
      },
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.deprecation.DeprecatedEnum",
        },
      },
    }),
    notDeprecatedOneof: t.field({
      type: NotDeprecatedMessageNotDeprecatedOneof$Ref,
      nullable: true,
      resolve: (source) => {
        const value = source.msg1 ?? source.msg2;
        if (value == null) {
          return null;
        }
        return value;
      },
      extensions: { protobufField: { name: "not_deprecated_oneof" } },
    }),
    deprecatedOneof: t.field({
      type: NotDeprecatedMessageDeprecatedOneof$Ref,
      nullable: true,
      deprecationReason:
        "testapis.deprecation.NotDeprecatedMessage.deprecated_oneof is mark as deprecated in a *.proto file.",
      resolve: (source) => {
        const value = source.msg3 ?? source.msg4;
        if (value == null) {
          return null;
        }
        return value;
      },
      extensions: { protobufField: { name: "deprecated_oneof" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as NotDeprecatedMessage | { $type: string & {}; }).$type ===
      "testapis.deprecation.NotDeprecatedMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.NotDeprecatedMessage",
      name: "NotDeprecatedMessage",
      package: "testapis.deprecation",
    },
  },
});

export const DeprecatedMessageInnerMessage$Ref = builder.objectRef<
  DeprecatedMessage_InnerMessage
>("DeprecatedMessageInnerMessage");
builder.objectType(DeprecatedMessageInnerMessage$Ref, {
  name: "DeprecatedMessageInnerMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as DeprecatedMessage_InnerMessage | { $type: string & {}; })
      .$type === "testapis.deprecation.DeprecatedMessage.InnerMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.deprecation",
    },
  },
});

export const NotDeprecatedMessageInnerMessage1$Ref = builder.objectRef<
  NotDeprecatedMessage_InnerMessage1
>("NotDeprecatedMessageInnerMessage1");
builder.objectType(NotDeprecatedMessageInnerMessage1$Ref, {
  name: "NotDeprecatedMessageInnerMessage1",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as NotDeprecatedMessage_InnerMessage1 | {
      $type: string & {};
    }).$type === "testapis.deprecation.NotDeprecatedMessage.InnerMessage1";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
      name: "InnerMessage1",
      package: "testapis.deprecation",
    },
  },
});

export const NotDeprecatedMessageInnerMessage2$Ref = builder.objectRef<
  NotDeprecatedMessage_InnerMessage2
>("NotDeprecatedMessageInnerMessage2");
builder.objectType(NotDeprecatedMessageInnerMessage2$Ref, {
  name: "NotDeprecatedMessageInnerMessage2",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as NotDeprecatedMessage_InnerMessage2 | {
      $type: string & {};
    }).$type === "testapis.deprecation.NotDeprecatedMessage.InnerMessage2";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
      name: "InnerMessage2",
      package: "testapis.deprecation",
    },
  },
});

export type DeprecatedMessageInput$Shape = {
  body?: DeprecatedMessage["body"] | null;
  enum?: DeprecatedMessage["enum"] | null;
};

export const DeprecatedMessageInput$Ref: InputObjectRef<
  DeprecatedMessageInput$Shape
> = builder.inputRef<DeprecatedMessageInput$Shape>("DeprecatedMessageInput")
  .implement({
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        deprecationReason:
          "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
      enum: t.field({
        type: NotDeprecatedEnum$Ref,
        required: false,
        deprecationReason:
          "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "enum",
            typeFullName: "testapis.deprecation.NotDeprecatedEnum",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.DeprecatedMessage",
        name: "DeprecatedMessage",
        package: "testapis.deprecation",
        options: { deprecated: true },
      },
    },
  });

export type NotDeprecatedMessageInput$Shape = {
  body?: NotDeprecatedMessage["body"] | null;
  enum?: NotDeprecatedMessage["enum"] | null;
  msg1?: NotDeprecatedMessageInnerMessage1Input$Shape | null;
  msg2?: NotDeprecatedMessageInnerMessage2Input$Shape | null;
  msg3?: NotDeprecatedMessageInnerMessage1Input$Shape | null;
  msg4?: NotDeprecatedMessageInnerMessage2Input$Shape | null;
};

export const NotDeprecatedMessageInput$Ref: InputObjectRef<
  NotDeprecatedMessageInput$Shape
> = builder.inputRef<NotDeprecatedMessageInput$Shape>(
  "NotDeprecatedMessageInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: false,
      deprecationReason:
        "testapis.deprecation.NotDeprecatedMessage.body is mark as deprecated in a *.proto file.",
      extensions: {
        protobufField: {
          name: "body",
          typeFullName: "string",
          options: { deprecated: true },
        },
      },
    }),
    enum: t.field({
      type: DeprecatedEnum$Ref,
      required: false,
      deprecationReason:
        "testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.",
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.deprecation.DeprecatedEnum",
        },
      },
    }),
    msg1: t.field({
      type: NotDeprecatedMessageInnerMessage1Input$Ref,
      required: false,
      deprecationReason:
        "testapis.deprecation.NotDeprecatedMessage.msg1 is mark as deprecated in a *.proto file.",
      extensions: {
        protobufField: {
          name: "msg1",
          typeFullName:
            "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
          options: { deprecated: true },
        },
      },
    }),
    msg2: t.field({
      type: NotDeprecatedMessageInnerMessage2Input$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "msg2",
          typeFullName:
            "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
        },
      },
    }),
    msg3: t.field({
      type: NotDeprecatedMessageInnerMessage1Input$Ref,
      required: false,
      deprecationReason:
        "testapis.deprecation.NotDeprecatedMessage.msg3 is mark as deprecated in a *.proto file.",
      extensions: {
        protobufField: {
          name: "msg3",
          typeFullName:
            "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
          options: { deprecated: true },
        },
      },
    }),
    msg4: t.field({
      type: NotDeprecatedMessageInnerMessage2Input$Ref,
      required: false,
      deprecationReason:
        "testapis.deprecation.NotDeprecatedMessage.msg4 is mark as deprecated in a *.proto file.",
      extensions: {
        protobufField: {
          name: "msg4",
          typeFullName:
            "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
          options: { deprecated: true },
        },
      },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.NotDeprecatedMessage",
      name: "NotDeprecatedMessage",
      package: "testapis.deprecation",
    },
  },
});

export type DeprecatedMessageInnerMessageInput$Shape = {
  body?: DeprecatedMessage_InnerMessage["body"] | null;
};

export const DeprecatedMessageInnerMessageInput$Ref: InputObjectRef<
  DeprecatedMessageInnerMessageInput$Shape
> = builder.inputRef<DeprecatedMessageInnerMessageInput$Shape>(
  "DeprecatedMessageInnerMessageInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: false,
      deprecationReason:
        "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.deprecation",
    },
  },
});

export type NotDeprecatedMessageInnerMessage1Input$Shape = {
  body: NotDeprecatedMessage_InnerMessage1["body"];
};

export const NotDeprecatedMessageInnerMessage1Input$Ref: InputObjectRef<
  NotDeprecatedMessageInnerMessage1Input$Shape
> = builder.inputRef<NotDeprecatedMessageInnerMessage1Input$Shape>(
  "NotDeprecatedMessageInnerMessage1Input",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
      name: "InnerMessage1",
      package: "testapis.deprecation",
    },
  },
});

export type NotDeprecatedMessageInnerMessage2Input$Shape = {
  body: NotDeprecatedMessage_InnerMessage2["body"];
};

export const NotDeprecatedMessageInnerMessage2Input$Ref: InputObjectRef<
  NotDeprecatedMessageInnerMessage2Input$Shape
> = builder.inputRef<NotDeprecatedMessageInnerMessage2Input$Shape>(
  "NotDeprecatedMessageInnerMessage2Input",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
      name: "InnerMessage2",
      package: "testapis.deprecation",
    },
  },
});

export const NotDeprecatedMessageNotDeprecatedOneof$Ref = builder.unionType(
  "NotDeprecatedMessageNotDeprecatedOneof",
  {
    types: [
      NotDeprecatedMessageInnerMessage1$Ref,
      NotDeprecatedMessageInnerMessage2$Ref,
    ],
    extensions: {
      protobufOneof: {
        fullName:
          "testapis.deprecation.NotDeprecatedMessage.not_deprecated_oneof",
        name: "not_deprecated_oneof",
        messageName: "NotDeprecatedMessage",
        package: "testapis.deprecation",
        fields: [{
          name: "msg1",
          type: "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
        }, {
          name: "msg2",
          type: "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
        }],
      },
    },
  },
);

export const NotDeprecatedMessageDeprecatedOneof$Ref = builder.unionType(
  "NotDeprecatedMessageDeprecatedOneof",
  {
    types: [
      NotDeprecatedMessageInnerMessage1$Ref,
      NotDeprecatedMessageInnerMessage2$Ref,
    ],
    extensions: {
      protobufOneof: {
        fullName: "testapis.deprecation.NotDeprecatedMessage.deprecated_oneof",
        name: "deprecated_oneof",
        messageName: "NotDeprecatedMessage",
        package: "testapis.deprecation",
        fields: [{
          name: "msg3",
          type: "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
        }, {
          name: "msg4",
          type: "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
        }],
      },
    },
  },
);

export const NotDeprecatedEnum$Ref = builder.enumType("NotDeprecatedEnum", {
  values: {
    NOT_DEPRECATED_FOO: {
      value: 1,
      extensions: { protobufEnumValue: { name: "NOT_DEPRECATED_FOO" } },
    },
    DEPRECATED_BAR: {
      deprecationReason:
        "testapis.deprecation.NotDeprecatedEnum.DEPRECATED_BAR is mark as deprecated in a *.proto file.",
      value: 2,
      extensions: {
        protobufEnumValue: {
          name: "DEPRECATED_BAR",
          options: { deprecated: true },
        },
      },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "NotDeprecatedEnum",
      fullName: "testapis.deprecation.NotDeprecatedEnum",
      package: "testapis.deprecation",
    },
  },
});

export const DeprecatedEnum$Ref = builder.enumType("DeprecatedEnum", {
  values: {
    DEPRECATED_BAZ: {
      deprecationReason:
        "testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.",
      value: 1,
      extensions: { protobufEnumValue: { name: "DEPRECATED_BAZ" } },
    },
    DEPRECATED_QUX: {
      deprecationReason:
        "testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.",
      value: 2,
      extensions: { protobufEnumValue: { name: "DEPRECATED_QUX" } },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "DeprecatedEnum",
      fullName: "testapis.deprecation.DeprecatedEnum",
      package: "testapis.deprecation",
      options: { deprecated: true },
    },
  },
});
",
    "name": "testapis/deprecation/deprecation.pb.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/deprecation/file_deprecation.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import {
  DeprecatedFileEnum,
  DeprecatedFileMessage,
  DeprecatedFileMessage_InnerMessage,
} from "./testapis/deprecation/file_deprecation";

export const DeprecatedFileMessage$Ref = builder.objectRef<
  DeprecatedFileMessage
>("DeprecatedFileMessage");
builder.objectType(DeprecatedFileMessage$Ref, {
  name: "DeprecatedFileMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    enum: t.field({
      type: DeprecatedFileEnum$Ref,
      nullable: true,
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      resolve: (source) => {
        if (
          source.enum === DeprecatedFileEnum.DEPRECATED_FILE_ENUM_UNSPECIFIED
        ) {
          return null;
        }

        return source.enum;
      },
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.deprecation.DeprecatedFileEnum",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as DeprecatedFileMessage | { $type: string & {}; }).$type ===
      "testapis.deprecation.DeprecatedFileMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedFileMessage",
      name: "DeprecatedFileMessage",
      package: "testapis.deprecation",
    },
  },
});

export const DeprecatedFileMessageInnerMessage$Ref = builder.objectRef<
  DeprecatedFileMessage_InnerMessage
>("DeprecatedFileMessageInnerMessage");
builder.objectType(DeprecatedFileMessageInnerMessage$Ref, {
  name: "DeprecatedFileMessageInnerMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as DeprecatedFileMessage_InnerMessage | {
      $type: string & {};
    }).$type === "testapis.deprecation.DeprecatedFileMessage.InnerMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedFileMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.deprecation",
    },
  },
});

export type DeprecatedFileMessageInput$Shape = {
  body?: DeprecatedFileMessage["body"] | null;
  enum?: DeprecatedFileMessage["enum"] | null;
};

export const DeprecatedFileMessageInput$Ref: InputObjectRef<
  DeprecatedFileMessageInput$Shape
> = builder.inputRef<DeprecatedFileMessageInput$Shape>(
  "DeprecatedFileMessageInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: false,
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    enum: t.field({
      type: DeprecatedFileEnum$Ref,
      required: false,
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.deprecation.DeprecatedFileEnum",
        },
      },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedFileMessage",
      name: "DeprecatedFileMessage",
      package: "testapis.deprecation",
    },
  },
});

export type DeprecatedFileMessageInnerMessageInput$Shape = {
  body?: DeprecatedFileMessage_InnerMessage["body"] | null;
};

export const DeprecatedFileMessageInnerMessageInput$Ref: InputObjectRef<
  DeprecatedFileMessageInnerMessageInput$Shape
> = builder.inputRef<DeprecatedFileMessageInnerMessageInput$Shape>(
  "DeprecatedFileMessageInnerMessageInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: false,
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedFileMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.deprecation",
    },
  },
});

export const DeprecatedFileEnum$Ref = builder.enumType("DeprecatedFileEnum", {
  values: {
    DEPRECATED_FILE_FOO: {
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      value: 1,
      extensions: { protobufEnumValue: { name: "DEPRECATED_FILE_FOO" } },
    },
    DEPRECATED_FILE_BAR: {
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      value: 2,
      extensions: { protobufEnumValue: { name: "DEPRECATED_FILE_BAR" } },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "DeprecatedFileEnum",
      fullName: "testapis.deprecation.DeprecatedFileEnum",
      package: "testapis.deprecation",
    },
  },
});
",
    "name": "testapis/deprecation/file_deprecation.pb.pothos.ts",
  },
]
`;

exports[`'testapis.edgecases.import_from_same_p…' > generates files by plugin 'with graphql_type layout' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_from_same_pkg/child.proto

/* eslint-disable */

import { ChildMessage } from "@testapis/ts-proto/testapis/edgecases/import_from_same_pkg/child";
import { builder } from "../../../builder";

export const ChildMessage$Ref = builder.objectRef<ChildMessage>("ChildMessage");
builder.objectType(ChildMessage$Ref, {
  name: "ChildMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as ChildMessage | { $type: string & {}; }).$type ===
      "testapis.edgecases.import_from_same_pkg.ChildMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.edgecases.import_from_same_pkg.ChildMessage",
      name: "ChildMessage",
      package: "testapis.edgecases.import_from_same_pkg",
    },
  },
});
",
    "name": "testapis/edgecases/import_from_same_pkg/ChildMessage.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_from_same_pkg/child.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { ChildMessage } from "@testapis/ts-proto/testapis/edgecases/import_from_same_pkg/child";
import { builder } from "../../../builder";

export type ChildMessageInput$Shape = { body: ChildMessage["body"]; };

export const ChildMessageInput$Ref: InputObjectRef<ChildMessageInput$Shape> =
  builder.inputRef<ChildMessageInput$Shape>("ChildMessageInput").implement({
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.edgecases.import_from_same_pkg.ChildMessage",
        name: "ChildMessage",
        package: "testapis.edgecases.import_from_same_pkg",
      },
    },
  });
",
    "name": "testapis/edgecases/import_from_same_pkg/ChildMessageInput.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_from_same_pkg/parent.proto

/* eslint-disable */

import { ParentMessage } from "@testapis/ts-proto/testapis/edgecases/import_from_same_pkg/parent";
import { builder } from "../../../builder";
import { ChildMessage$Ref } from "./ChildMessage.pothos";

export const ParentMessage$Ref = builder.objectRef<ParentMessage>(
  "ParentMessage",
);
builder.objectType(ParentMessage$Ref, {
  name: "ParentMessage",
  fields: (t) => ({
    child: t.expose("child", {
      type: ChildMessage$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "child",
          typeFullName: "testapis.edgecases.import_from_same_pkg.ChildMessage",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as ParentMessage | { $type: string & {}; }).$type ===
      "testapis.edgecases.import_from_same_pkg.ParentMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.edgecases.import_from_same_pkg.ParentMessage",
      name: "ParentMessage",
      package: "testapis.edgecases.import_from_same_pkg",
    },
  },
});
",
    "name": "testapis/edgecases/import_from_same_pkg/ParentMessage.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_from_same_pkg/parent.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../../builder";
import {
  ChildMessageInput$Ref,
  ChildMessageInput$Shape,
} from "./ChildMessageInput.pothos";

export type ParentMessageInput$Shape = {
  child?: ChildMessageInput$Shape | null;
};

export const ParentMessageInput$Ref: InputObjectRef<ParentMessageInput$Shape> =
  builder.inputRef<ParentMessageInput$Shape>("ParentMessageInput").implement({
    fields: (t) => ({
      child: t.field({
        type: ChildMessageInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "child",
            typeFullName:
              "testapis.edgecases.import_from_same_pkg.ChildMessage",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.edgecases.import_from_same_pkg.ParentMessage",
        name: "ParentMessage",
        package: "testapis.edgecases.import_from_same_pkg",
      },
    },
  });
",
    "name": "testapis/edgecases/import_from_same_pkg/ParentMessageInput.pothos.ts",
  },
]
`;

exports[`'testapis.edgecases.import_from_same_p…' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_from_same_pkg/child.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { ChildMessage } from "@testapis/ts-proto/testapis/edgecases/import_from_same_pkg/child";
import { builder } from "../../../builder";

export const ChildMessage$Ref = builder.objectRef<ChildMessage>("ChildMessage");
builder.objectType(ChildMessage$Ref, {
  name: "ChildMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as ChildMessage | { $type: string & {}; }).$type ===
      "testapis.edgecases.import_from_same_pkg.ChildMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.edgecases.import_from_same_pkg.ChildMessage",
      name: "ChildMessage",
      package: "testapis.edgecases.import_from_same_pkg",
    },
  },
});

export type ChildMessageInput$Shape = { body: ChildMessage["body"]; };

export const ChildMessageInput$Ref: InputObjectRef<ChildMessageInput$Shape> =
  builder.inputRef<ChildMessageInput$Shape>("ChildMessageInput").implement({
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.edgecases.import_from_same_pkg.ChildMessage",
        name: "ChildMessage",
        package: "testapis.edgecases.import_from_same_pkg",
      },
    },
  });
",
    "name": "testapis/edgecases/import_from_same_pkg/child.pb.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_from_same_pkg/parent.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { ParentMessage } from "@testapis/ts-proto/testapis/edgecases/import_from_same_pkg/parent";
import { builder } from "../../../builder";
import {
  ChildMessage$Ref,
  ChildMessageInput$Ref,
  ChildMessageInput$Shape,
} from "./child.pb.pothos";

export const ParentMessage$Ref = builder.objectRef<ParentMessage>(
  "ParentMessage",
);
builder.objectType(ParentMessage$Ref, {
  name: "ParentMessage",
  fields: (t) => ({
    child: t.expose("child", {
      type: ChildMessage$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "child",
          typeFullName: "testapis.edgecases.import_from_same_pkg.ChildMessage",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as ParentMessage | { $type: string & {}; }).$type ===
      "testapis.edgecases.import_from_same_pkg.ParentMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.edgecases.import_from_same_pkg.ParentMessage",
      name: "ParentMessage",
      package: "testapis.edgecases.import_from_same_pkg",
    },
  },
});

export type ParentMessageInput$Shape = {
  child?: ChildMessageInput$Shape | null;
};

export const ParentMessageInput$Ref: InputObjectRef<ParentMessageInput$Shape> =
  builder.inputRef<ParentMessageInput$Shape>("ParentMessageInput").implement({
    fields: (t) => ({
      child: t.field({
        type: ChildMessageInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "child",
            typeFullName:
              "testapis.edgecases.import_from_same_pkg.ChildMessage",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.edgecases.import_from_same_pkg.ParentMessage",
        name: "ParentMessage",
        package: "testapis.edgecases.import_from_same_pkg",
      },
    },
  });
",
    "name": "testapis/edgecases/import_from_same_pkg/parent.pb.pothos.ts",
  },
]
`;

exports[`'testapis.edgecases.import_from_same_p…' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_from_same_pkg/child.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { ChildMessage } from "@testapis/ts-proto/testapis/edgecases/import_from_same_pkg/child";
import { builder } from "../../../builder";

export const ChildMessage$Ref = builder.objectRef<ChildMessage>("ChildMessage");
builder.objectType(ChildMessage$Ref, {
  name: "ChildMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as ChildMessage | { $type: string & {}; }).$type ===
      "testapis.edgecases.import_from_same_pkg.ChildMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.edgecases.import_from_same_pkg.ChildMessage",
      name: "ChildMessage",
      package: "testapis.edgecases.import_from_same_pkg",
    },
  },
});

export type ChildMessageInput$Shape = { body: ChildMessage["body"]; };

export const ChildMessageInput$Ref: InputObjectRef<ChildMessageInput$Shape> =
  builder.inputRef<ChildMessageInput$Shape>("ChildMessageInput").implement({
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.edgecases.import_from_same_pkg.ChildMessage",
        name: "ChildMessage",
        package: "testapis.edgecases.import_from_same_pkg",
      },
    },
  });

export type ChildMessagePartialInput$Shape = {
  body?: ChildMessage["body"] | null;
};

export const ChildMessagePartialInput$Ref: InputObjectRef<
  ChildMessagePartialInput$Shape
> = builder.inputRef<ChildMessagePartialInput$Shape>("ChildMessagePartialInput")
  .implement({
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.edgecases.import_from_same_pkg.ChildMessage",
        name: "ChildMessage",
        package: "testapis.edgecases.import_from_same_pkg",
      },
    },
  });
",
    "name": "testapis/edgecases/import_from_same_pkg/child.pb.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_from_same_pkg/parent.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { ParentMessage } from "@testapis/ts-proto/testapis/edgecases/import_from_same_pkg/parent";
import { builder } from "../../../builder";
import {
  ChildMessage$Ref,
  ChildMessageInput$Ref,
  ChildMessageInput$Shape,
  ChildMessagePartialInput$Ref,
  ChildMessagePartialInput$Shape,
} from "./child.pb.pothos";

export const ParentMessage$Ref = builder.objectRef<ParentMessage>(
  "ParentMessage",
);
builder.objectType(ParentMessage$Ref, {
  name: "ParentMessage",
  fields: (t) => ({
    child: t.expose("child", {
      type: ChildMessage$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "child",
          typeFullName: "testapis.edgecases.import_from_same_pkg.ChildMessage",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as ParentMessage | { $type: string & {}; }).$type ===
      "testapis.edgecases.import_from_same_pkg.ParentMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.edgecases.import_from_same_pkg.ParentMessage",
      name: "ParentMessage",
      package: "testapis.edgecases.import_from_same_pkg",
    },
  },
});

export type ParentMessageInput$Shape = {
  child?: ChildMessageInput$Shape | null;
};

export const ParentMessageInput$Ref: InputObjectRef<ParentMessageInput$Shape> =
  builder.inputRef<ParentMessageInput$Shape>("ParentMessageInput").implement({
    fields: (t) => ({
      child: t.field({
        type: ChildMessageInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "child",
            typeFullName:
              "testapis.edgecases.import_from_same_pkg.ChildMessage",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.edgecases.import_from_same_pkg.ParentMessage",
        name: "ParentMessage",
        package: "testapis.edgecases.import_from_same_pkg",
      },
    },
  });

export type ParentMessagePartialInput$Shape = {
  child?: ChildMessagePartialInput$Shape | null;
};

export const ParentMessagePartialInput$Ref: InputObjectRef<
  ParentMessagePartialInput$Shape
> = builder.inputRef<ParentMessagePartialInput$Shape>(
  "ParentMessagePartialInput",
).implement({
  fields: (t) => ({
    child: t.field({
      type: ChildMessagePartialInput$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "child",
          typeFullName: "testapis.edgecases.import_from_same_pkg.ChildMessage",
        },
      },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.edgecases.import_from_same_pkg.ParentMessage",
      name: "ParentMessage",
      package: "testapis.edgecases.import_from_same_pkg",
    },
  },
});
",
    "name": "testapis/edgecases/import_from_same_pkg/parent.pb.pothos.ts",
  },
]
`;

exports[`'testapis.edgecases.import_from_same_p…' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_from_same_pkg/child.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../../builder";
import { ChildMessage } from "./testapis/edgecases/import_from_same_pkg/child";

export const ChildMessage$Ref = builder.objectRef<ChildMessage>("ChildMessage");
builder.objectType(ChildMessage$Ref, {
  name: "ChildMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as ChildMessage | { $type: string & {}; }).$type ===
      "testapis.edgecases.import_from_same_pkg.ChildMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.edgecases.import_from_same_pkg.ChildMessage",
      name: "ChildMessage",
      package: "testapis.edgecases.import_from_same_pkg",
    },
  },
});

export type ChildMessageInput$Shape = { body: ChildMessage["body"]; };

export const ChildMessageInput$Ref: InputObjectRef<ChildMessageInput$Shape> =
  builder.inputRef<ChildMessageInput$Shape>("ChildMessageInput").implement({
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.edgecases.import_from_same_pkg.ChildMessage",
        name: "ChildMessage",
        package: "testapis.edgecases.import_from_same_pkg",
      },
    },
  });
",
    "name": "testapis/edgecases/import_from_same_pkg/child.pb.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_from_same_pkg/parent.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../../builder";
import {
  ChildMessage$Ref,
  ChildMessageInput$Ref,
  ChildMessageInput$Shape,
} from "./child.pb.pothos";
import { ParentMessage } from "./testapis/edgecases/import_from_same_pkg/parent";

export const ParentMessage$Ref = builder.objectRef<ParentMessage>(
  "ParentMessage",
);
builder.objectType(ParentMessage$Ref, {
  name: "ParentMessage",
  fields: (t) => ({
    child: t.expose("child", {
      type: ChildMessage$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "child",
          typeFullName: "testapis.edgecases.import_from_same_pkg.ChildMessage",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as ParentMessage | { $type: string & {}; }).$type ===
      "testapis.edgecases.import_from_same_pkg.ParentMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.edgecases.import_from_same_pkg.ParentMessage",
      name: "ParentMessage",
      package: "testapis.edgecases.import_from_same_pkg",
    },
  },
});

export type ParentMessageInput$Shape = {
  child?: ChildMessageInput$Shape | null;
};

export const ParentMessageInput$Ref: InputObjectRef<ParentMessageInput$Shape> =
  builder.inputRef<ParentMessageInput$Shape>("ParentMessageInput").implement({
    fields: (t) => ({
      child: t.field({
        type: ChildMessageInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "child",
            typeFullName:
              "testapis.edgecases.import_from_same_pkg.ChildMessage",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.edgecases.import_from_same_pkg.ParentMessage",
        name: "ParentMessage",
        package: "testapis.edgecases.import_from_same_pkg",
      },
    },
  });
",
    "name": "testapis/edgecases/import_from_same_pkg/parent.pb.pothos.ts",
  },
]
`;

exports[`'testapis.edgecases.import_squashed_un…' > generates files by plugin 'with graphql_type layout' 1`] = `[]`;

exports[`'testapis.edgecases.import_squashed_un…' > generates files by plugin 'with graphql_type layout' 2`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_squashed_union/pkg1/types.proto

/* eslint-disable */

import { OneofMessage1 } from "@testapis/ts-proto/testapis/edgecases/import_squashed_union/pkg1/types";
import { builder } from "../../../../builder";

export const OneofMessage1$Ref = builder.objectRef<OneofMessage1>(
  "OneofMessage1",
);
builder.objectType(OneofMessage1$Ref, {
  name: "OneofMessage1",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as OneofMessage1 | { $type: string & {}; }).$type ===
      "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
      name: "OneofMessage1",
      package: "testapis.edgecases.import_squashed_union.pkg1",
    },
  },
});
",
    "name": "testapis/edgecases/import_squashed_union/pkg1/OneofMessage1.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_squashed_union/pkg1/types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { OneofMessage1 } from "@testapis/ts-proto/testapis/edgecases/import_squashed_union/pkg1/types";
import { builder } from "../../../../builder";

export type OneofMessage1Input$Shape = { body: OneofMessage1["body"]; };

export const OneofMessage1Input$Ref: InputObjectRef<OneofMessage1Input$Shape> =
  builder.inputRef<OneofMessage1Input$Shape>("OneofMessage1Input").implement({
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
        name: "OneofMessage1",
        package: "testapis.edgecases.import_squashed_union.pkg1",
      },
    },
  });
",
    "name": "testapis/edgecases/import_squashed_union/pkg1/OneofMessage1Input.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_squashed_union/pkg1/types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../../../builder";
import {
  OneofMessage1Input$Ref,
  OneofMessage1Input$Shape,
} from "./OneofMessage1Input.pothos";

export type SquashedOneofInput$Shape = {
  msg1?: OneofMessage1Input$Shape | null;
};

export const SquashedOneofInput$Ref: InputObjectRef<SquashedOneofInput$Shape> =
  builder.inputRef<SquashedOneofInput$Shape>("SquashedOneofInput").implement({
    fields: (t) => ({
      msg1: t.field({
        type: OneofMessage1Input$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "msg1",
            typeFullName:
              "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
        name: "SquashedOneof",
        package: "testapis.edgecases.import_squashed_union.pkg1",
        options: { "[graphql.object_type]": { squashUnion: true } },
      },
    },
  });
",
    "name": "testapis/edgecases/import_squashed_union/pkg1/SquashedOneofInput.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_squashed_union/pkg1/types.proto

/* eslint-disable */

import { builder } from "../../../../builder";

export const SquashedOneof$Ref = builder.unionType("SquashedOneof", {
  types: [OneofMessage1$Ref],
  extensions: {
    protobufOneof: {
      fullName: "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
      name: "SquashedOneof",
      package: "testapis.edgecases.import_squashed_union.pkg1",
      fields: [{
        name: "msg1",
        type: "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
        options: { "[graphql.object_type]": { squashUnion: true } },
      }],
    },
  },
});
",
    "name": "testapis/edgecases/import_squashed_union/pkg1/SquashedOneof.pothos.ts",
  },
]
`;

exports[`'testapis.edgecases.import_squashed_un…' > generates files by plugin 'with graphql_type layout' 3`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_squashed_union/pkg2/types.proto

/* eslint-disable */

import { Message } from "@testapis/ts-proto/testapis/edgecases/import_squashed_union/pkg2/types";
import { builder } from "../../../../builder";
import { SquashedOneof$Ref } from "../pkg1/SquashedOneof.pothos";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    msg: t.field({
      type: SquashedOneof$Ref,
      nullable: true,
      resolve: (source) => {
        const value = source.msg?.msg1;
        if (value == null) {
          return null;
        }
        return value;
      },
      extensions: {
        protobufField: {
          name: "msg",
          typeFullName:
            "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Message | { $type: string & {}; }).$type ===
      "testapis.edgecases.import_squashed_union.pkg2.Message";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.edgecases.import_squashed_union.pkg2.Message",
      name: "Message",
      package: "testapis.edgecases.import_squashed_union.pkg2",
    },
  },
});
",
    "name": "testapis/edgecases/import_squashed_union/pkg2/Message.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_squashed_union/pkg2/types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../../../builder";
import {
  SquashedOneofInput$Ref,
  SquashedOneofInput$Shape,
} from "../pkg1/SquashedOneofInput.pothos";

export type MessageInput$Shape = { msg?: SquashedOneofInput$Shape | null; };

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement({
    fields: (t) => ({
      msg: t.field({
        type: SquashedOneofInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "msg",
            typeFullName:
              "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.edgecases.import_squashed_union.pkg2.Message",
        name: "Message",
        package: "testapis.edgecases.import_squashed_union.pkg2",
      },
    },
  });
",
    "name": "testapis/edgecases/import_squashed_union/pkg2/MessageInput.pothos.ts",
  },
]
`;

exports[`'testapis.edgecases.import_squashed_un…' > generates files by plugin 'with import prefix' 1`] = `[]`;

exports[`'testapis.edgecases.import_squashed_un…' > generates files by plugin 'with import prefix' 2`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_squashed_union/pkg1/types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { OneofMessage1 } from "@testapis/ts-proto/testapis/edgecases/import_squashed_union/pkg1/types";
import { builder } from "../../../../builder";

export const OneofMessage1$Ref = builder.objectRef<OneofMessage1>(
  "OneofMessage1",
);
builder.objectType(OneofMessage1$Ref, {
  name: "OneofMessage1",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as OneofMessage1 | { $type: string & {}; }).$type ===
      "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
      name: "OneofMessage1",
      package: "testapis.edgecases.import_squashed_union.pkg1",
    },
  },
});

export type OneofMessage1Input$Shape = { body: OneofMessage1["body"]; };

export const OneofMessage1Input$Ref: InputObjectRef<OneofMessage1Input$Shape> =
  builder.inputRef<OneofMessage1Input$Shape>("OneofMessage1Input").implement({
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
        name: "OneofMessage1",
        package: "testapis.edgecases.import_squashed_union.pkg1",
      },
    },
  });

export type SquashedOneofInput$Shape = {
  msg1?: OneofMessage1Input$Shape | null;
};

export const SquashedOneofInput$Ref: InputObjectRef<SquashedOneofInput$Shape> =
  builder.inputRef<SquashedOneofInput$Shape>("SquashedOneofInput").implement({
    fields: (t) => ({
      msg1: t.field({
        type: OneofMessage1Input$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "msg1",
            typeFullName:
              "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
        name: "SquashedOneof",
        package: "testapis.edgecases.import_squashed_union.pkg1",
        options: { "[graphql.object_type]": { squashUnion: true } },
      },
    },
  });

export const SquashedOneof$Ref = builder.unionType("SquashedOneof", {
  types: [OneofMessage1$Ref],
  extensions: {
    protobufOneof: {
      fullName: "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
      name: "SquashedOneof",
      package: "testapis.edgecases.import_squashed_union.pkg1",
      fields: [{
        name: "msg1",
        type: "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
        options: { "[graphql.object_type]": { squashUnion: true } },
      }],
    },
  },
});
",
    "name": "testapis/edgecases/import_squashed_union/pkg1/types.pb.pothos.ts",
  },
]
`;

exports[`'testapis.edgecases.import_squashed_un…' > generates files by plugin 'with import prefix' 3`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_squashed_union/pkg2/types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { Message } from "@testapis/ts-proto/testapis/edgecases/import_squashed_union/pkg2/types";
import { builder } from "../../../../builder";
import {
  SquashedOneof$Ref,
  SquashedOneofInput$Ref,
  SquashedOneofInput$Shape,
} from "../pkg1/types.pb.pothos";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    msg: t.field({
      type: SquashedOneof$Ref,
      nullable: true,
      resolve: (source) => {
        const value = source.msg?.msg1;
        if (value == null) {
          return null;
        }
        return value;
      },
      extensions: {
        protobufField: {
          name: "msg",
          typeFullName:
            "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Message | { $type: string & {}; }).$type ===
      "testapis.edgecases.import_squashed_union.pkg2.Message";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.edgecases.import_squashed_union.pkg2.Message",
      name: "Message",
      package: "testapis.edgecases.import_squashed_union.pkg2",
    },
  },
});

export type MessageInput$Shape = { msg?: SquashedOneofInput$Shape | null; };

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement({
    fields: (t) => ({
      msg: t.field({
        type: SquashedOneofInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "msg",
            typeFullName:
              "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.edgecases.import_squashed_union.pkg2.Message",
        name: "Message",
        package: "testapis.edgecases.import_squashed_union.pkg2",
      },
    },
  });
",
    "name": "testapis/edgecases/import_squashed_union/pkg2/types.pb.pothos.ts",
  },
]
`;

exports[`'testapis.edgecases.import_squashed_un…' > generates files by plugin 'with partial inputs' 1`] = `[]`;

exports[`'testapis.edgecases.import_squashed_un…' > generates files by plugin 'with partial inputs' 2`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_squashed_union/pkg1/types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { OneofMessage1 } from "@testapis/ts-proto/testapis/edgecases/import_squashed_union/pkg1/types";
import { builder } from "../../../../builder";

export const OneofMessage1$Ref = builder.objectRef<OneofMessage1>(
  "OneofMessage1",
);
builder.objectType(OneofMessage1$Ref, {
  name: "OneofMessage1",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as OneofMessage1 | { $type: string & {}; }).$type ===
      "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
      name: "OneofMessage1",
      package: "testapis.edgecases.import_squashed_union.pkg1",
    },
  },
});

export type OneofMessage1Input$Shape = { body: OneofMessage1["body"]; };

export const OneofMessage1Input$Ref: InputObjectRef<OneofMessage1Input$Shape> =
  builder.inputRef<OneofMessage1Input$Shape>("OneofMessage1Input").implement({
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
        name: "OneofMessage1",
        package: "testapis.edgecases.import_squashed_union.pkg1",
      },
    },
  });

export type OneofMessage1PartialInput$Shape = {
  body?: OneofMessage1["body"] | null;
};

export const OneofMessage1PartialInput$Ref: InputObjectRef<
  OneofMessage1PartialInput$Shape
> = builder.inputRef<OneofMessage1PartialInput$Shape>(
  "OneofMessage1PartialInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
      name: "OneofMessage1",
      package: "testapis.edgecases.import_squashed_union.pkg1",
    },
  },
});

export type SquashedOneofInput$Shape = {
  msg1?: OneofMessage1Input$Shape | null;
};

export const SquashedOneofInput$Ref: InputObjectRef<SquashedOneofInput$Shape> =
  builder.inputRef<SquashedOneofInput$Shape>("SquashedOneofInput").implement({
    fields: (t) => ({
      msg1: t.field({
        type: OneofMessage1Input$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "msg1",
            typeFullName:
              "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
        name: "SquashedOneof",
        package: "testapis.edgecases.import_squashed_union.pkg1",
        options: { "[graphql.object_type]": { squashUnion: true } },
      },
    },
  });

export type SquashedOneofPartialInput$Shape = {
  msg1?: OneofMessage1PartialInput$Shape | null;
};

export const SquashedOneofPartialInput$Ref: InputObjectRef<
  SquashedOneofPartialInput$Shape
> = builder.inputRef<SquashedOneofPartialInput$Shape>(
  "SquashedOneofPartialInput",
).implement({
  fields: (t) => ({
    msg1: t.field({
      type: OneofMessage1PartialInput$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "msg1",
          typeFullName:
            "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
        },
      },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
      name: "SquashedOneof",
      package: "testapis.edgecases.import_squashed_union.pkg1",
      options: { "[graphql.object_type]": { squashUnion: true } },
    },
  },
});

export const SquashedOneof$Ref = builder.unionType("SquashedOneof", {
  types: [OneofMessage1$Ref],
  extensions: {
    protobufOneof: {
      fullName: "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
      name: "SquashedOneof",
      package: "testapis.edgecases.import_squashed_union.pkg1",
      fields: [{
        name: "msg1",
        type: "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
        options: { "[graphql.object_type]": { squashUnion: true } },
      }],
    },
  },
});
",
    "name": "testapis/edgecases/import_squashed_union/pkg1/types.pb.pothos.ts",
  },
]
`;

exports[`'testapis.edgecases.import_squashed_un…' > generates files by plugin 'with partial inputs' 3`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_squashed_union/pkg2/types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { Message } from "@testapis/ts-proto/testapis/edgecases/import_squashed_union/pkg2/types";
import { builder } from "../../../../builder";
import {
  SquashedOneof$Ref,
  SquashedOneofInput$Ref,
  SquashedOneofInput$Shape,
  SquashedOneofPartialInput$Ref,
  SquashedOneofPartialInput$Shape,
} from "../pkg1/types.pb.pothos";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    msg: t.field({
      type: SquashedOneof$Ref,
      nullable: true,
      resolve: (source) => {
        const value = source.msg?.msg1;
        if (value == null) {
          return null;
        }
        return value;
      },
      extensions: {
        protobufField: {
          name: "msg",
          typeFullName:
            "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Message | { $type: string & {}; }).$type ===
      "testapis.edgecases.import_squashed_union.pkg2.Message";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.edgecases.import_squashed_union.pkg2.Message",
      name: "Message",
      package: "testapis.edgecases.import_squashed_union.pkg2",
    },
  },
});

export type MessageInput$Shape = { msg?: SquashedOneofInput$Shape | null; };

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement({
    fields: (t) => ({
      msg: t.field({
        type: SquashedOneofInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "msg",
            typeFullName:
              "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.edgecases.import_squashed_union.pkg2.Message",
        name: "Message",
        package: "testapis.edgecases.import_squashed_union.pkg2",
      },
    },
  });

export type MessagePartialInput$Shape = {
  msg?: SquashedOneofPartialInput$Shape | null;
};

export const MessagePartialInput$Ref: InputObjectRef<
  MessagePartialInput$Shape
> = builder.inputRef<MessagePartialInput$Shape>("MessagePartialInput")
  .implement({
    fields: (t) => ({
      msg: t.field({
        type: SquashedOneofPartialInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "msg",
            typeFullName:
              "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.edgecases.import_squashed_union.pkg2.Message",
        name: "Message",
        package: "testapis.edgecases.import_squashed_union.pkg2",
      },
    },
  });
",
    "name": "testapis/edgecases/import_squashed_union/pkg2/types.pb.pothos.ts",
  },
]
`;

exports[`'testapis.edgecases.import_squashed_un…' > generates files by plugin 'without import prefix' 1`] = `[]`;

exports[`'testapis.edgecases.import_squashed_un…' > generates files by plugin 'without import prefix' 2`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_squashed_union/pkg1/types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../../../builder";
import { OneofMessage1 } from "./testapis/edgecases/import_squashed_union/pkg1/types";

export const OneofMessage1$Ref = builder.objectRef<OneofMessage1>(
  "OneofMessage1",
);
builder.objectType(OneofMessage1$Ref, {
  name: "OneofMessage1",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as OneofMessage1 | { $type: string & {}; }).$type ===
      "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
      name: "OneofMessage1",
      package: "testapis.edgecases.import_squashed_union.pkg1",
    },
  },
});

export type OneofMessage1Input$Shape = { body: OneofMessage1["body"]; };

export const OneofMessage1Input$Ref: InputObjectRef<OneofMessage1Input$Shape> =
  builder.inputRef<OneofMessage1Input$Shape>("OneofMessage1Input").implement({
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
        name: "OneofMessage1",
        package: "testapis.edgecases.import_squashed_union.pkg1",
      },
    },
  });

export type SquashedOneofInput$Shape = {
  msg1?: OneofMessage1Input$Shape | null;
};

export const SquashedOneofInput$Ref: InputObjectRef<SquashedOneofInput$Shape> =
  builder.inputRef<SquashedOneofInput$Shape>("SquashedOneofInput").implement({
    fields: (t) => ({
      msg1: t.field({
        type: OneofMessage1Input$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "msg1",
            typeFullName:
              "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
        name: "SquashedOneof",
        package: "testapis.edgecases.import_squashed_union.pkg1",
        options: { "[graphql.object_type]": { squashUnion: true } },
      },
    },
  });

export const SquashedOneof$Ref = builder.unionType("SquashedOneof", {
  types: [OneofMessage1$Ref],
  extensions: {
    protobufOneof: {
      fullName: "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
      name: "SquashedOneof",
      package: "testapis.edgecases.import_squashed_union.pkg1",
      fields: [{
        name: "msg1",
        type: "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
        options: { "[graphql.object_type]": { squashUnion: true } },
      }],
    },
  },
});
",
    "name": "testapis/edgecases/import_squashed_union/pkg1/types.pb.pothos.ts",
  },
]
`;

exports[`'testapis.edgecases.import_squashed_un…' > generates files by plugin 'without import prefix' 3`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_squashed_union/pkg2/types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../../../builder";
import {
  SquashedOneof$Ref,
  SquashedOneofInput$Ref,
  SquashedOneofInput$Shape,
} from "../pkg1/types.pb.pothos";
import { Message } from "./testapis/edgecases/import_squashed_union/pkg2/types";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    msg: t.field({
      type: SquashedOneof$Ref,
      nullable: true,
      resolve: (source) => {
        const value = source.msg?.msg1;
        if (value == null) {
          return null;
        }
        return value;
      },
      extensions: {
        protobufField: {
          name: "msg",
          typeFullName:
            "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Message | { $type: string & {}; }).$type ===
      "testapis.edgecases.import_squashed_union.pkg2.Message";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.edgecases.import_squashed_union.pkg2.Message",
      name: "Message",
      package: "testapis.edgecases.import_squashed_union.pkg2",
    },
  },
});

export type MessageInput$Shape = { msg?: SquashedOneofInput$Shape | null; };

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement({
    fields: (t) => ({
      msg: t.field({
        type: SquashedOneofInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "msg",
            typeFullName:
              "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.edgecases.import_squashed_union.pkg2.Message",
        name: "Message",
        package: "testapis.edgecases.import_squashed_union.pkg2",
      },
    },
  });
",
    "name": "testapis/edgecases/import_squashed_union/pkg2/types.pb.pothos.ts",
  },
]
`;

exports[`'testapis.empty_types' > generates files by plugin 'with graphql_type layout' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/empty_types/empty.proto

/* eslint-disable */

import { EmptyMessage } from "@testapis/ts-proto/testapis/empty_types/empty";
import { builder } from "../../builder";

export const EmptyMessage$Ref = builder.objectRef<EmptyMessage>("EmptyMessage");
builder.objectType(EmptyMessage$Ref, {
  name: "EmptyMessage",
  fields: (t) => ({
    _: t.field({
      type: "Boolean",
      nullable: true,
      description: "noop field",
      resolve: () => true,
    }),
  }),
  isTypeOf: (source) => {
    return (source as EmptyMessage | { $type: string & {}; }).$type ===
      "testapis.empty_types.EmptyMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.empty_types.EmptyMessage",
      name: "EmptyMessage",
      package: "testapis.empty_types",
    },
  },
});
",
    "name": "testapis/empty_types/EmptyMessage.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/empty_types/empty.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";

export type EmptyMessageInput$Shape = {};

export const EmptyMessageInput$Ref: InputObjectRef<EmptyMessageInput$Shape> =
  builder.inputRef<EmptyMessageInput$Shape>("EmptyMessageInput").implement({
    fields: (t) => ({
      _: t.field({
        type: "Boolean",
        required: false,
        description: "noop field",
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.empty_types.EmptyMessage",
        name: "EmptyMessage",
        package: "testapis.empty_types",
      },
    },
  });
",
    "name": "testapis/empty_types/EmptyMessageInput.pothos.ts",
  },
]
`;

exports[`'testapis.empty_types' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/empty_types/empty.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { EmptyMessage } from "@testapis/ts-proto/testapis/empty_types/empty";
import { builder } from "../../builder";

export const EmptyMessage$Ref = builder.objectRef<EmptyMessage>("EmptyMessage");
builder.objectType(EmptyMessage$Ref, {
  name: "EmptyMessage",
  fields: (t) => ({
    _: t.field({
      type: "Boolean",
      nullable: true,
      description: "noop field",
      resolve: () => true,
    }),
  }),
  isTypeOf: (source) => {
    return (source as EmptyMessage | { $type: string & {}; }).$type ===
      "testapis.empty_types.EmptyMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.empty_types.EmptyMessage",
      name: "EmptyMessage",
      package: "testapis.empty_types",
    },
  },
});

export type EmptyMessageInput$Shape = {};

export const EmptyMessageInput$Ref: InputObjectRef<EmptyMessageInput$Shape> =
  builder.inputRef<EmptyMessageInput$Shape>("EmptyMessageInput").implement({
    fields: (t) => ({
      _: t.field({
        type: "Boolean",
        required: false,
        description: "noop field",
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.empty_types.EmptyMessage",
        name: "EmptyMessage",
        package: "testapis.empty_types",
      },
    },
  });
",
    "name": "testapis/empty_types/empty.pb.pothos.ts",
  },
]
`;

exports[`'testapis.empty_types' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/empty_types/empty.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { EmptyMessage } from "@testapis/ts-proto/testapis/empty_types/empty";
import { builder } from "../../builder";

export const EmptyMessage$Ref = builder.objectRef<EmptyMessage>("EmptyMessage");
builder.objectType(EmptyMessage$Ref, {
  name: "EmptyMessage",
  fields: (t) => ({
    _: t.field({
      type: "Boolean",
      nullable: true,
      description: "noop field",
      resolve: () => true,
    }),
  }),
  isTypeOf: (source) => {
    return (source as EmptyMessage | { $type: string & {}; }).$type ===
      "testapis.empty_types.EmptyMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.empty_types.EmptyMessage",
      name: "EmptyMessage",
      package: "testapis.empty_types",
    },
  },
});

export type EmptyMessageInput$Shape = {};

export const EmptyMessageInput$Ref: InputObjectRef<EmptyMessageInput$Shape> =
  builder.inputRef<EmptyMessageInput$Shape>("EmptyMessageInput").implement({
    fields: (t) => ({
      _: t.field({
        type: "Boolean",
        required: false,
        description: "noop field",
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.empty_types.EmptyMessage",
        name: "EmptyMessage",
        package: "testapis.empty_types",
      },
    },
  });

export type EmptyMessagePartialInput$Shape = {};

export const EmptyMessagePartialInput$Ref: InputObjectRef<
  EmptyMessagePartialInput$Shape
> = builder.inputRef<EmptyMessagePartialInput$Shape>("EmptyMessagePartialInput")
  .implement({
    fields: (t) => ({
      _: t.field({
        type: "Boolean",
        required: false,
        description: "noop field",
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.empty_types.EmptyMessage",
        name: "EmptyMessage",
        package: "testapis.empty_types",
      },
    },
  });
",
    "name": "testapis/empty_types/empty.pb.pothos.ts",
  },
]
`;

exports[`'testapis.empty_types' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/empty_types/empty.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import { EmptyMessage } from "./testapis/empty_types/empty";

export const EmptyMessage$Ref = builder.objectRef<EmptyMessage>("EmptyMessage");
builder.objectType(EmptyMessage$Ref, {
  name: "EmptyMessage",
  fields: (t) => ({
    _: t.field({
      type: "Boolean",
      nullable: true,
      description: "noop field",
      resolve: () => true,
    }),
  }),
  isTypeOf: (source) => {
    return (source as EmptyMessage | { $type: string & {}; }).$type ===
      "testapis.empty_types.EmptyMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.empty_types.EmptyMessage",
      name: "EmptyMessage",
      package: "testapis.empty_types",
    },
  },
});

export type EmptyMessageInput$Shape = {};

export const EmptyMessageInput$Ref: InputObjectRef<EmptyMessageInput$Shape> =
  builder.inputRef<EmptyMessageInput$Shape>("EmptyMessageInput").implement({
    fields: (t) => ({
      _: t.field({
        type: "Boolean",
        required: false,
        description: "noop field",
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.empty_types.EmptyMessage",
        name: "EmptyMessage",
        package: "testapis.empty_types",
      },
    },
  });
",
    "name": "testapis/empty_types/empty.pb.pothos.ts",
  },
]
`;

exports[`'testapis.enums' > generates files by plugin 'with graphql_type layout' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/enums/enums.proto

/* eslint-disable */

import {
  MessageWithEnums,
  MyEnum,
} from "@testapis/ts-proto/testapis/enums/enums";
import { builder } from "../../builder";
import { MyEnum$Ref } from "./MyEnum.pothos";
import { MyEnumWithoutUnspecified$Ref } from "./MyEnumWithoutUnspecified.pothos";

export const MessageWithEnums$Ref = builder.objectRef<MessageWithEnums>(
  "MessageWithEnums",
);
builder.objectType(MessageWithEnums$Ref, {
  name: "MessageWithEnums",
  fields: (t) => ({
    requiredMyEnum: t.field({
      type: MyEnum$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        if (source.requiredMyEnum === MyEnum.MY_ENUM_UNSPECIFIED) {
          throw new Error(
            "requiredMyEnum is required field. But got unspecified.",
          );
        }

        return source.requiredMyEnum;
      },
      extensions: {
        protobufField: {
          name: "required_my_enum",
          typeFullName: "testapi.enums.MyEnum",
        },
      },
    }),
    optionalMyEnum: t.field({
      type: MyEnum$Ref,
      nullable: true,
      description: "Optional.",
      resolve: (source) => {
        if (source.optionalMyEnum === MyEnum.MY_ENUM_UNSPECIFIED) {
          return null;
        }

        return source.optionalMyEnum;
      },
      extensions: {
        protobufField: {
          name: "optional_my_enum",
          typeFullName: "testapi.enums.MyEnum",
        },
      },
    }),
    requiredMyEnumWithoutUnspecified: t.field({
      type: MyEnumWithoutUnspecified$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.requiredMyEnumWithoutUnspecified;
      },
      extensions: {
        protobufField: {
          name: "required_my_enum_without_unspecified",
          typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
        },
      },
    }),
    optionalMyEnumWithoutUnspecified: t.field({
      type: MyEnumWithoutUnspecified$Ref,
      nullable: true,
      description: "Optional.",
      resolve: (source) => {
        return source.optionalMyEnumWithoutUnspecified;
      },
      extensions: {
        protobufField: {
          name: "optional_my_enum_without_unspecified",
          typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
        },
      },
    }),
    requiredMyEnums: t.field({
      type: [MyEnum$Ref],
      nullable: { list: false, items: false },
      description: "Required.",
      resolve: (source) => {
        return source.requiredMyEnums.map((item) => {
          if (item === MyEnum.MY_ENUM_UNSPECIFIED) {
            throw new Error(
              "requiredMyEnums is required field. But got unspecified.",
            );
          }

          return item;
        });
      },
      extensions: {
        protobufField: {
          name: "required_my_enums",
          typeFullName: "testapi.enums.MyEnum",
        },
      },
    }),
    optionalMyEnums: t.field({
      type: [MyEnum$Ref],
      nullable: { list: true, items: false },
      description: "Optional.",
      resolve: (source) => {
        return source.optionalMyEnums.map((item) => {
          if (item === MyEnum.MY_ENUM_UNSPECIFIED) {
            throw new Error(
              "optionalMyEnums is required field. But got unspecified.",
            );
          }

          return item;
        });
      },
      extensions: {
        protobufField: {
          name: "optional_my_enums",
          typeFullName: "testapi.enums.MyEnum",
        },
      },
    }),
    requiredMyEnumWithoutUnspecifieds: t.field({
      type: [MyEnumWithoutUnspecified$Ref],
      nullable: { list: false, items: false },
      description: "Required.",
      resolve: (source) => {
        return source.requiredMyEnumWithoutUnspecifieds;
      },
      extensions: {
        protobufField: {
          name: "required_my_enum_without_unspecifieds",
          typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
        },
      },
    }),
    optionalMyEnumWithoutUnspecifieds: t.field({
      type: [MyEnumWithoutUnspecified$Ref],
      nullable: { list: true, items: false },
      description: "Optional.",
      resolve: (source) => {
        return source.optionalMyEnumWithoutUnspecifieds;
      },
      extensions: {
        protobufField: {
          name: "optional_my_enum_without_unspecifieds",
          typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as MessageWithEnums | { $type: string & {}; }).$type ===
      "testapi.enums.MessageWithEnums";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapi.enums.MessageWithEnums",
      name: "MessageWithEnums",
      package: "testapi.enums",
    },
  },
});
",
    "name": "testapis/enums/MessageWithEnums.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/enums/enums.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { MessageWithEnums } from "@testapis/ts-proto/testapis/enums/enums";
import { builder } from "../../builder";
import { MyEnum$Ref } from "./MyEnum.pothos";
import { MyEnumWithoutUnspecified$Ref } from "./MyEnumWithoutUnspecified.pothos";

export type MessageWithEnumsInput$Shape = {
  requiredMyEnum: MessageWithEnums["requiredMyEnum"];
  optionalMyEnum?: MessageWithEnums["optionalMyEnum"] | null;
  requiredMyEnumWithoutUnspecified:
    MessageWithEnums["requiredMyEnumWithoutUnspecified"];
  optionalMyEnumWithoutUnspecified?:
    | MessageWithEnums["optionalMyEnumWithoutUnspecified"]
    | null;
  requiredMyEnums: MessageWithEnums["requiredMyEnums"];
  optionalMyEnums?: MessageWithEnums["optionalMyEnums"] | null;
  requiredMyEnumWithoutUnspecifieds:
    MessageWithEnums["requiredMyEnumWithoutUnspecifieds"];
  optionalMyEnumWithoutUnspecifieds?:
    | MessageWithEnums["optionalMyEnumWithoutUnspecifieds"]
    | null;
};

export const MessageWithEnumsInput$Ref: InputObjectRef<
  MessageWithEnumsInput$Shape
> = builder.inputRef<MessageWithEnumsInput$Shape>("MessageWithEnumsInput")
  .implement({
    fields: (t) => ({
      requiredMyEnum: t.field({
        type: MyEnum$Ref,
        required: true,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_my_enum",
            typeFullName: "testapi.enums.MyEnum",
          },
        },
      }),
      optionalMyEnum: t.field({
        type: MyEnum$Ref,
        required: false,
        description: "Optional.",
        extensions: {
          protobufField: {
            name: "optional_my_enum",
            typeFullName: "testapi.enums.MyEnum",
          },
        },
      }),
      requiredMyEnumWithoutUnspecified: t.field({
        type: MyEnumWithoutUnspecified$Ref,
        required: true,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_my_enum_without_unspecified",
            typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
          },
        },
      }),
      optionalMyEnumWithoutUnspecified: t.field({
        type: MyEnumWithoutUnspecified$Ref,
        required: false,
        description: "Optional.",
        extensions: {
          protobufField: {
            name: "optional_my_enum_without_unspecified",
            typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
          },
        },
      }),
      requiredMyEnums: t.field({
        type: [MyEnum$Ref],
        required: { list: true, items: true },
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_my_enums",
            typeFullName: "testapi.enums.MyEnum",
          },
        },
      }),
      optionalMyEnums: t.field({
        type: [MyEnum$Ref],
        required: { list: false, items: true },
        description: "Optional.",
        extensions: {
          protobufField: {
            name: "optional_my_enums",
            typeFullName: "testapi.enums.MyEnum",
          },
        },
      }),
      requiredMyEnumWithoutUnspecifieds: t.field({
        type: [MyEnumWithoutUnspecified$Ref],
        required: { list: true, items: true },
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_my_enum_without_unspecifieds",
            typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
          },
        },
      }),
      optionalMyEnumWithoutUnspecifieds: t.field({
        type: [MyEnumWithoutUnspecified$Ref],
        required: { list: false, items: true },
        description: "Optional.",
        extensions: {
          protobufField: {
            name: "optional_my_enum_without_unspecifieds",
            typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapi.enums.MessageWithEnums",
        name: "MessageWithEnums",
        package: "testapi.enums",
      },
    },
  });
",
    "name": "testapis/enums/MessageWithEnumsInput.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/enums/enums.proto

/* eslint-disable */

import { builder } from "../../builder";

export const MyEnum$Ref = builder.enumType("MyEnum", {
  values: {
    FOO: {
      value: 1,
      extensions: { protobufEnumValue: { name: "MY_ENUM_FOO" } },
    },
    BAR: {
      description: "This is Bar.",
      value: 2,
      extensions: { protobufEnumValue: { name: "MY_ENUM_BAR" } },
    },
    BAZ: {
      value: 3,
      extensions: { protobufEnumValue: { name: "MY_ENUM_BAZ" } },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "MyEnum",
      fullName: "testapi.enums.MyEnum",
      package: "testapi.enums",
    },
  },
});
",
    "name": "testapis/enums/MyEnum.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/enums/enums.proto

/* eslint-disable */

import { builder } from "../../builder";

export const MyEnumWithoutUnspecified$Ref = builder.enumType(
  "MyEnumWithoutUnspecified",
  {
    values: {
      FOO: {
        value: 0,
        extensions: {
          protobufEnumValue: { name: "MY_ENUM_WITHOUT_UNSPECIFIED_FOO" },
        },
      },
      BAR: {
        value: 1,
        extensions: {
          protobufEnumValue: { name: "MY_ENUM_WITHOUT_UNSPECIFIED_BAR" },
        },
      },
      BAZ: {
        value: 2,
        extensions: {
          protobufEnumValue: { name: "MY_ENUM_WITHOUT_UNSPECIFIED_BAZ" },
        },
      },
    } as const,
    extensions: {
      protobufEnum: {
        name: "MyEnumWithoutUnspecified",
        fullName: "testapi.enums.MyEnumWithoutUnspecified",
        package: "testapi.enums",
      },
    },
  },
);
",
    "name": "testapis/enums/MyEnumWithoutUnspecified.pothos.ts",
  },
]
`;

exports[`'testapis.enums' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/enums/enums.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import {
  MessageWithEnums,
  MyEnum,
} from "@testapis/ts-proto/testapis/enums/enums";
import { builder } from "../../builder";

export const MessageWithEnums$Ref = builder.objectRef<MessageWithEnums>(
  "MessageWithEnums",
);
builder.objectType(MessageWithEnums$Ref, {
  name: "MessageWithEnums",
  fields: (t) => ({
    requiredMyEnum: t.field({
      type: MyEnum$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        if (source.requiredMyEnum === MyEnum.MY_ENUM_UNSPECIFIED) {
          throw new Error(
            "requiredMyEnum is required field. But got unspecified.",
          );
        }

        return source.requiredMyEnum;
      },
      extensions: {
        protobufField: {
          name: "required_my_enum",
          typeFullName: "testapi.enums.MyEnum",
        },
      },
    }),
    optionalMyEnum: t.field({
      type: MyEnum$Ref,
      nullable: true,
      description: "Optional.",
      resolve: (source) => {
        if (source.optionalMyEnum === MyEnum.MY_ENUM_UNSPECIFIED) {
          return null;
        }

        return source.optionalMyEnum;
      },
      extensions: {
        protobufField: {
          name: "optional_my_enum",
          typeFullName: "testapi.enums.MyEnum",
        },
      },
    }),
    requiredMyEnumWithoutUnspecified: t.field({
      type: MyEnumWithoutUnspecified$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.requiredMyEnumWithoutUnspecified;
      },
      extensions: {
        protobufField: {
          name: "required_my_enum_without_unspecified",
          typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
        },
      },
    }),
    optionalMyEnumWithoutUnspecified: t.field({
      type: MyEnumWithoutUnspecified$Ref,
      nullable: true,
      description: "Optional.",
      resolve: (source) => {
        return source.optionalMyEnumWithoutUnspecified;
      },
      extensions: {
        protobufField: {
          name: "optional_my_enum_without_unspecified",
          typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
        },
      },
    }),
    requiredMyEnums: t.field({
      type: [MyEnum$Ref],
      nullable: { list: false, items: false },
      description: "Required.",
      resolve: (source) => {
        return source.requiredMyEnums.map((item) => {
          if (item === MyEnum.MY_ENUM_UNSPECIFIED) {
            throw new Error(
              "requiredMyEnums is required field. But got unspecified.",
            );
          }

          return item;
        });
      },
      extensions: {
        protobufField: {
          name: "required_my_enums",
          typeFullName: "testapi.enums.MyEnum",
        },
      },
    }),
    optionalMyEnums: t.field({
      type: [MyEnum$Ref],
      nullable: { list: true, items: false },
      description: "Optional.",
      resolve: (source) => {
        return source.optionalMyEnums.map((item) => {
          if (item === MyEnum.MY_ENUM_UNSPECIFIED) {
            throw new Error(
              "optionalMyEnums is required field. But got unspecified.",
            );
          }

          return item;
        });
      },
      extensions: {
        protobufField: {
          name: "optional_my_enums",
          typeFullName: "testapi.enums.MyEnum",
        },
      },
    }),
    requiredMyEnumWithoutUnspecifieds: t.field({
      type: [MyEnumWithoutUnspecified$Ref],
      nullable: { list: false, items: false },
      description: "Required.",
      resolve: (source) => {
        return source.requiredMyEnumWithoutUnspecifieds;
      },
      extensions: {
        protobufField: {
          name: "required_my_enum_without_unspecifieds",
          typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
        },
      },
    }),
    optionalMyEnumWithoutUnspecifieds: t.field({
      type: [MyEnumWithoutUnspecified$Ref],
      nullable: { list: true, items: false },
      description: "Optional.",
      resolve: (source) => {
        return source.optionalMyEnumWithoutUnspecifieds;
      },
      extensions: {
        protobufField: {
          name: "optional_my_enum_without_unspecifieds",
          typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as MessageWithEnums | { $type: string & {}; }).$type ===
      "testapi.enums.MessageWithEnums";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapi.enums.MessageWithEnums",
      name: "MessageWithEnums",
      package: "testapi.enums",
    },
  },
});

export type MessageWithEnumsInput$Shape = {
  requiredMyEnum: MessageWithEnums["requiredMyEnum"];
  optionalMyEnum?: MessageWithEnums["optionalMyEnum"] | null;
  requiredMyEnumWithoutUnspecified:
    MessageWithEnums["requiredMyEnumWithoutUnspecified"];
  optionalMyEnumWithoutUnspecified?:
    | MessageWithEnums["optionalMyEnumWithoutUnspecified"]
    | null;
  requiredMyEnums: MessageWithEnums["requiredMyEnums"];
  optionalMyEnums?: MessageWithEnums["optionalMyEnums"] | null;
  requiredMyEnumWithoutUnspecifieds:
    MessageWithEnums["requiredMyEnumWithoutUnspecifieds"];
  optionalMyEnumWithoutUnspecifieds?:
    | MessageWithEnums["optionalMyEnumWithoutUnspecifieds"]
    | null;
};

export const MessageWithEnumsInput$Ref: InputObjectRef<
  MessageWithEnumsInput$Shape
> = builder.inputRef<MessageWithEnumsInput$Shape>("MessageWithEnumsInput")
  .implement({
    fields: (t) => ({
      requiredMyEnum: t.field({
        type: MyEnum$Ref,
        required: true,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_my_enum",
            typeFullName: "testapi.enums.MyEnum",
          },
        },
      }),
      optionalMyEnum: t.field({
        type: MyEnum$Ref,
        required: false,
        description: "Optional.",
        extensions: {
          protobufField: {
            name: "optional_my_enum",
            typeFullName: "testapi.enums.MyEnum",
          },
        },
      }),
      requiredMyEnumWithoutUnspecified: t.field({
        type: MyEnumWithoutUnspecified$Ref,
        required: true,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_my_enum_without_unspecified",
            typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
          },
        },
      }),
      optionalMyEnumWithoutUnspecified: t.field({
        type: MyEnumWithoutUnspecified$Ref,
        required: false,
        description: "Optional.",
        extensions: {
          protobufField: {
            name: "optional_my_enum_without_unspecified",
            typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
          },
        },
      }),
      requiredMyEnums: t.field({
        type: [MyEnum$Ref],
        required: { list: true, items: true },
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_my_enums",
            typeFullName: "testapi.enums.MyEnum",
          },
        },
      }),
      optionalMyEnums: t.field({
        type: [MyEnum$Ref],
        required: { list: false, items: true },
        description: "Optional.",
        extensions: {
          protobufField: {
            name: "optional_my_enums",
            typeFullName: "testapi.enums.MyEnum",
          },
        },
      }),
      requiredMyEnumWithoutUnspecifieds: t.field({
        type: [MyEnumWithoutUnspecified$Ref],
        required: { list: true, items: true },
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_my_enum_without_unspecifieds",
            typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
          },
        },
      }),
      optionalMyEnumWithoutUnspecifieds: t.field({
        type: [MyEnumWithoutUnspecified$Ref],
        required: { list: false, items: true },
        description: "Optional.",
        extensions: {
          protobufField: {
            name: "optional_my_enum_without_unspecifieds",
            typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapi.enums.MessageWithEnums",
        name: "MessageWithEnums",
        package: "testapi.enums",
      },
    },
  });

export const MyEnum$Ref = builder.enumType("MyEnum", {
  values: {
    FOO: {
      value: 1,
      extensions: { protobufEnumValue: { name: "MY_ENUM_FOO" } },
    },
    BAR: {
      description: "This is Bar.",
      value: 2,
      extensions: { protobufEnumValue: { name: "MY_ENUM_BAR" } },
    },
    BAZ: {
      value: 3,
      extensions: { protobufEnumValue: { name: "MY_ENUM_BAZ" } },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "MyEnum",
      fullName: "testapi.enums.MyEnum",
      package: "testapi.enums",
    },
  },
});

export const MyEnumWithoutUnspecified$Ref = builder.enumType(
  "MyEnumWithoutUnspecified",
  {
    values: {
      FOO: {
        value: 0,
        extensions: {
          protobufEnumValue: { name: "MY_ENUM_WITHOUT_UNSPECIFIED_FOO" },
        },
      },
      BAR: {
        value: 1,
        extensions: {
          protobufEnumValue: { name: "MY_ENUM_WITHOUT_UNSPECIFIED_BAR" },
        },
      },
      BAZ: {
        value: 2,
        extensions: {
          protobufEnumValue: { name: "MY_ENUM_WITHOUT_UNSPECIFIED_BAZ" },
        },
      },
    } as const,
    extensions: {
      protobufEnum: {
        name: "MyEnumWithoutUnspecified",
        fullName: "testapi.enums.MyEnumWithoutUnspecified",
        package: "testapi.enums",
      },
    },
  },
);
",
    "name": "testapis/enums/enums.pb.pothos.ts",
  },
]
`;

exports[`'testapis.enums' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/enums/enums.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import {
  MessageWithEnums,
  MyEnum,
} from "@testapis/ts-proto/testapis/enums/enums";
import { builder } from "../../builder";

export const MessageWithEnums$Ref = builder.objectRef<MessageWithEnums>(
  "MessageWithEnums",
);
builder.objectType(MessageWithEnums$Ref, {
  name: "MessageWithEnums",
  fields: (t) => ({
    requiredMyEnum: t.field({
      type: MyEnum$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        if (source.requiredMyEnum === MyEnum.MY_ENUM_UNSPECIFIED) {
          throw new Error(
            "requiredMyEnum is required field. But got unspecified.",
          );
        }

        return source.requiredMyEnum;
      },
      extensions: {
        protobufField: {
          name: "required_my_enum",
          typeFullName: "testapi.enums.MyEnum",
        },
      },
    }),
    optionalMyEnum: t.field({
      type: MyEnum$Ref,
      nullable: true,
      description: "Optional.",
      resolve: (source) => {
        if (source.optionalMyEnum === MyEnum.MY_ENUM_UNSPECIFIED) {
          return null;
        }

        return source.optionalMyEnum;
      },
      extensions: {
        protobufField: {
          name: "optional_my_enum",
          typeFullName: "testapi.enums.MyEnum",
        },
      },
    }),
    requiredMyEnumWithoutUnspecified: t.field({
      type: MyEnumWithoutUnspecified$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.requiredMyEnumWithoutUnspecified;
      },
      extensions: {
        protobufField: {
          name: "required_my_enum_without_unspecified",
          typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
        },
      },
    }),
    optionalMyEnumWithoutUnspecified: t.field({
      type: MyEnumWithoutUnspecified$Ref,
      nullable: true,
      description: "Optional.",
      resolve: (source) => {
        return source.optionalMyEnumWithoutUnspecified;
      },
      extensions: {
        protobufField: {
          name: "optional_my_enum_without_unspecified",
          typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
        },
      },
    }),
    requiredMyEnums: t.field({
      type: [MyEnum$Ref],
      nullable: { list: false, items: false },
      description: "Required.",
      resolve: (source) => {
        return source.requiredMyEnums.map((item) => {
          if (item === MyEnum.MY_ENUM_UNSPECIFIED) {
            throw new Error(
              "requiredMyEnums is required field. But got unspecified.",
            );
          }

          return item;
        });
      },
      extensions: {
        protobufField: {
          name: "required_my_enums",
          typeFullName: "testapi.enums.MyEnum",
        },
      },
    }),
    optionalMyEnums: t.field({
      type: [MyEnum$Ref],
      nullable: { list: true, items: false },
      description: "Optional.",
      resolve: (source) => {
        return source.optionalMyEnums.map((item) => {
          if (item === MyEnum.MY_ENUM_UNSPECIFIED) {
            throw new Error(
              "optionalMyEnums is required field. But got unspecified.",
            );
          }

          return item;
        });
      },
      extensions: {
        protobufField: {
          name: "optional_my_enums",
          typeFullName: "testapi.enums.MyEnum",
        },
      },
    }),
    requiredMyEnumWithoutUnspecifieds: t.field({
      type: [MyEnumWithoutUnspecified$Ref],
      nullable: { list: false, items: false },
      description: "Required.",
      resolve: (source) => {
        return source.requiredMyEnumWithoutUnspecifieds;
      },
      extensions: {
        protobufField: {
          name: "required_my_enum_without_unspecifieds",
          typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
        },
      },
    }),
    optionalMyEnumWithoutUnspecifieds: t.field({
      type: [MyEnumWithoutUnspecified$Ref],
      nullable: { list: true, items: false },
      description: "Optional.",
      resolve: (source) => {
        return source.optionalMyEnumWithoutUnspecifieds;
      },
      extensions: {
        protobufField: {
          name: "optional_my_enum_without_unspecifieds",
          typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as MessageWithEnums | { $type: string & {}; }).$type ===
      "testapi.enums.MessageWithEnums";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapi.enums.MessageWithEnums",
      name: "MessageWithEnums",
      package: "testapi.enums",
    },
  },
});

export type MessageWithEnumsInput$Shape = {
  requiredMyEnum: MessageWithEnums["requiredMyEnum"];
  optionalMyEnum?: MessageWithEnums["optionalMyEnum"] | null;
  requiredMyEnumWithoutUnspecified:
    MessageWithEnums["requiredMyEnumWithoutUnspecified"];
  optionalMyEnumWithoutUnspecified?:
    | MessageWithEnums["optionalMyEnumWithoutUnspecified"]
    | null;
  requiredMyEnums: MessageWithEnums["requiredMyEnums"];
  optionalMyEnums?: MessageWithEnums["optionalMyEnums"] | null;
  requiredMyEnumWithoutUnspecifieds:
    MessageWithEnums["requiredMyEnumWithoutUnspecifieds"];
  optionalMyEnumWithoutUnspecifieds?:
    | MessageWithEnums["optionalMyEnumWithoutUnspecifieds"]
    | null;
};

export const MessageWithEnumsInput$Ref: InputObjectRef<
  MessageWithEnumsInput$Shape
> = builder.inputRef<MessageWithEnumsInput$Shape>("MessageWithEnumsInput")
  .implement({
    fields: (t) => ({
      requiredMyEnum: t.field({
        type: MyEnum$Ref,
        required: true,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_my_enum",
            typeFullName: "testapi.enums.MyEnum",
          },
        },
      }),
      optionalMyEnum: t.field({
        type: MyEnum$Ref,
        required: false,
        description: "Optional.",
        extensions: {
          protobufField: {
            name: "optional_my_enum",
            typeFullName: "testapi.enums.MyEnum",
          },
        },
      }),
      requiredMyEnumWithoutUnspecified: t.field({
        type: MyEnumWithoutUnspecified$Ref,
        required: true,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_my_enum_without_unspecified",
            typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
          },
        },
      }),
      optionalMyEnumWithoutUnspecified: t.field({
        type: MyEnumWithoutUnspecified$Ref,
        required: false,
        description: "Optional.",
        extensions: {
          protobufField: {
            name: "optional_my_enum_without_unspecified",
            typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
          },
        },
      }),
      requiredMyEnums: t.field({
        type: [MyEnum$Ref],
        required: { list: true, items: true },
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_my_enums",
            typeFullName: "testapi.enums.MyEnum",
          },
        },
      }),
      optionalMyEnums: t.field({
        type: [MyEnum$Ref],
        required: { list: false, items: true },
        description: "Optional.",
        extensions: {
          protobufField: {
            name: "optional_my_enums",
            typeFullName: "testapi.enums.MyEnum",
          },
        },
      }),
      requiredMyEnumWithoutUnspecifieds: t.field({
        type: [MyEnumWithoutUnspecified$Ref],
        required: { list: true, items: true },
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_my_enum_without_unspecifieds",
            typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
          },
        },
      }),
      optionalMyEnumWithoutUnspecifieds: t.field({
        type: [MyEnumWithoutUnspecified$Ref],
        required: { list: false, items: true },
        description: "Optional.",
        extensions: {
          protobufField: {
            name: "optional_my_enum_without_unspecifieds",
            typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapi.enums.MessageWithEnums",
        name: "MessageWithEnums",
        package: "testapi.enums",
      },
    },
  });

export type MessageWithEnumsPartialInput$Shape = {
  requiredMyEnum?: MessageWithEnums["requiredMyEnum"] | null;
  optionalMyEnum?: MessageWithEnums["optionalMyEnum"] | null;
  requiredMyEnumWithoutUnspecified?:
    | MessageWithEnums["requiredMyEnumWithoutUnspecified"]
    | null;
  optionalMyEnumWithoutUnspecified?:
    | MessageWithEnums["optionalMyEnumWithoutUnspecified"]
    | null;
  requiredMyEnums?: MessageWithEnums["requiredMyEnums"] | null;
  optionalMyEnums?: MessageWithEnums["optionalMyEnums"] | null;
  requiredMyEnumWithoutUnspecifieds?:
    | MessageWithEnums["requiredMyEnumWithoutUnspecifieds"]
    | null;
  optionalMyEnumWithoutUnspecifieds?:
    | MessageWithEnums["optionalMyEnumWithoutUnspecifieds"]
    | null;
};

export const MessageWithEnumsPartialInput$Ref: InputObjectRef<
  MessageWithEnumsPartialInput$Shape
> = builder.inputRef<MessageWithEnumsPartialInput$Shape>(
  "MessageWithEnumsPartialInput",
).implement({
  fields: (t) => ({
    requiredMyEnum: t.field({
      type: MyEnum$Ref,
      required: false,
      description: "Required.",
      extensions: {
        protobufField: {
          name: "required_my_enum",
          typeFullName: "testapi.enums.MyEnum",
        },
      },
    }),
    optionalMyEnum: t.field({
      type: MyEnum$Ref,
      required: false,
      description: "Optional.",
      extensions: {
        protobufField: {
          name: "optional_my_enum",
          typeFullName: "testapi.enums.MyEnum",
        },
      },
    }),
    requiredMyEnumWithoutUnspecified: t.field({
      type: MyEnumWithoutUnspecified$Ref,
      required: false,
      description: "Required.",
      extensions: {
        protobufField: {
          name: "required_my_enum_without_unspecified",
          typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
        },
      },
    }),
    optionalMyEnumWithoutUnspecified: t.field({
      type: MyEnumWithoutUnspecified$Ref,
      required: false,
      description: "Optional.",
      extensions: {
        protobufField: {
          name: "optional_my_enum_without_unspecified",
          typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
        },
      },
    }),
    requiredMyEnums: t.field({
      type: [MyEnum$Ref],
      required: { list: false, items: true },
      description: "Required.",
      extensions: {
        protobufField: {
          name: "required_my_enums",
          typeFullName: "testapi.enums.MyEnum",
        },
      },
    }),
    optionalMyEnums: t.field({
      type: [MyEnum$Ref],
      required: { list: false, items: true },
      description: "Optional.",
      extensions: {
        protobufField: {
          name: "optional_my_enums",
          typeFullName: "testapi.enums.MyEnum",
        },
      },
    }),
    requiredMyEnumWithoutUnspecifieds: t.field({
      type: [MyEnumWithoutUnspecified$Ref],
      required: { list: false, items: true },
      description: "Required.",
      extensions: {
        protobufField: {
          name: "required_my_enum_without_unspecifieds",
          typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
        },
      },
    }),
    optionalMyEnumWithoutUnspecifieds: t.field({
      type: [MyEnumWithoutUnspecified$Ref],
      required: { list: false, items: true },
      description: "Optional.",
      extensions: {
        protobufField: {
          name: "optional_my_enum_without_unspecifieds",
          typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
        },
      },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapi.enums.MessageWithEnums",
      name: "MessageWithEnums",
      package: "testapi.enums",
    },
  },
});

export const MyEnum$Ref = builder.enumType("MyEnum", {
  values: {
    FOO: {
      value: 1,
      extensions: { protobufEnumValue: { name: "MY_ENUM_FOO" } },
    },
    BAR: {
      description: "This is Bar.",
      value: 2,
      extensions: { protobufEnumValue: { name: "MY_ENUM_BAR" } },
    },
    BAZ: {
      value: 3,
      extensions: { protobufEnumValue: { name: "MY_ENUM_BAZ" } },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "MyEnum",
      fullName: "testapi.enums.MyEnum",
      package: "testapi.enums",
    },
  },
});

export const MyEnumWithoutUnspecified$Ref = builder.enumType(
  "MyEnumWithoutUnspecified",
  {
    values: {
      FOO: {
        value: 0,
        extensions: {
          protobufEnumValue: { name: "MY_ENUM_WITHOUT_UNSPECIFIED_FOO" },
        },
      },
      BAR: {
        value: 1,
        extensions: {
          protobufEnumValue: { name: "MY_ENUM_WITHOUT_UNSPECIFIED_BAR" },
        },
      },
      BAZ: {
        value: 2,
        extensions: {
          protobufEnumValue: { name: "MY_ENUM_WITHOUT_UNSPECIFIED_BAZ" },
        },
      },
    } as const,
    extensions: {
      protobufEnum: {
        name: "MyEnumWithoutUnspecified",
        fullName: "testapi.enums.MyEnumWithoutUnspecified",
        package: "testapi.enums",
      },
    },
  },
);
",
    "name": "testapis/enums/enums.pb.pothos.ts",
  },
]
`;

exports[`'testapis.enums' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/enums/enums.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import { MessageWithEnums, MyEnum } from "./testapis/enums/enums";

export const MessageWithEnums$Ref = builder.objectRef<MessageWithEnums>(
  "MessageWithEnums",
);
builder.objectType(MessageWithEnums$Ref, {
  name: "MessageWithEnums",
  fields: (t) => ({
    requiredMyEnum: t.field({
      type: MyEnum$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        if (source.requiredMyEnum === MyEnum.MY_ENUM_UNSPECIFIED) {
          throw new Error(
            "requiredMyEnum is required field. But got unspecified.",
          );
        }

        return source.requiredMyEnum;
      },
      extensions: {
        protobufField: {
          name: "required_my_enum",
          typeFullName: "testapi.enums.MyEnum",
        },
      },
    }),
    optionalMyEnum: t.field({
      type: MyEnum$Ref,
      nullable: true,
      description: "Optional.",
      resolve: (source) => {
        if (source.optionalMyEnum === MyEnum.MY_ENUM_UNSPECIFIED) {
          return null;
        }

        return source.optionalMyEnum;
      },
      extensions: {
        protobufField: {
          name: "optional_my_enum",
          typeFullName: "testapi.enums.MyEnum",
        },
      },
    }),
    requiredMyEnumWithoutUnspecified: t.field({
      type: MyEnumWithoutUnspecified$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.requiredMyEnumWithoutUnspecified;
      },
      extensions: {
        protobufField: {
          name: "required_my_enum_without_unspecified",
          typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
        },
      },
    }),
    optionalMyEnumWithoutUnspecified: t.field({
      type: MyEnumWithoutUnspecified$Ref,
      nullable: true,
      description: "Optional.",
      resolve: (source) => {
        return source.optionalMyEnumWithoutUnspecified;
      },
      extensions: {
        protobufField: {
          name: "optional_my_enum_without_unspecified",
          typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
        },
      },
    }),
    requiredMyEnums: t.field({
      type: [MyEnum$Ref],
      nullable: { list: false, items: false },
      description: "Required.",
      resolve: (source) => {
        return source.requiredMyEnums.map((item) => {
          if (item === MyEnum.MY_ENUM_UNSPECIFIED) {
            throw new Error(
              "requiredMyEnums is required field. But got unspecified.",
            );
          }

          return item;
        });
      },
      extensions: {
        protobufField: {
          name: "required_my_enums",
          typeFullName: "testapi.enums.MyEnum",
        },
      },
    }),
    optionalMyEnums: t.field({
      type: [MyEnum$Ref],
      nullable: { list: true, items: false },
      description: "Optional.",
      resolve: (source) => {
        return source.optionalMyEnums.map((item) => {
          if (item === MyEnum.MY_ENUM_UNSPECIFIED) {
            throw new Error(
              "optionalMyEnums is required field. But got unspecified.",
            );
          }

          return item;
        });
      },
      extensions: {
        protobufField: {
          name: "optional_my_enums",
          typeFullName: "testapi.enums.MyEnum",
        },
      },
    }),
    requiredMyEnumWithoutUnspecifieds: t.field({
      type: [MyEnumWithoutUnspecified$Ref],
      nullable: { list: false, items: false },
      description: "Required.",
      resolve: (source) => {
        return source.requiredMyEnumWithoutUnspecifieds;
      },
      extensions: {
        protobufField: {
          name: "required_my_enum_without_unspecifieds",
          typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
        },
      },
    }),
    optionalMyEnumWithoutUnspecifieds: t.field({
      type: [MyEnumWithoutUnspecified$Ref],
      nullable: { list: true, items: false },
      description: "Optional.",
      resolve: (source) => {
        return source.optionalMyEnumWithoutUnspecifieds;
      },
      extensions: {
        protobufField: {
          name: "optional_my_enum_without_unspecifieds",
          typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as MessageWithEnums | { $type: string & {}; }).$type ===
      "testapi.enums.MessageWithEnums";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapi.enums.MessageWithEnums",
      name: "MessageWithEnums",
      package: "testapi.enums",
    },
  },
});

export type MessageWithEnumsInput$Shape = {
  requiredMyEnum: MessageWithEnums["requiredMyEnum"];
  optionalMyEnum?: MessageWithEnums["optionalMyEnum"] | null;
  requiredMyEnumWithoutUnspecified:
    MessageWithEnums["requiredMyEnumWithoutUnspecified"];
  optionalMyEnumWithoutUnspecified?:
    | MessageWithEnums["optionalMyEnumWithoutUnspecified"]
    | null;
  requiredMyEnums: MessageWithEnums["requiredMyEnums"];
  optionalMyEnums?: MessageWithEnums["optionalMyEnums"] | null;
  requiredMyEnumWithoutUnspecifieds:
    MessageWithEnums["requiredMyEnumWithoutUnspecifieds"];
  optionalMyEnumWithoutUnspecifieds?:
    | MessageWithEnums["optionalMyEnumWithoutUnspecifieds"]
    | null;
};

export const MessageWithEnumsInput$Ref: InputObjectRef<
  MessageWithEnumsInput$Shape
> = builder.inputRef<MessageWithEnumsInput$Shape>("MessageWithEnumsInput")
  .implement({
    fields: (t) => ({
      requiredMyEnum: t.field({
        type: MyEnum$Ref,
        required: true,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_my_enum",
            typeFullName: "testapi.enums.MyEnum",
          },
        },
      }),
      optionalMyEnum: t.field({
        type: MyEnum$Ref,
        required: false,
        description: "Optional.",
        extensions: {
          protobufField: {
            name: "optional_my_enum",
            typeFullName: "testapi.enums.MyEnum",
          },
        },
      }),
      requiredMyEnumWithoutUnspecified: t.field({
        type: MyEnumWithoutUnspecified$Ref,
        required: true,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_my_enum_without_unspecified",
            typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
          },
        },
      }),
      optionalMyEnumWithoutUnspecified: t.field({
        type: MyEnumWithoutUnspecified$Ref,
        required: false,
        description: "Optional.",
        extensions: {
          protobufField: {
            name: "optional_my_enum_without_unspecified",
            typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
          },
        },
      }),
      requiredMyEnums: t.field({
        type: [MyEnum$Ref],
        required: { list: true, items: true },
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_my_enums",
            typeFullName: "testapi.enums.MyEnum",
          },
        },
      }),
      optionalMyEnums: t.field({
        type: [MyEnum$Ref],
        required: { list: false, items: true },
        description: "Optional.",
        extensions: {
          protobufField: {
            name: "optional_my_enums",
            typeFullName: "testapi.enums.MyEnum",
          },
        },
      }),
      requiredMyEnumWithoutUnspecifieds: t.field({
        type: [MyEnumWithoutUnspecified$Ref],
        required: { list: true, items: true },
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_my_enum_without_unspecifieds",
            typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
          },
        },
      }),
      optionalMyEnumWithoutUnspecifieds: t.field({
        type: [MyEnumWithoutUnspecified$Ref],
        required: { list: false, items: true },
        description: "Optional.",
        extensions: {
          protobufField: {
            name: "optional_my_enum_without_unspecifieds",
            typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapi.enums.MessageWithEnums",
        name: "MessageWithEnums",
        package: "testapi.enums",
      },
    },
  });

export const MyEnum$Ref = builder.enumType("MyEnum", {
  values: {
    FOO: {
      value: 1,
      extensions: { protobufEnumValue: { name: "MY_ENUM_FOO" } },
    },
    BAR: {
      description: "This is Bar.",
      value: 2,
      extensions: { protobufEnumValue: { name: "MY_ENUM_BAR" } },
    },
    BAZ: {
      value: 3,
      extensions: { protobufEnumValue: { name: "MY_ENUM_BAZ" } },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "MyEnum",
      fullName: "testapi.enums.MyEnum",
      package: "testapi.enums",
    },
  },
});

export const MyEnumWithoutUnspecified$Ref = builder.enumType(
  "MyEnumWithoutUnspecified",
  {
    values: {
      FOO: {
        value: 0,
        extensions: {
          protobufEnumValue: { name: "MY_ENUM_WITHOUT_UNSPECIFIED_FOO" },
        },
      },
      BAR: {
        value: 1,
        extensions: {
          protobufEnumValue: { name: "MY_ENUM_WITHOUT_UNSPECIFIED_BAR" },
        },
      },
      BAZ: {
        value: 2,
        extensions: {
          protobufEnumValue: { name: "MY_ENUM_WITHOUT_UNSPECIFIED_BAZ" },
        },
      },
    } as const,
    extensions: {
      protobufEnum: {
        name: "MyEnumWithoutUnspecified",
        fullName: "testapi.enums.MyEnumWithoutUnspecified",
        package: "testapi.enums",
      },
    },
  },
);
",
    "name": "testapis/enums/enums.pb.pothos.ts",
  },
]
`;

exports[`'testapis.extensions' > generates files by plugin 'with graphql_type layout' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import {
  EnumWillRename,
  PrefixedEnum,
  PrefixedMessage,
} from "@testapis/ts-proto/testapis/extensions/extensions";
import { builder } from "../../builder";
import { TestPrefixIgnoredMessageNotIgnored$Ref } from "./TestPrefixIgnoredMessageNotIgnored.pothos";
import { TestPrefixPrefixedEnum$Ref } from "./TestPrefixPrefixedEnum.pothos";
import { TestPrefixPrefixedMessageSquashedMessage$Ref } from "./TestPrefixPrefixedMessageSquashedMessage.pothos";
import { TestPrefixRenamedEnum$Ref } from "./TestPrefixRenamedEnum.pothos";
import { TestPrefixRenamedMessage$Ref } from "./TestPrefixRenamedMessage.pothos";

export const TestPrefixPrefixedMessage$Ref = builder.objectRef<PrefixedMessage>(
  "TestPrefixPrefixedMessage",
);
builder.objectType(TestPrefixPrefixedMessage$Ref, {
  name: "TestPrefixPrefixedMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "String",
      nullable: false,
      description: "Output only.",
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    prefixedEnum: t.field({
      type: TestPrefixPrefixedEnum$Ref,
      nullable: true,
      resolve: (source) => {
        if (source.prefixedEnum === PrefixedEnum.PREFIXED_ENUM_UNSPECIFIED) {
          return null;
        }

        if (source.prefixedEnum === PrefixedEnum.PREFIXED_IGNORED) {
          throw new Error("PREFIXED_IGNORED is ignored in GraphQL schema");
        }

        return source.prefixedEnum;
      },
      extensions: {
        protobufField: {
          name: "prefixed_enum",
          typeFullName: "testapis.extensions.PrefixedEnum",
        },
      },
    }),
    notIgnoredMessage: t.expose("notIgnoredMessage", {
      type: TestPrefixIgnoredMessageNotIgnored$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "not_ignored_message",
          typeFullName: "testapis.extensions.IgnoredMessage.NotIgnored",
        },
      },
    }),
    squashedMessage: t.field({
      type: TestPrefixPrefixedMessageSquashedMessage$Ref,
      nullable: true,
      resolve: (source) => {
        const value = source.squashedMessage?.oneofField ??
          source.squashedMessage?.oneofField2;
        if (value == null) {
          return null;
        }
        return value;
      },
      extensions: {
        protobufField: {
          name: "squashed_message",
          typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        },
      },
    }),
    thisFieldWasRenamed: t.expose("thisFieldWillBeRenamed", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "this_field_will_be_renamed",
          typeFullName: "string",
          options: { "[graphql.field]": { name: "thisFieldWasRenamed" } },
        },
      },
    }),
    skipResolver: t.expose("skipResolver", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "skip_resolver",
          typeFullName: "string",
          options: { "[graphql.field]": { skipResolver: true } },
        },
      },
    }),
    squashedMessages: t.field({
      type: [TestPrefixPrefixedMessageSquashedMessage$Ref],
      nullable: { list: true, items: false },
      resolve: (source) => {
        return source.squashedMessages.map((item) => {
          const value = item?.oneofField ?? item?.oneofField2;
          if (value == null) {
            throw new Error("squashedMessages should not be null");
          }
          return value;
        });
      },
      extensions: {
        protobufField: {
          name: "squashed_messages",
          typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        },
      },
    }),
    renamedMessage: t.expose("renamedMessage", {
      type: TestPrefixRenamedMessage$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "renamed_message",
          typeFullName: "testapis.extensions.MessageWillRename",
        },
      },
    }),
    renamedEnum: t.field({
      type: TestPrefixRenamedEnum$Ref,
      nullable: true,
      resolve: (source) => {
        if (
          source.renamedEnum === EnumWillRename.ENUM_WILL_RENAME_UNSPECIFIED
        ) {
          return null;
        }

        return source.renamedEnum;
      },
      extensions: {
        protobufField: {
          name: "renamed_enum",
          typeFullName: "testapis.extensions.EnumWillRename",
        },
      },
    }),
    partialIgnoreOneof: t.field({
      type: TestPrefixPrefixedMessagePartialIgnoreOneof$Ref,
      nullable: true,
      resolve: (source) => {
        const value = source.oneofNotIgnoredField;
        if (value == null) {
          return null;
        }
        return value;
      },
      extensions: { protobufField: { name: "partial_ignore_oneof" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as PrefixedMessage | { $type: string & {}; }).$type ===
      "testapis.extensions.PrefixedMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage",
      name: "PrefixedMessage",
      package: "testapis.extensions",
    },
  },
});
",
    "name": "testapis/extensions/TestPrefixPrefixedMessage.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import { MessageWillRename } from "@testapis/ts-proto/testapis/extensions/extensions";
import { builder } from "../../builder";

export const TestPrefixRenamedMessage$Ref = builder.objectRef<
  MessageWillRename
>("TestPrefixRenamedMessage");
builder.objectType(TestPrefixRenamedMessage$Ref, {
  name: "TestPrefixRenamedMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as MessageWillRename | { $type: string & {}; }).$type ===
      "testapis.extensions.MessageWillRename";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.MessageWillRename",
      name: "MessageWillRename",
      package: "testapis.extensions",
      options: { "[graphql.object_type]": { name: "RenamedMessage" } },
    },
  },
});
",
    "name": "testapis/extensions/TestPrefixRenamedMessage.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import { MessageOnlyOutput } from "@testapis/ts-proto/testapis/extensions/extensions";
import { builder } from "../../builder";

export const TestPrefixMessageOnlyOutput$Ref = builder.objectRef<
  MessageOnlyOutput
>("TestPrefixMessageOnlyOutput");
builder.objectType(TestPrefixMessageOnlyOutput$Ref, {
  name: "TestPrefixMessageOnlyOutput",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as MessageOnlyOutput | { $type: string & {}; }).$type ===
      "testapis.extensions.MessageOnlyOutput";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.MessageOnlyOutput",
      name: "MessageOnlyOutput",
      package: "testapis.extensions",
      options: { "[graphql.input_type]": { ignore: true } },
    },
  },
});
",
    "name": "testapis/extensions/TestPrefixMessageOnlyOutput.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import { PrefixedMessage_InnerMessage } from "@testapis/ts-proto/testapis/extensions/extensions";
import { builder } from "../../builder";

export const TestPrefixPrefixedMessageInnerMessage$Ref = builder.objectRef<
  PrefixedMessage_InnerMessage
>("TestPrefixPrefixedMessageInnerMessage");
builder.objectType(TestPrefixPrefixedMessageInnerMessage$Ref, {
  name: "TestPrefixPrefixedMessageInnerMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as PrefixedMessage_InnerMessage | { $type: string & {}; })
      .$type === "testapis.extensions.PrefixedMessage.InnerMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.extensions",
    },
  },
});
",
    "name": "testapis/extensions/TestPrefixPrefixedMessageInnerMessage.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import { PrefixedMessage_InnerMessage2 } from "@testapis/ts-proto/testapis/extensions/extensions";
import { builder } from "../../builder";

export const TestPrefixPrefixedMessageInnerMessage2$Ref = builder.objectRef<
  PrefixedMessage_InnerMessage2
>("TestPrefixPrefixedMessageInnerMessage2");
builder.objectType(TestPrefixPrefixedMessageInnerMessage2$Ref, {
  name: "TestPrefixPrefixedMessageInnerMessage2",
  fields: (t) => ({
    id: t.expose("id", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as PrefixedMessage_InnerMessage2 | { $type: string & {}; })
      .$type === "testapis.extensions.PrefixedMessage.InnerMessage2";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage.InnerMessage2",
      name: "InnerMessage2",
      package: "testapis.extensions",
    },
  },
});
",
    "name": "testapis/extensions/TestPrefixPrefixedMessageInnerMessage2.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import { IgnoredMessage_NotIgnored } from "@testapis/ts-proto/testapis/extensions/extensions";
import { builder } from "../../builder";

export const TestPrefixIgnoredMessageNotIgnored$Ref = builder.objectRef<
  IgnoredMessage_NotIgnored
>("TestPrefixIgnoredMessageNotIgnored");
builder.objectType(TestPrefixIgnoredMessageNotIgnored$Ref, {
  name: "TestPrefixIgnoredMessageNotIgnored",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as IgnoredMessage_NotIgnored | { $type: string & {}; })
      .$type === "testapis.extensions.IgnoredMessage.NotIgnored";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.IgnoredMessage.NotIgnored",
      name: "NotIgnored",
      package: "testapis.extensions",
    },
  },
});
",
    "name": "testapis/extensions/TestPrefixIgnoredMessageNotIgnored.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { PrefixedMessage } from "@testapis/ts-proto/testapis/extensions/extensions";
import { builder } from "../../builder";
import {
  TestPrefixIgnoredMessageNotIgnoredInput$Ref,
  TestPrefixIgnoredMessageNotIgnoredInput$Shape,
} from "./TestPrefixIgnoredMessageNotIgnoredInput.pothos";
import { TestPrefixPrefixedEnum$Ref } from "./TestPrefixPrefixedEnum.pothos";
import {
  TestPrefixPrefixedMessageInnerMessageInput$Ref,
  TestPrefixPrefixedMessageInnerMessageInput$Shape,
} from "./TestPrefixPrefixedMessageInnerMessageInput.pothos";
import {
  TestPrefixPrefixedMessageSquashedMessageInput$Ref,
  TestPrefixPrefixedMessageSquashedMessageInput$Shape,
} from "./TestPrefixPrefixedMessageSquashedMessageInput.pothos";
import { TestPrefixRenamedEnum$Ref } from "./TestPrefixRenamedEnum.pothos";
import {
  TestPrefixRenamedMessageInput$Ref,
  TestPrefixRenamedMessageInput$Shape,
} from "./TestPrefixRenamedMessageInput.pothos";

export type TestPrefixPrefixedMessageInput$Shape = {
  body: PrefixedMessage["body"];
  prefixedEnum?: PrefixedMessage["prefixedEnum"] | null;
  notIgnoredMessage?: TestPrefixIgnoredMessageNotIgnoredInput$Shape | null;
  squashedMessage?: TestPrefixPrefixedMessageSquashedMessageInput$Shape | null;
  thisFieldWasRenamed: PrefixedMessage["thisFieldWillBeRenamed"];
  oneofNotIgnoredField?:
    | TestPrefixPrefixedMessageInnerMessageInput$Shape
    | null;
  skipResolver: PrefixedMessage["skipResolver"];
  squashedMessages?:
    | Array<TestPrefixPrefixedMessageSquashedMessageInput$Shape>
    | null;
  renamedMessage?: TestPrefixRenamedMessageInput$Shape | null;
  renamedEnum?: PrefixedMessage["renamedEnum"] | null;
};

export const TestPrefixPrefixedMessageInput$Ref: InputObjectRef<
  TestPrefixPrefixedMessageInput$Shape
> = builder.inputRef<TestPrefixPrefixedMessageInput$Shape>(
  "TestPrefixPrefixedMessageInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    prefixedEnum: t.field({
      type: TestPrefixPrefixedEnum$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "prefixed_enum",
          typeFullName: "testapis.extensions.PrefixedEnum",
        },
      },
    }),
    notIgnoredMessage: t.field({
      type: TestPrefixIgnoredMessageNotIgnoredInput$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "not_ignored_message",
          typeFullName: "testapis.extensions.IgnoredMessage.NotIgnored",
        },
      },
    }),
    squashedMessage: t.field({
      type: TestPrefixPrefixedMessageSquashedMessageInput$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "squashed_message",
          typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        },
      },
    }),
    thisFieldWasRenamed: t.field({
      type: "String",
      required: true,
      extensions: {
        protobufField: {
          name: "this_field_will_be_renamed",
          typeFullName: "string",
          options: { "[graphql.field]": { name: "thisFieldWasRenamed" } },
        },
      },
    }),
    oneofNotIgnoredField: t.field({
      type: TestPrefixPrefixedMessageInnerMessageInput$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "oneof_not_ignored_field",
          typeFullName: "testapis.extensions.PrefixedMessage.InnerMessage",
        },
      },
    }),
    skipResolver: t.field({
      type: "String",
      required: true,
      extensions: {
        protobufField: {
          name: "skip_resolver",
          typeFullName: "string",
          options: { "[graphql.field]": { skipResolver: true } },
        },
      },
    }),
    squashedMessages: t.field({
      type: [TestPrefixPrefixedMessageSquashedMessageInput$Ref],
      required: { list: false, items: true },
      extensions: {
        protobufField: {
          name: "squashed_messages",
          typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        },
      },
    }),
    renamedMessage: t.field({
      type: TestPrefixRenamedMessageInput$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "renamed_message",
          typeFullName: "testapis.extensions.MessageWillRename",
        },
      },
    }),
    renamedEnum: t.field({
      type: TestPrefixRenamedEnum$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "renamed_enum",
          typeFullName: "testapis.extensions.EnumWillRename",
        },
      },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage",
      name: "PrefixedMessage",
      package: "testapis.extensions",
    },
  },
});
",
    "name": "testapis/extensions/TestPrefixPrefixedMessageInput.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { MessageWillRename } from "@testapis/ts-proto/testapis/extensions/extensions";
import { builder } from "../../builder";

export type TestPrefixRenamedMessageInput$Shape = {
  body: MessageWillRename["body"];
};

export const TestPrefixRenamedMessageInput$Ref: InputObjectRef<
  TestPrefixRenamedMessageInput$Shape
> = builder.inputRef<TestPrefixRenamedMessageInput$Shape>(
  "TestPrefixRenamedMessageInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.MessageWillRename",
      name: "MessageWillRename",
      package: "testapis.extensions",
      options: { "[graphql.object_type]": { name: "RenamedMessage" } },
    },
  },
});
",
    "name": "testapis/extensions/TestPrefixRenamedMessageInput.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { InterfaceMessage } from "@testapis/ts-proto/testapis/extensions/extensions";
import { builder } from "../../builder";

export type TestPrefixInterfaceMessageInput$Shape = {
  id: InterfaceMessage["id"];
};

export const TestPrefixInterfaceMessageInput$Ref: InputObjectRef<
  TestPrefixInterfaceMessageInput$Shape
> = builder.inputRef<TestPrefixInterfaceMessageInput$Shape>(
  "TestPrefixInterfaceMessageInput",
).implement({
  fields: (t) => ({
    id: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.InterfaceMessage",
      name: "InterfaceMessage",
      package: "testapis.extensions",
      options: { "[graphql.object_type]": { interface: true } },
    },
  },
});
",
    "name": "testapis/extensions/TestPrefixInterfaceMessageInput.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { PrefixedMessage_InnerMessage } from "@testapis/ts-proto/testapis/extensions/extensions";
import { builder } from "../../builder";

export type TestPrefixPrefixedMessageInnerMessageInput$Shape = {
  id: PrefixedMessage_InnerMessage["id"];
  body: PrefixedMessage_InnerMessage["body"];
};

export const TestPrefixPrefixedMessageInnerMessageInput$Ref: InputObjectRef<
  TestPrefixPrefixedMessageInnerMessageInput$Shape
> = builder.inputRef<TestPrefixPrefixedMessageInnerMessageInput$Shape>(
  "TestPrefixPrefixedMessageInnerMessageInput",
).implement({
  fields: (t) => ({
    id: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.extensions",
    },
  },
});
",
    "name": "testapis/extensions/TestPrefixPrefixedMessageInnerMessageInput.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { PrefixedMessage_InnerMessage2 } from "@testapis/ts-proto/testapis/extensions/extensions";
import { builder } from "../../builder";

export type TestPrefixPrefixedMessageInnerMessage2Input$Shape = {
  id: PrefixedMessage_InnerMessage2["id"];
  body: PrefixedMessage_InnerMessage2["body"];
};

export const TestPrefixPrefixedMessageInnerMessage2Input$Ref: InputObjectRef<
  TestPrefixPrefixedMessageInnerMessage2Input$Shape
> = builder.inputRef<TestPrefixPrefixedMessageInnerMessage2Input$Shape>(
  "TestPrefixPrefixedMessageInnerMessage2Input",
).implement({
  fields: (t) => ({
    id: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage.InnerMessage2",
      name: "InnerMessage2",
      package: "testapis.extensions",
    },
  },
});
",
    "name": "testapis/extensions/TestPrefixPrefixedMessageInnerMessage2Input.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import {
  TestPrefixPrefixedMessageInnerMessage2Input$Ref,
  TestPrefixPrefixedMessageInnerMessage2Input$Shape,
} from "./TestPrefixPrefixedMessageInnerMessage2Input.pothos";
import {
  TestPrefixPrefixedMessageInnerMessageInput$Ref,
  TestPrefixPrefixedMessageInnerMessageInput$Shape,
} from "./TestPrefixPrefixedMessageInnerMessageInput.pothos";

export type TestPrefixPrefixedMessageSquashedMessageInput$Shape = {
  oneofField?: TestPrefixPrefixedMessageInnerMessageInput$Shape | null;
  oneofField2?: TestPrefixPrefixedMessageInnerMessage2Input$Shape | null;
};

export const TestPrefixPrefixedMessageSquashedMessageInput$Ref: InputObjectRef<
  TestPrefixPrefixedMessageSquashedMessageInput$Shape
> = builder.inputRef<TestPrefixPrefixedMessageSquashedMessageInput$Shape>(
  "TestPrefixPrefixedMessageSquashedMessageInput",
).implement({
  fields: (t) => ({
    oneofField: t.field({
      type: TestPrefixPrefixedMessageInnerMessageInput$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "oneof_field",
          typeFullName: "testapis.extensions.PrefixedMessage.InnerMessage",
        },
      },
    }),
    oneofField2: t.field({
      type: TestPrefixPrefixedMessageInnerMessage2Input$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "oneof_field_2",
          typeFullName: "testapis.extensions.PrefixedMessage.InnerMessage2",
        },
      },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
      name: "SquashedMessage",
      package: "testapis.extensions",
      options: { "[graphql.object_type]": { squashUnion: true } },
    },
  },
});
",
    "name": "testapis/extensions/TestPrefixPrefixedMessageSquashedMessageInput.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { IgnoredMessage_NotIgnored } from "@testapis/ts-proto/testapis/extensions/extensions";
import { builder } from "../../builder";

export type TestPrefixIgnoredMessageNotIgnoredInput$Shape = {
  body: IgnoredMessage_NotIgnored["body"];
};

export const TestPrefixIgnoredMessageNotIgnoredInput$Ref: InputObjectRef<
  TestPrefixIgnoredMessageNotIgnoredInput$Shape
> = builder.inputRef<TestPrefixIgnoredMessageNotIgnoredInput$Shape>(
  "TestPrefixIgnoredMessageNotIgnoredInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.IgnoredMessage.NotIgnored",
      name: "NotIgnored",
      package: "testapis.extensions",
    },
  },
});
",
    "name": "testapis/extensions/TestPrefixIgnoredMessageNotIgnoredInput.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import { InterfaceMessage } from "@testapis/ts-proto/testapis/extensions/extensions";
import { builder } from "../../builder";

export const TestPrefixInterfaceMessage$Ref = builder.interfaceRef<
  Pick<InterfaceMessage, "id">
>("TestPrefixInterfaceMessage");
builder.interfaceType(TestPrefixInterfaceMessage$Ref, {
  name: "TestPrefixInterfaceMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.InterfaceMessage",
      name: "InterfaceMessage",
      package: "testapis.extensions",
      options: { "[graphql.object_type]": { interface: true } },
    },
  },
});
",
    "name": "testapis/extensions/TestPrefixInterfaceMessage.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import { builder } from "../../builder";

export const TestPrefixPrefixedMessageSquashedMessage$Ref = builder.unionType(
  "TestPrefixPrefixedMessageSquashedMessage",
  {
    types: [
      TestPrefixPrefixedMessageInnerMessage$Ref,
      TestPrefixPrefixedMessageInnerMessage2$Ref,
    ],
    extensions: {
      protobufOneof: {
        fullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        name: "SquashedMessage",
        package: "testapis.extensions",
        fields: [{
          name: "oneof_field",
          type: "testapis.extensions.PrefixedMessage.InnerMessage",
          options: { "[graphql.object_type]": { squashUnion: true } },
        }, {
          name: "oneof_field_2",
          type: "testapis.extensions.PrefixedMessage.InnerMessage2",
          options: { "[graphql.object_type]": { squashUnion: true } },
        }],
      },
    },
  },
);
",
    "name": "testapis/extensions/TestPrefixPrefixedMessageSquashedMessage.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import { builder } from "../../builder";

export const TestPrefixPrefixedMessagePartialIgnoreOneof$Ref = builder
  .unionType("TestPrefixPrefixedMessagePartialIgnoreOneof", {
    types: [TestPrefixPrefixedMessageInnerMessage$Ref],
    extensions: {
      protobufOneof: {
        fullName: "testapis.extensions.PrefixedMessage.partial_ignore_oneof",
        name: "partial_ignore_oneof",
        messageName: "PrefixedMessage",
        package: "testapis.extensions",
        fields: [{
          name: "oneof_not_ignored_field",
          type: "testapis.extensions.PrefixedMessage.InnerMessage",
        }],
      },
    },
  });
",
    "name": "testapis/extensions/TestPrefixPrefixedMessagePartialIgnoreOneof.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import { builder } from "../../builder";

export const TestPrefixPrefixedEnum$Ref = builder.enumType(
  "TestPrefixPrefixedEnum",
  {
    values: {
      PREFIXED_FOO: {
        value: 1,
        extensions: { protobufEnumValue: { name: "PREFIXED_FOO" } },
      },
      PREFIXED_BAR: {
        value: 2,
        extensions: { protobufEnumValue: { name: "PREFIXED_BAR" } },
      },
    } as const,
    extensions: {
      protobufEnum: {
        name: "PrefixedEnum",
        fullName: "testapis.extensions.PrefixedEnum",
        package: "testapis.extensions",
      },
    },
  },
);
",
    "name": "testapis/extensions/TestPrefixPrefixedEnum.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import { builder } from "../../builder";

export const TestPrefixRenamedEnum$Ref = builder.enumType(
  "TestPrefixRenamedEnum",
  {
    values: {
      FOO: {
        value: 1,
        extensions: { protobufEnumValue: { name: "ENUM_WILL_RENAME_FOO" } },
      },
      BAR: {
        value: 2,
        extensions: { protobufEnumValue: { name: "ENUM_WILL_RENAME_BAR" } },
      },
    } as const,
    extensions: {
      protobufEnum: {
        name: "EnumWillRename",
        fullName: "testapis.extensions.EnumWillRename",
        package: "testapis.extensions",
        options: { "[graphql.enum_type]": { name: "RenamedEnum" } },
      },
    },
  },
);
",
    "name": "testapis/extensions/TestPrefixRenamedEnum.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import { builder } from "../../builder";

export const TestPrefixInterfaceMessageType$Ref = builder.enumType(
  "TestPrefixInterfaceMessageType",
  {
    values: {
      INNER: { value: 1, extensions: { protobufEnumValue: { name: "INNER" } } },
      INNER2: {
        value: 2,
        extensions: { protobufEnumValue: { name: "INNER2" } },
      },
    } as const,
    extensions: {
      protobufEnum: {
        name: "Type",
        fullName: "testapis.extensions.InterfaceMessage.Type",
        package: "testapis.extensions",
      },
    },
  },
);
",
    "name": "testapis/extensions/TestPrefixInterfaceMessageType.pothos.ts",
  },
]
`;

exports[`'testapis.extensions' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import {
  EnumWillRename,
  IgnoredMessage_NotIgnored,
  InterfaceMessage,
  MessageOnlyOutput,
  MessageWillRename,
  PrefixedEnum,
  PrefixedMessage,
  PrefixedMessage_InnerMessage,
  PrefixedMessage_InnerMessage2,
} from "@testapis/ts-proto/testapis/extensions/extensions";
import { builder } from "../../builder";

export const TestPrefixPrefixedMessage$Ref = builder.objectRef<PrefixedMessage>(
  "TestPrefixPrefixedMessage",
);
builder.objectType(TestPrefixPrefixedMessage$Ref, {
  name: "TestPrefixPrefixedMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "String",
      nullable: false,
      description: "Output only.",
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    prefixedEnum: t.field({
      type: TestPrefixPrefixedEnum$Ref,
      nullable: true,
      resolve: (source) => {
        if (source.prefixedEnum === PrefixedEnum.PREFIXED_ENUM_UNSPECIFIED) {
          return null;
        }

        if (source.prefixedEnum === PrefixedEnum.PREFIXED_IGNORED) {
          throw new Error("PREFIXED_IGNORED is ignored in GraphQL schema");
        }

        return source.prefixedEnum;
      },
      extensions: {
        protobufField: {
          name: "prefixed_enum",
          typeFullName: "testapis.extensions.PrefixedEnum",
        },
      },
    }),
    notIgnoredMessage: t.expose("notIgnoredMessage", {
      type: TestPrefixIgnoredMessageNotIgnored$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "not_ignored_message",
          typeFullName: "testapis.extensions.IgnoredMessage.NotIgnored",
        },
      },
    }),
    squashedMessage: t.field({
      type: TestPrefixPrefixedMessageSquashedMessage$Ref,
      nullable: true,
      resolve: (source) => {
        const value = source.squashedMessage?.oneofField ??
          source.squashedMessage?.oneofField2;
        if (value == null) {
          return null;
        }
        return value;
      },
      extensions: {
        protobufField: {
          name: "squashed_message",
          typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        },
      },
    }),
    thisFieldWasRenamed: t.expose("thisFieldWillBeRenamed", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "this_field_will_be_renamed",
          typeFullName: "string",
          options: { "[graphql.field]": { name: "thisFieldWasRenamed" } },
        },
      },
    }),
    skipResolver: t.expose("skipResolver", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "skip_resolver",
          typeFullName: "string",
          options: { "[graphql.field]": { skipResolver: true } },
        },
      },
    }),
    squashedMessages: t.field({
      type: [TestPrefixPrefixedMessageSquashedMessage$Ref],
      nullable: { list: true, items: false },
      resolve: (source) => {
        return source.squashedMessages.map((item) => {
          const value = item?.oneofField ?? item?.oneofField2;
          if (value == null) {
            throw new Error("squashedMessages should not be null");
          }
          return value;
        });
      },
      extensions: {
        protobufField: {
          name: "squashed_messages",
          typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        },
      },
    }),
    renamedMessage: t.expose("renamedMessage", {
      type: TestPrefixRenamedMessage$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "renamed_message",
          typeFullName: "testapis.extensions.MessageWillRename",
        },
      },
    }),
    renamedEnum: t.field({
      type: TestPrefixRenamedEnum$Ref,
      nullable: true,
      resolve: (source) => {
        if (
          source.renamedEnum === EnumWillRename.ENUM_WILL_RENAME_UNSPECIFIED
        ) {
          return null;
        }

        return source.renamedEnum;
      },
      extensions: {
        protobufField: {
          name: "renamed_enum",
          typeFullName: "testapis.extensions.EnumWillRename",
        },
      },
    }),
    partialIgnoreOneof: t.field({
      type: TestPrefixPrefixedMessagePartialIgnoreOneof$Ref,
      nullable: true,
      resolve: (source) => {
        const value = source.oneofNotIgnoredField;
        if (value == null) {
          return null;
        }
        return value;
      },
      extensions: { protobufField: { name: "partial_ignore_oneof" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as PrefixedMessage | { $type: string & {}; }).$type ===
      "testapis.extensions.PrefixedMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage",
      name: "PrefixedMessage",
      package: "testapis.extensions",
    },
  },
});

export const TestPrefixRenamedMessage$Ref = builder.objectRef<
  MessageWillRename
>("TestPrefixRenamedMessage");
builder.objectType(TestPrefixRenamedMessage$Ref, {
  name: "TestPrefixRenamedMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as MessageWillRename | { $type: string & {}; }).$type ===
      "testapis.extensions.MessageWillRename";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.MessageWillRename",
      name: "MessageWillRename",
      package: "testapis.extensions",
      options: { "[graphql.object_type]": { name: "RenamedMessage" } },
    },
  },
});

export const TestPrefixMessageOnlyOutput$Ref = builder.objectRef<
  MessageOnlyOutput
>("TestPrefixMessageOnlyOutput");
builder.objectType(TestPrefixMessageOnlyOutput$Ref, {
  name: "TestPrefixMessageOnlyOutput",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as MessageOnlyOutput | { $type: string & {}; }).$type ===
      "testapis.extensions.MessageOnlyOutput";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.MessageOnlyOutput",
      name: "MessageOnlyOutput",
      package: "testapis.extensions",
      options: { "[graphql.input_type]": { ignore: true } },
    },
  },
});

export const TestPrefixPrefixedMessageInnerMessage$Ref = builder.objectRef<
  PrefixedMessage_InnerMessage
>("TestPrefixPrefixedMessageInnerMessage");
builder.objectType(TestPrefixPrefixedMessageInnerMessage$Ref, {
  name: "TestPrefixPrefixedMessageInnerMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as PrefixedMessage_InnerMessage | { $type: string & {}; })
      .$type === "testapis.extensions.PrefixedMessage.InnerMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.extensions",
    },
  },
});

export const TestPrefixPrefixedMessageInnerMessage2$Ref = builder.objectRef<
  PrefixedMessage_InnerMessage2
>("TestPrefixPrefixedMessageInnerMessage2");
builder.objectType(TestPrefixPrefixedMessageInnerMessage2$Ref, {
  name: "TestPrefixPrefixedMessageInnerMessage2",
  fields: (t) => ({
    id: t.expose("id", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as PrefixedMessage_InnerMessage2 | { $type: string & {}; })
      .$type === "testapis.extensions.PrefixedMessage.InnerMessage2";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage.InnerMessage2",
      name: "InnerMessage2",
      package: "testapis.extensions",
    },
  },
});

export const TestPrefixIgnoredMessageNotIgnored$Ref = builder.objectRef<
  IgnoredMessage_NotIgnored
>("TestPrefixIgnoredMessageNotIgnored");
builder.objectType(TestPrefixIgnoredMessageNotIgnored$Ref, {
  name: "TestPrefixIgnoredMessageNotIgnored",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as IgnoredMessage_NotIgnored | { $type: string & {}; })
      .$type === "testapis.extensions.IgnoredMessage.NotIgnored";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.IgnoredMessage.NotIgnored",
      name: "NotIgnored",
      package: "testapis.extensions",
    },
  },
});

export type TestPrefixPrefixedMessageInput$Shape = {
  body: PrefixedMessage["body"];
  prefixedEnum?: PrefixedMessage["prefixedEnum"] | null;
  notIgnoredMessage?: TestPrefixIgnoredMessageNotIgnoredInput$Shape | null;
  squashedMessage?: TestPrefixPrefixedMessageSquashedMessageInput$Shape | null;
  thisFieldWasRenamed: PrefixedMessage["thisFieldWillBeRenamed"];
  oneofNotIgnoredField?:
    | TestPrefixPrefixedMessageInnerMessageInput$Shape
    | null;
  skipResolver: PrefixedMessage["skipResolver"];
  squashedMessages?:
    | Array<TestPrefixPrefixedMessageSquashedMessageInput$Shape>
    | null;
  renamedMessage?: TestPrefixRenamedMessageInput$Shape | null;
  renamedEnum?: PrefixedMessage["renamedEnum"] | null;
};

export const TestPrefixPrefixedMessageInput$Ref: InputObjectRef<
  TestPrefixPrefixedMessageInput$Shape
> = builder.inputRef<TestPrefixPrefixedMessageInput$Shape>(
  "TestPrefixPrefixedMessageInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    prefixedEnum: t.field({
      type: TestPrefixPrefixedEnum$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "prefixed_enum",
          typeFullName: "testapis.extensions.PrefixedEnum",
        },
      },
    }),
    notIgnoredMessage: t.field({
      type: TestPrefixIgnoredMessageNotIgnoredInput$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "not_ignored_message",
          typeFullName: "testapis.extensions.IgnoredMessage.NotIgnored",
        },
      },
    }),
    squashedMessage: t.field({
      type: TestPrefixPrefixedMessageSquashedMessageInput$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "squashed_message",
          typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        },
      },
    }),
    thisFieldWasRenamed: t.field({
      type: "String",
      required: true,
      extensions: {
        protobufField: {
          name: "this_field_will_be_renamed",
          typeFullName: "string",
          options: { "[graphql.field]": { name: "thisFieldWasRenamed" } },
        },
      },
    }),
    oneofNotIgnoredField: t.field({
      type: TestPrefixPrefixedMessageInnerMessageInput$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "oneof_not_ignored_field",
          typeFullName: "testapis.extensions.PrefixedMessage.InnerMessage",
        },
      },
    }),
    skipResolver: t.field({
      type: "String",
      required: true,
      extensions: {
        protobufField: {
          name: "skip_resolver",
          typeFullName: "string",
          options: { "[graphql.field]": { skipResolver: true } },
        },
      },
    }),
    squashedMessages: t.field({
      type: [TestPrefixPrefixedMessageSquashedMessageInput$Ref],
      required: { list: false, items: true },
      extensions: {
        protobufField: {
          name: "squashed_messages",
          typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        },
      },
    }),
    renamedMessage: t.field({
      type: TestPrefixRenamedMessageInput$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "renamed_message",
          typeFullName: "testapis.extensions.MessageWillRename",
        },
      },
    }),
    renamedEnum: t.field({
      type: TestPrefixRenamedEnum$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "renamed_enum",
          typeFullName: "testapis.extensions.EnumWillRename",
        },
      },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage",
      name: "PrefixedMessage",
      package: "testapis.extensions",
    },
  },
});

export type TestPrefixRenamedMessageInput$Shape = {
  body: MessageWillRename["body"];
};

export const TestPrefixRenamedMessageInput$Ref: InputObjectRef<
  TestPrefixRenamedMessageInput$Shape
> = builder.inputRef<TestPrefixRenamedMessageInput$Shape>(
  "TestPrefixRenamedMessageInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.MessageWillRename",
      name: "MessageWillRename",
      package: "testapis.extensions",
      options: { "[graphql.object_type]": { name: "RenamedMessage" } },
    },
  },
});

export type TestPrefixInterfaceMessageInput$Shape = {
  id: InterfaceMessage["id"];
};

export const TestPrefixInterfaceMessageInput$Ref: InputObjectRef<
  TestPrefixInterfaceMessageInput$Shape
> = builder.inputRef<TestPrefixInterfaceMessageInput$Shape>(
  "TestPrefixInterfaceMessageInput",
).implement({
  fields: (t) => ({
    id: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.InterfaceMessage",
      name: "InterfaceMessage",
      package: "testapis.extensions",
      options: { "[graphql.object_type]": { interface: true } },
    },
  },
});

export type TestPrefixPrefixedMessageInnerMessageInput$Shape = {
  id: PrefixedMessage_InnerMessage["id"];
  body: PrefixedMessage_InnerMessage["body"];
};

export const TestPrefixPrefixedMessageInnerMessageInput$Ref: InputObjectRef<
  TestPrefixPrefixedMessageInnerMessageInput$Shape
> = builder.inputRef<TestPrefixPrefixedMessageInnerMessageInput$Shape>(
  "TestPrefixPrefixedMessageInnerMessageInput",
).implement({
  fields: (t) => ({
    id: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.extensions",
    },
  },
});

export type TestPrefixPrefixedMessageInnerMessage2Input$Shape = {
  id: PrefixedMessage_InnerMessage2["id"];
  body: PrefixedMessage_InnerMessage2["body"];
};

export const TestPrefixPrefixedMessageInnerMessage2Input$Ref: InputObjectRef<
  TestPrefixPrefixedMessageInnerMessage2Input$Shape
> = builder.inputRef<TestPrefixPrefixedMessageInnerMessage2Input$Shape>(
  "TestPrefixPrefixedMessageInnerMessage2Input",
).implement({
  fields: (t) => ({
    id: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage.InnerMessage2",
      name: "InnerMessage2",
      package: "testapis.extensions",
    },
  },
});

export type TestPrefixPrefixedMessageSquashedMessageInput$Shape = {
  oneofField?: TestPrefixPrefixedMessageInnerMessageInput$Shape | null;
  oneofField2?: TestPrefixPrefixedMessageInnerMessage2Input$Shape | null;
};

export const TestPrefixPrefixedMessageSquashedMessageInput$Ref: InputObjectRef<
  TestPrefixPrefixedMessageSquashedMessageInput$Shape
> = builder.inputRef<TestPrefixPrefixedMessageSquashedMessageInput$Shape>(
  "TestPrefixPrefixedMessageSquashedMessageInput",
).implement({
  fields: (t) => ({
    oneofField: t.field({
      type: TestPrefixPrefixedMessageInnerMessageInput$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "oneof_field",
          typeFullName: "testapis.extensions.PrefixedMessage.InnerMessage",
        },
      },
    }),
    oneofField2: t.field({
      type: TestPrefixPrefixedMessageInnerMessage2Input$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "oneof_field_2",
          typeFullName: "testapis.extensions.PrefixedMessage.InnerMessage2",
        },
      },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
      name: "SquashedMessage",
      package: "testapis.extensions",
      options: { "[graphql.object_type]": { squashUnion: true } },
    },
  },
});

export type TestPrefixIgnoredMessageNotIgnoredInput$Shape = {
  body: IgnoredMessage_NotIgnored["body"];
};

export const TestPrefixIgnoredMessageNotIgnoredInput$Ref: InputObjectRef<
  TestPrefixIgnoredMessageNotIgnoredInput$Shape
> = builder.inputRef<TestPrefixIgnoredMessageNotIgnoredInput$Shape>(
  "TestPrefixIgnoredMessageNotIgnoredInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.IgnoredMessage.NotIgnored",
      name: "NotIgnored",
      package: "testapis.extensions",
    },
  },
});

export const TestPrefixInterfaceMessage$Ref = builder.interfaceRef<
  Pick<InterfaceMessage, "id">
>("TestPrefixInterfaceMessage");
builder.interfaceType(TestPrefixInterfaceMessage$Ref, {
  name: "TestPrefixInterfaceMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.InterfaceMessage",
      name: "InterfaceMessage",
      package: "testapis.extensions",
      options: { "[graphql.object_type]": { interface: true } },
    },
  },
});

export const TestPrefixPrefixedMessageSquashedMessage$Ref = builder.unionType(
  "TestPrefixPrefixedMessageSquashedMessage",
  {
    types: [
      TestPrefixPrefixedMessageInnerMessage$Ref,
      TestPrefixPrefixedMessageInnerMessage2$Ref,
    ],
    extensions: {
      protobufOneof: {
        fullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        name: "SquashedMessage",
        package: "testapis.extensions",
        fields: [{
          name: "oneof_field",
          type: "testapis.extensions.PrefixedMessage.InnerMessage",
          options: { "[graphql.object_type]": { squashUnion: true } },
        }, {
          name: "oneof_field_2",
          type: "testapis.extensions.PrefixedMessage.InnerMessage2",
          options: { "[graphql.object_type]": { squashUnion: true } },
        }],
      },
    },
  },
);

export const TestPrefixPrefixedMessagePartialIgnoreOneof$Ref = builder
  .unionType("TestPrefixPrefixedMessagePartialIgnoreOneof", {
    types: [TestPrefixPrefixedMessageInnerMessage$Ref],
    extensions: {
      protobufOneof: {
        fullName: "testapis.extensions.PrefixedMessage.partial_ignore_oneof",
        name: "partial_ignore_oneof",
        messageName: "PrefixedMessage",
        package: "testapis.extensions",
        fields: [{
          name: "oneof_not_ignored_field",
          type: "testapis.extensions.PrefixedMessage.InnerMessage",
        }],
      },
    },
  });

export const TestPrefixPrefixedEnum$Ref = builder.enumType(
  "TestPrefixPrefixedEnum",
  {
    values: {
      PREFIXED_FOO: {
        value: 1,
        extensions: { protobufEnumValue: { name: "PREFIXED_FOO" } },
      },
      PREFIXED_BAR: {
        value: 2,
        extensions: { protobufEnumValue: { name: "PREFIXED_BAR" } },
      },
    } as const,
    extensions: {
      protobufEnum: {
        name: "PrefixedEnum",
        fullName: "testapis.extensions.PrefixedEnum",
        package: "testapis.extensions",
      },
    },
  },
);

export const TestPrefixRenamedEnum$Ref = builder.enumType(
  "TestPrefixRenamedEnum",
  {
    values: {
      FOO: {
        value: 1,
        extensions: { protobufEnumValue: { name: "ENUM_WILL_RENAME_FOO" } },
      },
      BAR: {
        value: 2,
        extensions: { protobufEnumValue: { name: "ENUM_WILL_RENAME_BAR" } },
      },
    } as const,
    extensions: {
      protobufEnum: {
        name: "EnumWillRename",
        fullName: "testapis.extensions.EnumWillRename",
        package: "testapis.extensions",
        options: { "[graphql.enum_type]": { name: "RenamedEnum" } },
      },
    },
  },
);

export const TestPrefixInterfaceMessageType$Ref = builder.enumType(
  "TestPrefixInterfaceMessageType",
  {
    values: {
      INNER: { value: 1, extensions: { protobufEnumValue: { name: "INNER" } } },
      INNER2: {
        value: 2,
        extensions: { protobufEnumValue: { name: "INNER2" } },
      },
    } as const,
    extensions: {
      protobufEnum: {
        name: "Type",
        fullName: "testapis.extensions.InterfaceMessage.Type",
        package: "testapis.extensions",
      },
    },
  },
);
",
    "name": "testapis/extensions/extensions.pb.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/ignored.proto

/* eslint-disable */

export {};
",
    "name": "testapis/extensions/ignored.pb.pothos.ts",
  },
]
`;

exports[`'testapis.extensions' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import {
  EnumWillRename,
  IgnoredMessage_NotIgnored,
  InterfaceMessage,
  MessageOnlyOutput,
  MessageWillRename,
  PrefixedEnum,
  PrefixedMessage,
  PrefixedMessage_InnerMessage,
  PrefixedMessage_InnerMessage2,
} from "@testapis/ts-proto/testapis/extensions/extensions";
import { builder } from "../../builder";

export const TestPrefixPrefixedMessage$Ref = builder.objectRef<PrefixedMessage>(
  "TestPrefixPrefixedMessage",
);
builder.objectType(TestPrefixPrefixedMessage$Ref, {
  name: "TestPrefixPrefixedMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "String",
      nullable: false,
      description: "Output only.",
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    prefixedEnum: t.field({
      type: TestPrefixPrefixedEnum$Ref,
      nullable: true,
      resolve: (source) => {
        if (source.prefixedEnum === PrefixedEnum.PREFIXED_ENUM_UNSPECIFIED) {
          return null;
        }

        if (source.prefixedEnum === PrefixedEnum.PREFIXED_IGNORED) {
          throw new Error("PREFIXED_IGNORED is ignored in GraphQL schema");
        }

        return source.prefixedEnum;
      },
      extensions: {
        protobufField: {
          name: "prefixed_enum",
          typeFullName: "testapis.extensions.PrefixedEnum",
        },
      },
    }),
    notIgnoredMessage: t.expose("notIgnoredMessage", {
      type: TestPrefixIgnoredMessageNotIgnored$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "not_ignored_message",
          typeFullName: "testapis.extensions.IgnoredMessage.NotIgnored",
        },
      },
    }),
    squashedMessage: t.field({
      type: TestPrefixPrefixedMessageSquashedMessage$Ref,
      nullable: true,
      resolve: (source) => {
        const value = source.squashedMessage?.oneofField ??
          source.squashedMessage?.oneofField2;
        if (value == null) {
          return null;
        }
        return value;
      },
      extensions: {
        protobufField: {
          name: "squashed_message",
          typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        },
      },
    }),
    thisFieldWasRenamed: t.expose("thisFieldWillBeRenamed", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "this_field_will_be_renamed",
          typeFullName: "string",
          options: { "[graphql.field]": { name: "thisFieldWasRenamed" } },
        },
      },
    }),
    skipResolver: t.expose("skipResolver", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "skip_resolver",
          typeFullName: "string",
          options: { "[graphql.field]": { skipResolver: true } },
        },
      },
    }),
    squashedMessages: t.field({
      type: [TestPrefixPrefixedMessageSquashedMessage$Ref],
      nullable: { list: true, items: false },
      resolve: (source) => {
        return source.squashedMessages.map((item) => {
          const value = item?.oneofField ?? item?.oneofField2;
          if (value == null) {
            throw new Error("squashedMessages should not be null");
          }
          return value;
        });
      },
      extensions: {
        protobufField: {
          name: "squashed_messages",
          typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        },
      },
    }),
    renamedMessage: t.expose("renamedMessage", {
      type: TestPrefixRenamedMessage$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "renamed_message",
          typeFullName: "testapis.extensions.MessageWillRename",
        },
      },
    }),
    renamedEnum: t.field({
      type: TestPrefixRenamedEnum$Ref,
      nullable: true,
      resolve: (source) => {
        if (
          source.renamedEnum === EnumWillRename.ENUM_WILL_RENAME_UNSPECIFIED
        ) {
          return null;
        }

        return source.renamedEnum;
      },
      extensions: {
        protobufField: {
          name: "renamed_enum",
          typeFullName: "testapis.extensions.EnumWillRename",
        },
      },
    }),
    partialIgnoreOneof: t.field({
      type: TestPrefixPrefixedMessagePartialIgnoreOneof$Ref,
      nullable: true,
      resolve: (source) => {
        const value = source.oneofNotIgnoredField;
        if (value == null) {
          return null;
        }
        return value;
      },
      extensions: { protobufField: { name: "partial_ignore_oneof" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as PrefixedMessage | { $type: string & {}; }).$type ===
      "testapis.extensions.PrefixedMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage",
      name: "PrefixedMessage",
      package: "testapis.extensions",
    },
  },
});

export const TestPrefixRenamedMessage$Ref = builder.objectRef<
  MessageWillRename
>("TestPrefixRenamedMessage");
builder.objectType(TestPrefixRenamedMessage$Ref, {
  name: "TestPrefixRenamedMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as MessageWillRename | { $type: string & {}; }).$type ===
      "testapis.extensions.MessageWillRename";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.MessageWillRename",
      name: "MessageWillRename",
      package: "testapis.extensions",
      options: { "[graphql.object_type]": { name: "RenamedMessage" } },
    },
  },
});

export const TestPrefixMessageOnlyOutput$Ref = builder.objectRef<
  MessageOnlyOutput
>("TestPrefixMessageOnlyOutput");
builder.objectType(TestPrefixMessageOnlyOutput$Ref, {
  name: "TestPrefixMessageOnlyOutput",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as MessageOnlyOutput | { $type: string & {}; }).$type ===
      "testapis.extensions.MessageOnlyOutput";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.MessageOnlyOutput",
      name: "MessageOnlyOutput",
      package: "testapis.extensions",
      options: { "[graphql.input_type]": { ignore: true } },
    },
  },
});

export const TestPrefixPrefixedMessageInnerMessage$Ref = builder.objectRef<
  PrefixedMessage_InnerMessage
>("TestPrefixPrefixedMessageInnerMessage");
builder.objectType(TestPrefixPrefixedMessageInnerMessage$Ref, {
  name: "TestPrefixPrefixedMessageInnerMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as PrefixedMessage_InnerMessage | { $type: string & {}; })
      .$type === "testapis.extensions.PrefixedMessage.InnerMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.extensions",
    },
  },
});

export const TestPrefixPrefixedMessageInnerMessage2$Ref = builder.objectRef<
  PrefixedMessage_InnerMessage2
>("TestPrefixPrefixedMessageInnerMessage2");
builder.objectType(TestPrefixPrefixedMessageInnerMessage2$Ref, {
  name: "TestPrefixPrefixedMessageInnerMessage2",
  fields: (t) => ({
    id: t.expose("id", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as PrefixedMessage_InnerMessage2 | { $type: string & {}; })
      .$type === "testapis.extensions.PrefixedMessage.InnerMessage2";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage.InnerMessage2",
      name: "InnerMessage2",
      package: "testapis.extensions",
    },
  },
});

export const TestPrefixIgnoredMessageNotIgnored$Ref = builder.objectRef<
  IgnoredMessage_NotIgnored
>("TestPrefixIgnoredMessageNotIgnored");
builder.objectType(TestPrefixIgnoredMessageNotIgnored$Ref, {
  name: "TestPrefixIgnoredMessageNotIgnored",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as IgnoredMessage_NotIgnored | { $type: string & {}; })
      .$type === "testapis.extensions.IgnoredMessage.NotIgnored";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.IgnoredMessage.NotIgnored",
      name: "NotIgnored",
      package: "testapis.extensions",
    },
  },
});

export type TestPrefixPrefixedMessageInput$Shape = {
  body: PrefixedMessage["body"];
  prefixedEnum?: PrefixedMessage["prefixedEnum"] | null;
  notIgnoredMessage?: TestPrefixIgnoredMessageNotIgnoredInput$Shape | null;
  squashedMessage?: TestPrefixPrefixedMessageSquashedMessageInput$Shape | null;
  thisFieldWasRenamed: PrefixedMessage["thisFieldWillBeRenamed"];
  oneofNotIgnoredField?:
    | TestPrefixPrefixedMessageInnerMessageInput$Shape
    | null;
  skipResolver: PrefixedMessage["skipResolver"];
  squashedMessages?:
    | Array<TestPrefixPrefixedMessageSquashedMessageInput$Shape>
    | null;
  renamedMessage?: TestPrefixRenamedMessageInput$Shape | null;
  renamedEnum?: PrefixedMessage["renamedEnum"] | null;
};

export const TestPrefixPrefixedMessageInput$Ref: InputObjectRef<
  TestPrefixPrefixedMessageInput$Shape
> = builder.inputRef<TestPrefixPrefixedMessageInput$Shape>(
  "TestPrefixPrefixedMessageInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    prefixedEnum: t.field({
      type: TestPrefixPrefixedEnum$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "prefixed_enum",
          typeFullName: "testapis.extensions.PrefixedEnum",
        },
      },
    }),
    notIgnoredMessage: t.field({
      type: TestPrefixIgnoredMessageNotIgnoredInput$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "not_ignored_message",
          typeFullName: "testapis.extensions.IgnoredMessage.NotIgnored",
        },
      },
    }),
    squashedMessage: t.field({
      type: TestPrefixPrefixedMessageSquashedMessageInput$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "squashed_message",
          typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        },
      },
    }),
    thisFieldWasRenamed: t.field({
      type: "String",
      required: true,
      extensions: {
        protobufField: {
          name: "this_field_will_be_renamed",
          typeFullName: "string",
          options: { "[graphql.field]": { name: "thisFieldWasRenamed" } },
        },
      },
    }),
    oneofNotIgnoredField: t.field({
      type: TestPrefixPrefixedMessageInnerMessageInput$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "oneof_not_ignored_field",
          typeFullName: "testapis.extensions.PrefixedMessage.InnerMessage",
        },
      },
    }),
    skipResolver: t.field({
      type: "String",
      required: true,
      extensions: {
        protobufField: {
          name: "skip_resolver",
          typeFullName: "string",
          options: { "[graphql.field]": { skipResolver: true } },
        },
      },
    }),
    squashedMessages: t.field({
      type: [TestPrefixPrefixedMessageSquashedMessageInput$Ref],
      required: { list: false, items: true },
      extensions: {
        protobufField: {
          name: "squashed_messages",
          typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        },
      },
    }),
    renamedMessage: t.field({
      type: TestPrefixRenamedMessageInput$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "renamed_message",
          typeFullName: "testapis.extensions.MessageWillRename",
        },
      },
    }),
    renamedEnum: t.field({
      type: TestPrefixRenamedEnum$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "renamed_enum",
          typeFullName: "testapis.extensions.EnumWillRename",
        },
      },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage",
      name: "PrefixedMessage",
      package: "testapis.extensions",
    },
  },
});

export type TestPrefixPrefixedMessagePartialInput$Shape = {
  body?: PrefixedMessage["body"] | null;
  prefixedEnum?: PrefixedMessage["prefixedEnum"] | null;
  notIgnoredMessage?:
    | TestPrefixIgnoredMessageNotIgnoredPartialInput$Shape
    | null;
  squashedMessage?:
    | TestPrefixPrefixedMessageSquashedMessagePartialInput$Shape
    | null;
  thisFieldWasRenamed?: PrefixedMessage["thisFieldWillBeRenamed"] | null;
  oneofNotIgnoredField?:
    | TestPrefixPrefixedMessageInnerMessagePartialInput$Shape
    | null;
  skipResolver?: PrefixedMessage["skipResolver"] | null;
  squashedMessages?:
    | Array<TestPrefixPrefixedMessageSquashedMessagePartialInput$Shape>
    | null;
  renamedMessage?: TestPrefixRenamedMessagePartialInput$Shape | null;
  renamedEnum?: PrefixedMessage["renamedEnum"] | null;
};

export const TestPrefixPrefixedMessagePartialInput$Ref: InputObjectRef<
  TestPrefixPrefixedMessagePartialInput$Shape
> = builder.inputRef<TestPrefixPrefixedMessagePartialInput$Shape>(
  "TestPrefixPrefixedMessagePartialInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    prefixedEnum: t.field({
      type: TestPrefixPrefixedEnum$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "prefixed_enum",
          typeFullName: "testapis.extensions.PrefixedEnum",
        },
      },
    }),
    notIgnoredMessage: t.field({
      type: TestPrefixIgnoredMessageNotIgnoredPartialInput$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "not_ignored_message",
          typeFullName: "testapis.extensions.IgnoredMessage.NotIgnored",
        },
      },
    }),
    squashedMessage: t.field({
      type: TestPrefixPrefixedMessageSquashedMessagePartialInput$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "squashed_message",
          typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        },
      },
    }),
    thisFieldWasRenamed: t.field({
      type: "String",
      required: false,
      extensions: {
        protobufField: {
          name: "this_field_will_be_renamed",
          typeFullName: "string",
          options: { "[graphql.field]": { name: "thisFieldWasRenamed" } },
        },
      },
    }),
    oneofNotIgnoredField: t.field({
      type: TestPrefixPrefixedMessageInnerMessagePartialInput$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "oneof_not_ignored_field",
          typeFullName: "testapis.extensions.PrefixedMessage.InnerMessage",
        },
      },
    }),
    skipResolver: t.field({
      type: "String",
      required: false,
      extensions: {
        protobufField: {
          name: "skip_resolver",
          typeFullName: "string",
          options: { "[graphql.field]": { skipResolver: true } },
        },
      },
    }),
    squashedMessages: t.field({
      type: [TestPrefixPrefixedMessageSquashedMessagePartialInput$Ref],
      required: { list: false, items: true },
      extensions: {
        protobufField: {
          name: "squashed_messages",
          typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        },
      },
    }),
    renamedMessage: t.field({
      type: TestPrefixRenamedMessagePartialInput$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "renamed_message",
          typeFullName: "testapis.extensions.MessageWillRename",
        },
      },
    }),
    renamedEnum: t.field({
      type: TestPrefixRenamedEnum$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "renamed_enum",
          typeFullName: "testapis.extensions.EnumWillRename",
        },
      },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage",
      name: "PrefixedMessage",
      package: "testapis.extensions",
    },
  },
});

export type TestPrefixRenamedMessageInput$Shape = {
  body: MessageWillRename["body"];
};

export const TestPrefixRenamedMessageInput$Ref: InputObjectRef<
  TestPrefixRenamedMessageInput$Shape
> = builder.inputRef<TestPrefixRenamedMessageInput$Shape>(
  "TestPrefixRenamedMessageInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.MessageWillRename",
      name: "MessageWillRename",
      package: "testapis.extensions",
      options: { "[graphql.object_type]": { name: "RenamedMessage" } },
    },
  },
});

export type TestPrefixRenamedMessagePartialInput$Shape = {
  body?: MessageWillRename["body"] | null;
};

export const TestPrefixRenamedMessagePartialInput$Ref: InputObjectRef<
  TestPrefixRenamedMessagePartialInput$Shape
> = builder.inputRef<TestPrefixRenamedMessagePartialInput$Shape>(
  "TestPrefixRenamedMessagePartialInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.MessageWillRename",
      name: "MessageWillRename",
      package: "testapis.extensions",
      options: { "[graphql.object_type]": { name: "RenamedMessage" } },
    },
  },
});

export type TestPrefixInterfaceMessageInput$Shape = {
  id: InterfaceMessage["id"];
};

export const TestPrefixInterfaceMessageInput$Ref: InputObjectRef<
  TestPrefixInterfaceMessageInput$Shape
> = builder.inputRef<TestPrefixInterfaceMessageInput$Shape>(
  "TestPrefixInterfaceMessageInput",
).implement({
  fields: (t) => ({
    id: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.InterfaceMessage",
      name: "InterfaceMessage",
      package: "testapis.extensions",
      options: { "[graphql.object_type]": { interface: true } },
    },
  },
});

export type TestPrefixInterfaceMessagePartialInput$Shape = {
  id?: InterfaceMessage["id"] | null;
};

export const TestPrefixInterfaceMessagePartialInput$Ref: InputObjectRef<
  TestPrefixInterfaceMessagePartialInput$Shape
> = builder.inputRef<TestPrefixInterfaceMessagePartialInput$Shape>(
  "TestPrefixInterfaceMessagePartialInput",
).implement({
  fields: (t) => ({
    id: t.field({
      type: "String",
      required: false,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.InterfaceMessage",
      name: "InterfaceMessage",
      package: "testapis.extensions",
      options: { "[graphql.object_type]": { interface: true } },
    },
  },
});

export type TestPrefixPrefixedMessageInnerMessageInput$Shape = {
  id: PrefixedMessage_InnerMessage["id"];
  body: PrefixedMessage_InnerMessage["body"];
};

export const TestPrefixPrefixedMessageInnerMessageInput$Ref: InputObjectRef<
  TestPrefixPrefixedMessageInnerMessageInput$Shape
> = builder.inputRef<TestPrefixPrefixedMessageInnerMessageInput$Shape>(
  "TestPrefixPrefixedMessageInnerMessageInput",
).implement({
  fields: (t) => ({
    id: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.extensions",
    },
  },
});

export type TestPrefixPrefixedMessageInnerMessagePartialInput$Shape = {
  id?: PrefixedMessage_InnerMessage["id"] | null;
  body?: PrefixedMessage_InnerMessage["body"] | null;
};

export const TestPrefixPrefixedMessageInnerMessagePartialInput$Ref:
  InputObjectRef<TestPrefixPrefixedMessageInnerMessagePartialInput$Shape> =
    builder.inputRef<TestPrefixPrefixedMessageInnerMessagePartialInput$Shape>(
      "TestPrefixPrefixedMessageInnerMessagePartialInput",
    ).implement({
      fields: (t) => ({
        id: t.field({
          type: "String",
          required: false,
          extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
        }),
        body: t.field({
          type: "String",
          required: false,
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.extensions.PrefixedMessage.InnerMessage",
          name: "InnerMessage",
          package: "testapis.extensions",
        },
      },
    });

export type TestPrefixPrefixedMessageInnerMessage2Input$Shape = {
  id: PrefixedMessage_InnerMessage2["id"];
  body: PrefixedMessage_InnerMessage2["body"];
};

export const TestPrefixPrefixedMessageInnerMessage2Input$Ref: InputObjectRef<
  TestPrefixPrefixedMessageInnerMessage2Input$Shape
> = builder.inputRef<TestPrefixPrefixedMessageInnerMessage2Input$Shape>(
  "TestPrefixPrefixedMessageInnerMessage2Input",
).implement({
  fields: (t) => ({
    id: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage.InnerMessage2",
      name: "InnerMessage2",
      package: "testapis.extensions",
    },
  },
});

export type TestPrefixPrefixedMessageInnerMessage2PartialInput$Shape = {
  id?: PrefixedMessage_InnerMessage2["id"] | null;
  body?: PrefixedMessage_InnerMessage2["body"] | null;
};

export const TestPrefixPrefixedMessageInnerMessage2PartialInput$Ref:
  InputObjectRef<TestPrefixPrefixedMessageInnerMessage2PartialInput$Shape> =
    builder.inputRef<TestPrefixPrefixedMessageInnerMessage2PartialInput$Shape>(
      "TestPrefixPrefixedMessageInnerMessage2PartialInput",
    ).implement({
      fields: (t) => ({
        id: t.field({
          type: "String",
          required: false,
          extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
        }),
        body: t.field({
          type: "String",
          required: false,
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.extensions.PrefixedMessage.InnerMessage2",
          name: "InnerMessage2",
          package: "testapis.extensions",
        },
      },
    });

export type TestPrefixPrefixedMessageSquashedMessageInput$Shape = {
  oneofField?: TestPrefixPrefixedMessageInnerMessageInput$Shape | null;
  oneofField2?: TestPrefixPrefixedMessageInnerMessage2Input$Shape | null;
};

export const TestPrefixPrefixedMessageSquashedMessageInput$Ref: InputObjectRef<
  TestPrefixPrefixedMessageSquashedMessageInput$Shape
> = builder.inputRef<TestPrefixPrefixedMessageSquashedMessageInput$Shape>(
  "TestPrefixPrefixedMessageSquashedMessageInput",
).implement({
  fields: (t) => ({
    oneofField: t.field({
      type: TestPrefixPrefixedMessageInnerMessageInput$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "oneof_field",
          typeFullName: "testapis.extensions.PrefixedMessage.InnerMessage",
        },
      },
    }),
    oneofField2: t.field({
      type: TestPrefixPrefixedMessageInnerMessage2Input$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "oneof_field_2",
          typeFullName: "testapis.extensions.PrefixedMessage.InnerMessage2",
        },
      },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
      name: "SquashedMessage",
      package: "testapis.extensions",
      options: { "[graphql.object_type]": { squashUnion: true } },
    },
  },
});

export type TestPrefixPrefixedMessageSquashedMessagePartialInput$Shape = {
  oneofField?: TestPrefixPrefixedMessageInnerMessagePartialInput$Shape | null;
  oneofField2?:
    | TestPrefixPrefixedMessageInnerMessage2PartialInput$Shape
    | null;
};

export const TestPrefixPrefixedMessageSquashedMessagePartialInput$Ref:
  InputObjectRef<TestPrefixPrefixedMessageSquashedMessagePartialInput$Shape> =
    builder.inputRef<
      TestPrefixPrefixedMessageSquashedMessagePartialInput$Shape
    >("TestPrefixPrefixedMessageSquashedMessagePartialInput").implement({
      fields: (t) => ({
        oneofField: t.field({
          type: TestPrefixPrefixedMessageInnerMessagePartialInput$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "oneof_field",
              typeFullName: "testapis.extensions.PrefixedMessage.InnerMessage",
            },
          },
        }),
        oneofField2: t.field({
          type: TestPrefixPrefixedMessageInnerMessage2PartialInput$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "oneof_field_2",
              typeFullName: "testapis.extensions.PrefixedMessage.InnerMessage2",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
          name: "SquashedMessage",
          package: "testapis.extensions",
          options: { "[graphql.object_type]": { squashUnion: true } },
        },
      },
    });

export type TestPrefixIgnoredMessageNotIgnoredInput$Shape = {
  body: IgnoredMessage_NotIgnored["body"];
};

export const TestPrefixIgnoredMessageNotIgnoredInput$Ref: InputObjectRef<
  TestPrefixIgnoredMessageNotIgnoredInput$Shape
> = builder.inputRef<TestPrefixIgnoredMessageNotIgnoredInput$Shape>(
  "TestPrefixIgnoredMessageNotIgnoredInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.IgnoredMessage.NotIgnored",
      name: "NotIgnored",
      package: "testapis.extensions",
    },
  },
});

export type TestPrefixIgnoredMessageNotIgnoredPartialInput$Shape = {
  body?: IgnoredMessage_NotIgnored["body"] | null;
};

export const TestPrefixIgnoredMessageNotIgnoredPartialInput$Ref: InputObjectRef<
  TestPrefixIgnoredMessageNotIgnoredPartialInput$Shape
> = builder.inputRef<TestPrefixIgnoredMessageNotIgnoredPartialInput$Shape>(
  "TestPrefixIgnoredMessageNotIgnoredPartialInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.IgnoredMessage.NotIgnored",
      name: "NotIgnored",
      package: "testapis.extensions",
    },
  },
});

export const TestPrefixInterfaceMessage$Ref = builder.interfaceRef<
  Pick<InterfaceMessage, "id">
>("TestPrefixInterfaceMessage");
builder.interfaceType(TestPrefixInterfaceMessage$Ref, {
  name: "TestPrefixInterfaceMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.InterfaceMessage",
      name: "InterfaceMessage",
      package: "testapis.extensions",
      options: { "[graphql.object_type]": { interface: true } },
    },
  },
});

export const TestPrefixPrefixedMessageSquashedMessage$Ref = builder.unionType(
  "TestPrefixPrefixedMessageSquashedMessage",
  {
    types: [
      TestPrefixPrefixedMessageInnerMessage$Ref,
      TestPrefixPrefixedMessageInnerMessage2$Ref,
    ],
    extensions: {
      protobufOneof: {
        fullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        name: "SquashedMessage",
        package: "testapis.extensions",
        fields: [{
          name: "oneof_field",
          type: "testapis.extensions.PrefixedMessage.InnerMessage",
          options: { "[graphql.object_type]": { squashUnion: true } },
        }, {
          name: "oneof_field_2",
          type: "testapis.extensions.PrefixedMessage.InnerMessage2",
          options: { "[graphql.object_type]": { squashUnion: true } },
        }],
      },
    },
  },
);

export const TestPrefixPrefixedMessagePartialIgnoreOneof$Ref = builder
  .unionType("TestPrefixPrefixedMessagePartialIgnoreOneof", {
    types: [TestPrefixPrefixedMessageInnerMessage$Ref],
    extensions: {
      protobufOneof: {
        fullName: "testapis.extensions.PrefixedMessage.partial_ignore_oneof",
        name: "partial_ignore_oneof",
        messageName: "PrefixedMessage",
        package: "testapis.extensions",
        fields: [{
          name: "oneof_not_ignored_field",
          type: "testapis.extensions.PrefixedMessage.InnerMessage",
        }],
      },
    },
  });

export const TestPrefixPrefixedEnum$Ref = builder.enumType(
  "TestPrefixPrefixedEnum",
  {
    values: {
      PREFIXED_FOO: {
        value: 1,
        extensions: { protobufEnumValue: { name: "PREFIXED_FOO" } },
      },
      PREFIXED_BAR: {
        value: 2,
        extensions: { protobufEnumValue: { name: "PREFIXED_BAR" } },
      },
    } as const,
    extensions: {
      protobufEnum: {
        name: "PrefixedEnum",
        fullName: "testapis.extensions.PrefixedEnum",
        package: "testapis.extensions",
      },
    },
  },
);

export const TestPrefixRenamedEnum$Ref = builder.enumType(
  "TestPrefixRenamedEnum",
  {
    values: {
      FOO: {
        value: 1,
        extensions: { protobufEnumValue: { name: "ENUM_WILL_RENAME_FOO" } },
      },
      BAR: {
        value: 2,
        extensions: { protobufEnumValue: { name: "ENUM_WILL_RENAME_BAR" } },
      },
    } as const,
    extensions: {
      protobufEnum: {
        name: "EnumWillRename",
        fullName: "testapis.extensions.EnumWillRename",
        package: "testapis.extensions",
        options: { "[graphql.enum_type]": { name: "RenamedEnum" } },
      },
    },
  },
);

export const TestPrefixInterfaceMessageType$Ref = builder.enumType(
  "TestPrefixInterfaceMessageType",
  {
    values: {
      INNER: { value: 1, extensions: { protobufEnumValue: { name: "INNER" } } },
      INNER2: {
        value: 2,
        extensions: { protobufEnumValue: { name: "INNER2" } },
      },
    } as const,
    extensions: {
      protobufEnum: {
        name: "Type",
        fullName: "testapis.extensions.InterfaceMessage.Type",
        package: "testapis.extensions",
      },
    },
  },
);
",
    "name": "testapis/extensions/extensions.pb.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/ignored.proto

/* eslint-disable */

export {};
",
    "name": "testapis/extensions/ignored.pb.pothos.ts",
  },
]
`;

exports[`'testapis.extensions' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import {
  EnumWillRename,
  IgnoredMessage_NotIgnored,
  InterfaceMessage,
  MessageOnlyOutput,
  MessageWillRename,
  PrefixedEnum,
  PrefixedMessage,
  PrefixedMessage_InnerMessage,
  PrefixedMessage_InnerMessage2,
} from "./testapis/extensions/extensions";

export const TestPrefixPrefixedMessage$Ref = builder.objectRef<PrefixedMessage>(
  "TestPrefixPrefixedMessage",
);
builder.objectType(TestPrefixPrefixedMessage$Ref, {
  name: "TestPrefixPrefixedMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "String",
      nullable: false,
      description: "Output only.",
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    prefixedEnum: t.field({
      type: TestPrefixPrefixedEnum$Ref,
      nullable: true,
      resolve: (source) => {
        if (source.prefixedEnum === PrefixedEnum.PREFIXED_ENUM_UNSPECIFIED) {
          return null;
        }

        if (source.prefixedEnum === PrefixedEnum.PREFIXED_IGNORED) {
          throw new Error("PREFIXED_IGNORED is ignored in GraphQL schema");
        }

        return source.prefixedEnum;
      },
      extensions: {
        protobufField: {
          name: "prefixed_enum",
          typeFullName: "testapis.extensions.PrefixedEnum",
        },
      },
    }),
    notIgnoredMessage: t.expose("notIgnoredMessage", {
      type: TestPrefixIgnoredMessageNotIgnored$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "not_ignored_message",
          typeFullName: "testapis.extensions.IgnoredMessage.NotIgnored",
        },
      },
    }),
    squashedMessage: t.field({
      type: TestPrefixPrefixedMessageSquashedMessage$Ref,
      nullable: true,
      resolve: (source) => {
        const value = source.squashedMessage?.oneofField ??
          source.squashedMessage?.oneofField2;
        if (value == null) {
          return null;
        }
        return value;
      },
      extensions: {
        protobufField: {
          name: "squashed_message",
          typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        },
      },
    }),
    thisFieldWasRenamed: t.expose("thisFieldWillBeRenamed", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "this_field_will_be_renamed",
          typeFullName: "string",
          options: { "[graphql.field]": { name: "thisFieldWasRenamed" } },
        },
      },
    }),
    skipResolver: t.expose("skipResolver", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "skip_resolver",
          typeFullName: "string",
          options: { "[graphql.field]": { skipResolver: true } },
        },
      },
    }),
    squashedMessages: t.field({
      type: [TestPrefixPrefixedMessageSquashedMessage$Ref],
      nullable: { list: true, items: false },
      resolve: (source) => {
        return source.squashedMessages.map((item) => {
          const value = item?.oneofField ?? item?.oneofField2;
          if (value == null) {
            throw new Error("squashedMessages should not be null");
          }
          return value;
        });
      },
      extensions: {
        protobufField: {
          name: "squashed_messages",
          typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        },
      },
    }),
    renamedMessage: t.expose("renamedMessage", {
      type: TestPrefixRenamedMessage$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "renamed_message",
          typeFullName: "testapis.extensions.MessageWillRename",
        },
      },
    }),
    renamedEnum: t.field({
      type: TestPrefixRenamedEnum$Ref,
      nullable: true,
      resolve: (source) => {
        if (
          source.renamedEnum === EnumWillRename.ENUM_WILL_RENAME_UNSPECIFIED
        ) {
          return null;
        }

        return source.renamedEnum;
      },
      extensions: {
        protobufField: {
          name: "renamed_enum",
          typeFullName: "testapis.extensions.EnumWillRename",
        },
      },
    }),
    partialIgnoreOneof: t.field({
      type: TestPrefixPrefixedMessagePartialIgnoreOneof$Ref,
      nullable: true,
      resolve: (source) => {
        const value = source.oneofNotIgnoredField;
        if (value == null) {
          return null;
        }
        return value;
      },
      extensions: { protobufField: { name: "partial_ignore_oneof" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as PrefixedMessage | { $type: string & {}; }).$type ===
      "testapis.extensions.PrefixedMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage",
      name: "PrefixedMessage",
      package: "testapis.extensions",
    },
  },
});

export const TestPrefixRenamedMessage$Ref = builder.objectRef<
  MessageWillRename
>("TestPrefixRenamedMessage");
builder.objectType(TestPrefixRenamedMessage$Ref, {
  name: "TestPrefixRenamedMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as MessageWillRename | { $type: string & {}; }).$type ===
      "testapis.extensions.MessageWillRename";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.MessageWillRename",
      name: "MessageWillRename",
      package: "testapis.extensions",
      options: { "[graphql.object_type]": { name: "RenamedMessage" } },
    },
  },
});

export const TestPrefixMessageOnlyOutput$Ref = builder.objectRef<
  MessageOnlyOutput
>("TestPrefixMessageOnlyOutput");
builder.objectType(TestPrefixMessageOnlyOutput$Ref, {
  name: "TestPrefixMessageOnlyOutput",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as MessageOnlyOutput | { $type: string & {}; }).$type ===
      "testapis.extensions.MessageOnlyOutput";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.MessageOnlyOutput",
      name: "MessageOnlyOutput",
      package: "testapis.extensions",
      options: { "[graphql.input_type]": { ignore: true } },
    },
  },
});

export const TestPrefixPrefixedMessageInnerMessage$Ref = builder.objectRef<
  PrefixedMessage_InnerMessage
>("TestPrefixPrefixedMessageInnerMessage");
builder.objectType(TestPrefixPrefixedMessageInnerMessage$Ref, {
  name: "TestPrefixPrefixedMessageInnerMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as PrefixedMessage_InnerMessage | { $type: string & {}; })
      .$type === "testapis.extensions.PrefixedMessage.InnerMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.extensions",
    },
  },
});

export const TestPrefixPrefixedMessageInnerMessage2$Ref = builder.objectRef<
  PrefixedMessage_InnerMessage2
>("TestPrefixPrefixedMessageInnerMessage2");
builder.objectType(TestPrefixPrefixedMessageInnerMessage2$Ref, {
  name: "TestPrefixPrefixedMessageInnerMessage2",
  fields: (t) => ({
    id: t.expose("id", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as PrefixedMessage_InnerMessage2 | { $type: string & {}; })
      .$type === "testapis.extensions.PrefixedMessage.InnerMessage2";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage.InnerMessage2",
      name: "InnerMessage2",
      package: "testapis.extensions",
    },
  },
});

export const TestPrefixIgnoredMessageNotIgnored$Ref = builder.objectRef<
  IgnoredMessage_NotIgnored
>("TestPrefixIgnoredMessageNotIgnored");
builder.objectType(TestPrefixIgnoredMessageNotIgnored$Ref, {
  name: "TestPrefixIgnoredMessageNotIgnored",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as IgnoredMessage_NotIgnored | { $type: string & {}; })
      .$type === "testapis.extensions.IgnoredMessage.NotIgnored";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.IgnoredMessage.NotIgnored",
      name: "NotIgnored",
      package: "testapis.extensions",
    },
  },
});

export type TestPrefixPrefixedMessageInput$Shape = {
  body: PrefixedMessage["body"];
  prefixedEnum?: PrefixedMessage["prefixedEnum"] | null;
  notIgnoredMessage?: TestPrefixIgnoredMessageNotIgnoredInput$Shape | null;
  squashedMessage?: TestPrefixPrefixedMessageSquashedMessageInput$Shape | null;
  thisFieldWasRenamed: PrefixedMessage["thisFieldWillBeRenamed"];
  oneofNotIgnoredField?:
    | TestPrefixPrefixedMessageInnerMessageInput$Shape
    | null;
  skipResolver: PrefixedMessage["skipResolver"];
  squashedMessages?:
    | Array<TestPrefixPrefixedMessageSquashedMessageInput$Shape>
    | null;
  renamedMessage?: TestPrefixRenamedMessageInput$Shape | null;
  renamedEnum?: PrefixedMessage["renamedEnum"] | null;
};

export const TestPrefixPrefixedMessageInput$Ref: InputObjectRef<
  TestPrefixPrefixedMessageInput$Shape
> = builder.inputRef<TestPrefixPrefixedMessageInput$Shape>(
  "TestPrefixPrefixedMessageInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    prefixedEnum: t.field({
      type: TestPrefixPrefixedEnum$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "prefixed_enum",
          typeFullName: "testapis.extensions.PrefixedEnum",
        },
      },
    }),
    notIgnoredMessage: t.field({
      type: TestPrefixIgnoredMessageNotIgnoredInput$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "not_ignored_message",
          typeFullName: "testapis.extensions.IgnoredMessage.NotIgnored",
        },
      },
    }),
    squashedMessage: t.field({
      type: TestPrefixPrefixedMessageSquashedMessageInput$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "squashed_message",
          typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        },
      },
    }),
    thisFieldWasRenamed: t.field({
      type: "String",
      required: true,
      extensions: {
        protobufField: {
          name: "this_field_will_be_renamed",
          typeFullName: "string",
          options: { "[graphql.field]": { name: "thisFieldWasRenamed" } },
        },
      },
    }),
    oneofNotIgnoredField: t.field({
      type: TestPrefixPrefixedMessageInnerMessageInput$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "oneof_not_ignored_field",
          typeFullName: "testapis.extensions.PrefixedMessage.InnerMessage",
        },
      },
    }),
    skipResolver: t.field({
      type: "String",
      required: true,
      extensions: {
        protobufField: {
          name: "skip_resolver",
          typeFullName: "string",
          options: { "[graphql.field]": { skipResolver: true } },
        },
      },
    }),
    squashedMessages: t.field({
      type: [TestPrefixPrefixedMessageSquashedMessageInput$Ref],
      required: { list: false, items: true },
      extensions: {
        protobufField: {
          name: "squashed_messages",
          typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        },
      },
    }),
    renamedMessage: t.field({
      type: TestPrefixRenamedMessageInput$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "renamed_message",
          typeFullName: "testapis.extensions.MessageWillRename",
        },
      },
    }),
    renamedEnum: t.field({
      type: TestPrefixRenamedEnum$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "renamed_enum",
          typeFullName: "testapis.extensions.EnumWillRename",
        },
      },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage",
      name: "PrefixedMessage",
      package: "testapis.extensions",
    },
  },
});

export type TestPrefixRenamedMessageInput$Shape = {
  body: MessageWillRename["body"];
};

export const TestPrefixRenamedMessageInput$Ref: InputObjectRef<
  TestPrefixRenamedMessageInput$Shape
> = builder.inputRef<TestPrefixRenamedMessageInput$Shape>(
  "TestPrefixRenamedMessageInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.MessageWillRename",
      name: "MessageWillRename",
      package: "testapis.extensions",
      options: { "[graphql.object_type]": { name: "RenamedMessage" } },
    },
  },
});

export type TestPrefixInterfaceMessageInput$Shape = {
  id: InterfaceMessage["id"];
};

export const TestPrefixInterfaceMessageInput$Ref: InputObjectRef<
  TestPrefixInterfaceMessageInput$Shape
> = builder.inputRef<TestPrefixInterfaceMessageInput$Shape>(
  "TestPrefixInterfaceMessageInput",
).implement({
  fields: (t) => ({
    id: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.InterfaceMessage",
      name: "InterfaceMessage",
      package: "testapis.extensions",
      options: { "[graphql.object_type]": { interface: true } },
    },
  },
});

export type TestPrefixPrefixedMessageInnerMessageInput$Shape = {
  id: PrefixedMessage_InnerMessage["id"];
  body: PrefixedMessage_InnerMessage["body"];
};

export const TestPrefixPrefixedMessageInnerMessageInput$Ref: InputObjectRef<
  TestPrefixPrefixedMessageInnerMessageInput$Shape
> = builder.inputRef<TestPrefixPrefixedMessageInnerMessageInput$Shape>(
  "TestPrefixPrefixedMessageInnerMessageInput",
).implement({
  fields: (t) => ({
    id: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.extensions",
    },
  },
});

export type TestPrefixPrefixedMessageInnerMessage2Input$Shape = {
  id: PrefixedMessage_InnerMessage2["id"];
  body: PrefixedMessage_InnerMessage2["body"];
};

export const TestPrefixPrefixedMessageInnerMessage2Input$Ref: InputObjectRef<
  TestPrefixPrefixedMessageInnerMessage2Input$Shape
> = builder.inputRef<TestPrefixPrefixedMessageInnerMessage2Input$Shape>(
  "TestPrefixPrefixedMessageInnerMessage2Input",
).implement({
  fields: (t) => ({
    id: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage.InnerMessage2",
      name: "InnerMessage2",
      package: "testapis.extensions",
    },
  },
});

export type TestPrefixPrefixedMessageSquashedMessageInput$Shape = {
  oneofField?: TestPrefixPrefixedMessageInnerMessageInput$Shape | null;
  oneofField2?: TestPrefixPrefixedMessageInnerMessage2Input$Shape | null;
};

export const TestPrefixPrefixedMessageSquashedMessageInput$Ref: InputObjectRef<
  TestPrefixPrefixedMessageSquashedMessageInput$Shape
> = builder.inputRef<TestPrefixPrefixedMessageSquashedMessageInput$Shape>(
  "TestPrefixPrefixedMessageSquashedMessageInput",
).implement({
  fields: (t) => ({
    oneofField: t.field({
      type: TestPrefixPrefixedMessageInnerMessageInput$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "oneof_field",
          typeFullName: "testapis.extensions.PrefixedMessage.InnerMessage",
        },
      },
    }),
    oneofField2: t.field({
      type: TestPrefixPrefixedMessageInnerMessage2Input$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "oneof_field_2",
          typeFullName: "testapis.extensions.PrefixedMessage.InnerMessage2",
        },
      },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
      name: "SquashedMessage",
      package: "testapis.extensions",
      options: { "[graphql.object_type]": { squashUnion: true } },
    },
  },
});

export type TestPrefixIgnoredMessageNotIgnoredInput$Shape = {
  body: IgnoredMessage_NotIgnored["body"];
};

export const TestPrefixIgnoredMessageNotIgnoredInput$Ref: InputObjectRef<
  TestPrefixIgnoredMessageNotIgnoredInput$Shape
> = builder.inputRef<TestPrefixIgnoredMessageNotIgnoredInput$Shape>(
  "TestPrefixIgnoredMessageNotIgnoredInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.IgnoredMessage.NotIgnored",
      name: "NotIgnored",
      package: "testapis.extensions",
    },
  },
});

export const TestPrefixInterfaceMessage$Ref = builder.interfaceRef<
  Pick<InterfaceMessage, "id">
>("TestPrefixInterfaceMessage");
builder.interfaceType(TestPrefixInterfaceMessage$Ref, {
  name: "TestPrefixInterfaceMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.InterfaceMessage",
      name: "InterfaceMessage",
      package: "testapis.extensions",
      options: { "[graphql.object_type]": { interface: true } },
    },
  },
});

export const TestPrefixPrefixedMessageSquashedMessage$Ref = builder.unionType(
  "TestPrefixPrefixedMessageSquashedMessage",
  {
    types: [
      TestPrefixPrefixedMessageInnerMessage$Ref,
      TestPrefixPrefixedMessageInnerMessage2$Ref,
    ],
    extensions: {
      protobufOneof: {
        fullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        name: "SquashedMessage",
        package: "testapis.extensions",
        fields: [{
          name: "oneof_field",
          type: "testapis.extensions.PrefixedMessage.InnerMessage",
          options: { "[graphql.object_type]": { squashUnion: true } },
        }, {
          name: "oneof_field_2",
          type: "testapis.extensions.PrefixedMessage.InnerMessage2",
          options: { "[graphql.object_type]": { squashUnion: true } },
        }],
      },
    },
  },
);

export const TestPrefixPrefixedMessagePartialIgnoreOneof$Ref = builder
  .unionType("TestPrefixPrefixedMessagePartialIgnoreOneof", {
    types: [TestPrefixPrefixedMessageInnerMessage$Ref],
    extensions: {
      protobufOneof: {
        fullName: "testapis.extensions.PrefixedMessage.partial_ignore_oneof",
        name: "partial_ignore_oneof",
        messageName: "PrefixedMessage",
        package: "testapis.extensions",
        fields: [{
          name: "oneof_not_ignored_field",
          type: "testapis.extensions.PrefixedMessage.InnerMessage",
        }],
      },
    },
  });

export const TestPrefixPrefixedEnum$Ref = builder.enumType(
  "TestPrefixPrefixedEnum",
  {
    values: {
      PREFIXED_FOO: {
        value: 1,
        extensions: { protobufEnumValue: { name: "PREFIXED_FOO" } },
      },
      PREFIXED_BAR: {
        value: 2,
        extensions: { protobufEnumValue: { name: "PREFIXED_BAR" } },
      },
    } as const,
    extensions: {
      protobufEnum: {
        name: "PrefixedEnum",
        fullName: "testapis.extensions.PrefixedEnum",
        package: "testapis.extensions",
      },
    },
  },
);

export const TestPrefixRenamedEnum$Ref = builder.enumType(
  "TestPrefixRenamedEnum",
  {
    values: {
      FOO: {
        value: 1,
        extensions: { protobufEnumValue: { name: "ENUM_WILL_RENAME_FOO" } },
      },
      BAR: {
        value: 2,
        extensions: { protobufEnumValue: { name: "ENUM_WILL_RENAME_BAR" } },
      },
    } as const,
    extensions: {
      protobufEnum: {
        name: "EnumWillRename",
        fullName: "testapis.extensions.EnumWillRename",
        package: "testapis.extensions",
        options: { "[graphql.enum_type]": { name: "RenamedEnum" } },
      },
    },
  },
);

export const TestPrefixInterfaceMessageType$Ref = builder.enumType(
  "TestPrefixInterfaceMessageType",
  {
    values: {
      INNER: { value: 1, extensions: { protobufEnumValue: { name: "INNER" } } },
      INNER2: {
        value: 2,
        extensions: { protobufEnumValue: { name: "INNER2" } },
      },
    } as const,
    extensions: {
      protobufEnum: {
        name: "Type",
        fullName: "testapis.extensions.InterfaceMessage.Type",
        package: "testapis.extensions",
      },
    },
  },
);
",
    "name": "testapis/extensions/extensions.pb.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/ignored.proto

/* eslint-disable */

export {};
",
    "name": "testapis/extensions/ignored.pb.pothos.ts",
  },
]
`;

exports[`'testapis.extensions.field_nullability' > generates files by plugin 'with graphql_type layout' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/field_nullability/nullability.proto

/* eslint-disable */

import {
  Message,
  Message_Status,
} from "@testapis/ts-proto/testapis/extensions/field_nullability/nullability";
import { builder } from "../../../builder";
import { MessageStatus$Ref } from "./MessageStatus.pothos";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    userId: t.expose("userId", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: {
        protobufField: {
          name: "user_id",
          typeFullName: "uint64",
          options: {
            "[graphql.field]": {
              outputNullability: "NON_NULL",
              inputNullability: "NULLABLE",
              partialInputNullability: "NON_NULL",
            },
          },
        },
      },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    status: t.field({
      type: MessageStatus$Ref,
      nullable: true,
      description: "Required.",
      resolve: (source) => {
        if (source.status === Message_Status.STATUS_UNSPECIFIED) {
          return null;
        }

        return source.status;
      },
      extensions: {
        protobufField: {
          name: "status",
          typeFullName: "testapis.extensions.field_nullability.Message.Status",
          options: {
            "[graphql.field]": {
              outputNullability: "NULLABLE",
              inputNullability: "NULLABLE",
            },
          },
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Message | { $type: string & {}; }).$type ===
      "testapis.extensions.field_nullability.Message";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.field_nullability.Message",
      name: "Message",
      package: "testapis.extensions.field_nullability",
    },
  },
});
",
    "name": "testapis/extensions/field_nullability/Message.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/field_nullability/nullability.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { Message } from "@testapis/ts-proto/testapis/extensions/field_nullability/nullability";
import { builder } from "../../../builder";
import { MessageStatus$Ref } from "./MessageStatus.pothos";

export type MessageInput$Shape = {
  userId?: Message["userId"] | null;
  body: Message["body"];
  status?: Message["status"] | null;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement({
    fields: (t) => ({
      userId: t.field({
        type: "String",
        required: false,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "user_id",
            typeFullName: "uint64",
            options: {
              "[graphql.field]": {
                outputNullability: "NON_NULL",
                inputNullability: "NULLABLE",
                partialInputNullability: "NON_NULL",
              },
            },
          },
        },
      }),
      body: t.field({
        type: "String",
        required: true,
        description: "Required.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
      status: t.field({
        type: MessageStatus$Ref,
        required: false,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "status",
            typeFullName:
              "testapis.extensions.field_nullability.Message.Status",
            options: {
              "[graphql.field]": {
                outputNullability: "NULLABLE",
                inputNullability: "NULLABLE",
              },
            },
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.field_nullability.Message",
        name: "Message",
        package: "testapis.extensions.field_nullability",
      },
    },
  });
",
    "name": "testapis/extensions/field_nullability/MessageInput.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/field_nullability/nullability.proto

/* eslint-disable */

import { builder } from "../../../builder";

export const MessageStatus$Ref = builder.enumType("MessageStatus", {
  values: {
    DRAFT: { value: 1, extensions: { protobufEnumValue: { name: "DRAFT" } } },
    PUBLISHED: {
      value: 2,
      extensions: { protobufEnumValue: { name: "PUBLISHED" } },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "Status",
      fullName: "testapis.extensions.field_nullability.Message.Status",
      package: "testapis.extensions.field_nullability",
    },
  },
});
",
    "name": "testapis/extensions/field_nullability/MessageStatus.pothos.ts",
  },
]
`;

exports[`'testapis.extensions.field_nullability' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/field_nullability/nullability.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import {
  Message,
  Message_Status,
} from "@testapis/ts-proto/testapis/extensions/field_nullability/nullability";
import { builder } from "../../../builder";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    userId: t.expose("userId", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: {
        protobufField: {
          name: "user_id",
          typeFullName: "uint64",
          options: {
            "[graphql.field]": {
              outputNullability: "NON_NULL",
              inputNullability: "NULLABLE",
              partialInputNullability: "NON_NULL",
            },
          },
        },
      },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    status: t.field({
      type: MessageStatus$Ref,
      nullable: true,
      description: "Required.",
      resolve: (source) => {
        if (source.status === Message_Status.STATUS_UNSPECIFIED) {
          return null;
        }

        return source.status;
      },
      extensions: {
        protobufField: {
          name: "status",
          typeFullName: "testapis.extensions.field_nullability.Message.Status",
          options: {
            "[graphql.field]": {
              outputNullability: "NULLABLE",
              inputNullability: "NULLABLE",
            },
          },
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Message | { $type: string & {}; }).$type ===
      "testapis.extensions.field_nullability.Message";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.field_nullability.Message",
      name: "Message",
      package: "testapis.extensions.field_nullability",
    },
  },
});

export type MessageInput$Shape = {
  userId?: Message["userId"] | null;
  body: Message["body"];
  status?: Message["status"] | null;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement({
    fields: (t) => ({
      userId: t.field({
        type: "String",
        required: false,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "user_id",
            typeFullName: "uint64",
            options: {
              "[graphql.field]": {
                outputNullability: "NON_NULL",
                inputNullability: "NULLABLE",
                partialInputNullability: "NON_NULL",
              },
            },
          },
        },
      }),
      body: t.field({
        type: "String",
        required: true,
        description: "Required.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
      status: t.field({
        type: MessageStatus$Ref,
        required: false,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "status",
            typeFullName:
              "testapis.extensions.field_nullability.Message.Status",
            options: {
              "[graphql.field]": {
                outputNullability: "NULLABLE",
                inputNullability: "NULLABLE",
              },
            },
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.field_nullability.Message",
        name: "Message",
        package: "testapis.extensions.field_nullability",
      },
    },
  });

export const MessageStatus$Ref = builder.enumType("MessageStatus", {
  values: {
    DRAFT: { value: 1, extensions: { protobufEnumValue: { name: "DRAFT" } } },
    PUBLISHED: {
      value: 2,
      extensions: { protobufEnumValue: { name: "PUBLISHED" } },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "Status",
      fullName: "testapis.extensions.field_nullability.Message.Status",
      package: "testapis.extensions.field_nullability",
    },
  },
});
",
    "name": "testapis/extensions/field_nullability/nullability.pb.pothos.ts",
  },
]
`;

exports[`'testapis.extensions.field_nullability' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/field_nullability/nullability.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import {
  Message,
  Message_Status,
} from "@testapis/ts-proto/testapis/extensions/field_nullability/nullability";
import { builder } from "../../../builder";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    userId: t.expose("userId", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: {
        protobufField: {
          name: "user_id",
          typeFullName: "uint64",
          options: {
            "[graphql.field]": {
              outputNullability: "NON_NULL",
              inputNullability: "NULLABLE",
              partialInputNullability: "NON_NULL",
            },
          },
        },
      },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    status: t.field({
      type: MessageStatus$Ref,
      nullable: true,
      description: "Required.",
      resolve: (source) => {
        if (source.status === Message_Status.STATUS_UNSPECIFIED) {
          return null;
        }

        return source.status;
      },
      extensions: {
        protobufField: {
          name: "status",
          typeFullName: "testapis.extensions.field_nullability.Message.Status",
          options: {
            "[graphql.field]": {
              outputNullability: "NULLABLE",
              inputNullability: "NULLABLE",
            },
          },
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Message | { $type: string & {}; }).$type ===
      "testapis.extensions.field_nullability.Message";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.field_nullability.Message",
      name: "Message",
      package: "testapis.extensions.field_nullability",
    },
  },
});

export type MessageInput$Shape = {
  userId?: Message["userId"] | null;
  body: Message["body"];
  status?: Message["status"] | null;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement({
    fields: (t) => ({
      userId: t.field({
        type: "String",
        required: false,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "user_id",
            typeFullName: "uint64",
            options: {
              "[graphql.field]": {
                outputNullability: "NON_NULL",
                inputNullability: "NULLABLE",
                partialInputNullability: "NON_NULL",
              },
            },
          },
        },
      }),
      body: t.field({
        type: "String",
        required: true,
        description: "Required.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
      status: t.field({
        type: MessageStatus$Ref,
        required: false,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "status",
            typeFullName:
              "testapis.extensions.field_nullability.Message.Status",
            options: {
              "[graphql.field]": {
                outputNullability: "NULLABLE",
                inputNullability: "NULLABLE",
              },
            },
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.field_nullability.Message",
        name: "Message",
        package: "testapis.extensions.field_nullability",
      },
    },
  });

export type MessagePartialInput$Shape = {
  userId: Message["userId"];
  body?: Message["body"] | null;
  status?: Message["status"] | null;
};

export const MessagePartialInput$Ref: InputObjectRef<
  MessagePartialInput$Shape
> = builder.inputRef<MessagePartialInput$Shape>("MessagePartialInput")
  .implement({
    fields: (t) => ({
      userId: t.field({
        type: "String",
        required: true,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "user_id",
            typeFullName: "uint64",
            options: {
              "[graphql.field]": {
                outputNullability: "NON_NULL",
                inputNullability: "NULLABLE",
                partialInputNullability: "NON_NULL",
              },
            },
          },
        },
      }),
      body: t.field({
        type: "String",
        required: false,
        description: "Required.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
      status: t.field({
        type: MessageStatus$Ref,
        required: false,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "status",
            typeFullName:
              "testapis.extensions.field_nullability.Message.Status",
            options: {
              "[graphql.field]": {
                outputNullability: "NULLABLE",
                inputNullability: "NULLABLE",
              },
            },
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.field_nullability.Message",
        name: "Message",
        package: "testapis.extensions.field_nullability",
      },
    },
  });

export const MessageStatus$Ref = builder.enumType("MessageStatus", {
  values: {
    DRAFT: { value: 1, extensions: { protobufEnumValue: { name: "DRAFT" } } },
    PUBLISHED: {
      value: 2,
      extensions: { protobufEnumValue: { name: "PUBLISHED" } },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "Status",
      fullName: "testapis.extensions.field_nullability.Message.Status",
      package: "testapis.extensions.field_nullability",
    },
  },
});
",
    "name": "testapis/extensions/field_nullability/nullability.pb.pothos.ts",
  },
]
`;

exports[`'testapis.extensions.field_nullability' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/field_nullability/nullability.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../../builder";
import {
  Message,
  Message_Status,
} from "./testapis/extensions/field_nullability/nullability";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    userId: t.expose("userId", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: {
        protobufField: {
          name: "user_id",
          typeFullName: "uint64",
          options: {
            "[graphql.field]": {
              outputNullability: "NON_NULL",
              inputNullability: "NULLABLE",
              partialInputNullability: "NON_NULL",
            },
          },
        },
      },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    status: t.field({
      type: MessageStatus$Ref,
      nullable: true,
      description: "Required.",
      resolve: (source) => {
        if (source.status === Message_Status.STATUS_UNSPECIFIED) {
          return null;
        }

        return source.status;
      },
      extensions: {
        protobufField: {
          name: "status",
          typeFullName: "testapis.extensions.field_nullability.Message.Status",
          options: {
            "[graphql.field]": {
              outputNullability: "NULLABLE",
              inputNullability: "NULLABLE",
            },
          },
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Message | { $type: string & {}; }).$type ===
      "testapis.extensions.field_nullability.Message";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.field_nullability.Message",
      name: "Message",
      package: "testapis.extensions.field_nullability",
    },
  },
});

export type MessageInput$Shape = {
  userId?: Message["userId"] | null;
  body: Message["body"];
  status?: Message["status"] | null;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement({
    fields: (t) => ({
      userId: t.field({
        type: "String",
        required: false,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "user_id",
            typeFullName: "uint64",
            options: {
              "[graphql.field]": {
                outputNullability: "NON_NULL",
                inputNullability: "NULLABLE",
                partialInputNullability: "NON_NULL",
              },
            },
          },
        },
      }),
      body: t.field({
        type: "String",
        required: true,
        description: "Required.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
      status: t.field({
        type: MessageStatus$Ref,
        required: false,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "status",
            typeFullName:
              "testapis.extensions.field_nullability.Message.Status",
            options: {
              "[graphql.field]": {
                outputNullability: "NULLABLE",
                inputNullability: "NULLABLE",
              },
            },
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.field_nullability.Message",
        name: "Message",
        package: "testapis.extensions.field_nullability",
      },
    },
  });

export const MessageStatus$Ref = builder.enumType("MessageStatus", {
  values: {
    DRAFT: { value: 1, extensions: { protobufEnumValue: { name: "DRAFT" } } },
    PUBLISHED: {
      value: 2,
      extensions: { protobufEnumValue: { name: "PUBLISHED" } },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "Status",
      fullName: "testapis.extensions.field_nullability.Message.Status",
      package: "testapis.extensions.field_nullability",
    },
  },
});
",
    "name": "testapis/extensions/field_nullability/nullability.pb.pothos.ts",
  },
]
`;

exports[`'testapis.extensions.no_partial' > generates files by plugin 'with graphql_type layout' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/no_partial/no_partial.proto

/* eslint-disable */

import { ParentMessage } from "@testapis/ts-proto/testapis/extensions/no_partial/no_partial";
import { builder } from "../../../builder";
import { NoPartialInputMessage$Ref } from "./NoPartialInputMessage.pothos";
import { PartialableInputMessage$Ref } from "./PartialableInputMessage.pothos";

export const ParentMessage$Ref = builder.objectRef<ParentMessage>(
  "ParentMessage",
);
builder.objectType(ParentMessage$Ref, {
  name: "ParentMessage",
  fields: (t) => ({
    partialableInputMessage: t.field({
      type: PartialableInputMessage$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.partialableInputMessage!;
      },
      extensions: {
        protobufField: {
          name: "partialable_input_message",
          typeFullName:
            "testapis.extensions.no_partial.PartialableInputMessage",
        },
      },
    }),
    noPartialInputMessage: t.field({
      type: NoPartialInputMessage$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.noPartialInputMessage!;
      },
      extensions: {
        protobufField: {
          name: "no_partial_input_message",
          typeFullName: "testapis.extensions.no_partial.NoPartialInputMessage",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as ParentMessage | { $type: string & {}; }).$type ===
      "testapis.extensions.no_partial.ParentMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.no_partial.ParentMessage",
      name: "ParentMessage",
      package: "testapis.extensions.no_partial",
    },
  },
});
",
    "name": "testapis/extensions/no_partial/ParentMessage.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/no_partial/no_partial.proto

/* eslint-disable */

import { PartialableInputMessage } from "@testapis/ts-proto/testapis/extensions/no_partial/no_partial";
import { builder } from "../../../builder";

export const PartialableInputMessage$Ref = builder.objectRef<
  PartialableInputMessage
>("PartialableInputMessage");
builder.objectType(PartialableInputMessage$Ref, {
  name: "PartialableInputMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as PartialableInputMessage | { $type: string & {}; })
      .$type === "testapis.extensions.no_partial.PartialableInputMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.no_partial.PartialableInputMessage",
      name: "PartialableInputMessage",
      package: "testapis.extensions.no_partial",
    },
  },
});
",
    "name": "testapis/extensions/no_partial/PartialableInputMessage.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/no_partial/no_partial.proto

/* eslint-disable */

import { NoPartialInputMessage } from "@testapis/ts-proto/testapis/extensions/no_partial/no_partial";
import { builder } from "../../../builder";

export const NoPartialInputMessage$Ref = builder.objectRef<
  NoPartialInputMessage
>("NoPartialInputMessage");
builder.objectType(NoPartialInputMessage$Ref, {
  name: "NoPartialInputMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as NoPartialInputMessage | { $type: string & {}; }).$type ===
      "testapis.extensions.no_partial.NoPartialInputMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.no_partial.NoPartialInputMessage",
      name: "NoPartialInputMessage",
      package: "testapis.extensions.no_partial",
      options: { "[graphql.input_type]": { noPartial: true } },
    },
  },
});
",
    "name": "testapis/extensions/no_partial/NoPartialInputMessage.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/no_partial/no_partial.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../../builder";
import {
  NoPartialInputMessageInput$Ref,
  NoPartialInputMessageInput$Shape,
} from "./NoPartialInputMessageInput.pothos";
import {
  PartialableInputMessageInput$Ref,
  PartialableInputMessageInput$Shape,
} from "./PartialableInputMessageInput.pothos";

export type ParentMessageInput$Shape = {
  partialableInputMessage: PartialableInputMessageInput$Shape;
  noPartialInputMessage: NoPartialInputMessageInput$Shape;
};

export const ParentMessageInput$Ref: InputObjectRef<ParentMessageInput$Shape> =
  builder.inputRef<ParentMessageInput$Shape>("ParentMessageInput").implement({
    fields: (t) => ({
      partialableInputMessage: t.field({
        type: PartialableInputMessageInput$Ref,
        required: true,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "partialable_input_message",
            typeFullName:
              "testapis.extensions.no_partial.PartialableInputMessage",
          },
        },
      }),
      noPartialInputMessage: t.field({
        type: NoPartialInputMessageInput$Ref,
        required: true,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "no_partial_input_message",
            typeFullName:
              "testapis.extensions.no_partial.NoPartialInputMessage",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.no_partial.ParentMessage",
        name: "ParentMessage",
        package: "testapis.extensions.no_partial",
      },
    },
  });
",
    "name": "testapis/extensions/no_partial/ParentMessageInput.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/no_partial/no_partial.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { PartialableInputMessage } from "@testapis/ts-proto/testapis/extensions/no_partial/no_partial";
import { builder } from "../../../builder";

export type PartialableInputMessageInput$Shape = {
  id: PartialableInputMessage["id"];
  body: PartialableInputMessage["body"];
};

export const PartialableInputMessageInput$Ref: InputObjectRef<
  PartialableInputMessageInput$Shape
> = builder.inputRef<PartialableInputMessageInput$Shape>(
  "PartialableInputMessageInput",
).implement({
  fields: (t) => ({
    id: t.field({
      type: "String",
      required: true,
      description: "Required.",
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.field({
      type: "String",
      required: true,
      description: "Required.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.no_partial.PartialableInputMessage",
      name: "PartialableInputMessage",
      package: "testapis.extensions.no_partial",
    },
  },
});
",
    "name": "testapis/extensions/no_partial/PartialableInputMessageInput.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/no_partial/no_partial.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { NoPartialInputMessage } from "@testapis/ts-proto/testapis/extensions/no_partial/no_partial";
import { builder } from "../../../builder";

export type NoPartialInputMessageInput$Shape = {
  id: NoPartialInputMessage["id"];
  body: NoPartialInputMessage["body"];
};

export const NoPartialInputMessageInput$Ref: InputObjectRef<
  NoPartialInputMessageInput$Shape
> = builder.inputRef<NoPartialInputMessageInput$Shape>(
  "NoPartialInputMessageInput",
).implement({
  fields: (t) => ({
    id: t.field({
      type: "String",
      required: true,
      description: "Required.",
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.field({
      type: "String",
      required: true,
      description: "Required.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.no_partial.NoPartialInputMessage",
      name: "NoPartialInputMessage",
      package: "testapis.extensions.no_partial",
      options: { "[graphql.input_type]": { noPartial: true } },
    },
  },
});
",
    "name": "testapis/extensions/no_partial/NoPartialInputMessageInput.pothos.ts",
  },
]
`;

exports[`'testapis.extensions.no_partial' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/no_partial/no_partial.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import {
  NoPartialInputMessage,
  ParentMessage,
  PartialableInputMessage,
} from "@testapis/ts-proto/testapis/extensions/no_partial/no_partial";
import { builder } from "../../../builder";

export const ParentMessage$Ref = builder.objectRef<ParentMessage>(
  "ParentMessage",
);
builder.objectType(ParentMessage$Ref, {
  name: "ParentMessage",
  fields: (t) => ({
    partialableInputMessage: t.field({
      type: PartialableInputMessage$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.partialableInputMessage!;
      },
      extensions: {
        protobufField: {
          name: "partialable_input_message",
          typeFullName:
            "testapis.extensions.no_partial.PartialableInputMessage",
        },
      },
    }),
    noPartialInputMessage: t.field({
      type: NoPartialInputMessage$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.noPartialInputMessage!;
      },
      extensions: {
        protobufField: {
          name: "no_partial_input_message",
          typeFullName: "testapis.extensions.no_partial.NoPartialInputMessage",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as ParentMessage | { $type: string & {}; }).$type ===
      "testapis.extensions.no_partial.ParentMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.no_partial.ParentMessage",
      name: "ParentMessage",
      package: "testapis.extensions.no_partial",
    },
  },
});

export const PartialableInputMessage$Ref = builder.objectRef<
  PartialableInputMessage
>("PartialableInputMessage");
builder.objectType(PartialableInputMessage$Ref, {
  name: "PartialableInputMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as PartialableInputMessage | { $type: string & {}; })
      .$type === "testapis.extensions.no_partial.PartialableInputMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.no_partial.PartialableInputMessage",
      name: "PartialableInputMessage",
      package: "testapis.extensions.no_partial",
    },
  },
});

export const NoPartialInputMessage$Ref = builder.objectRef<
  NoPartialInputMessage
>("NoPartialInputMessage");
builder.objectType(NoPartialInputMessage$Ref, {
  name: "NoPartialInputMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as NoPartialInputMessage | { $type: string & {}; }).$type ===
      "testapis.extensions.no_partial.NoPartialInputMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.no_partial.NoPartialInputMessage",
      name: "NoPartialInputMessage",
      package: "testapis.extensions.no_partial",
      options: { "[graphql.input_type]": { noPartial: true } },
    },
  },
});

export type ParentMessageInput$Shape = {
  partialableInputMessage: PartialableInputMessageInput$Shape;
  noPartialInputMessage: NoPartialInputMessageInput$Shape;
};

export const ParentMessageInput$Ref: InputObjectRef<ParentMessageInput$Shape> =
  builder.inputRef<ParentMessageInput$Shape>("ParentMessageInput").implement({
    fields: (t) => ({
      partialableInputMessage: t.field({
        type: PartialableInputMessageInput$Ref,
        required: true,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "partialable_input_message",
            typeFullName:
              "testapis.extensions.no_partial.PartialableInputMessage",
          },
        },
      }),
      noPartialInputMessage: t.field({
        type: NoPartialInputMessageInput$Ref,
        required: true,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "no_partial_input_message",
            typeFullName:
              "testapis.extensions.no_partial.NoPartialInputMessage",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.no_partial.ParentMessage",
        name: "ParentMessage",
        package: "testapis.extensions.no_partial",
      },
    },
  });

export type PartialableInputMessageInput$Shape = {
  id: PartialableInputMessage["id"];
  body: PartialableInputMessage["body"];
};

export const PartialableInputMessageInput$Ref: InputObjectRef<
  PartialableInputMessageInput$Shape
> = builder.inputRef<PartialableInputMessageInput$Shape>(
  "PartialableInputMessageInput",
).implement({
  fields: (t) => ({
    id: t.field({
      type: "String",
      required: true,
      description: "Required.",
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.field({
      type: "String",
      required: true,
      description: "Required.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.no_partial.PartialableInputMessage",
      name: "PartialableInputMessage",
      package: "testapis.extensions.no_partial",
    },
  },
});

export type NoPartialInputMessageInput$Shape = {
  id: NoPartialInputMessage["id"];
  body: NoPartialInputMessage["body"];
};

export const NoPartialInputMessageInput$Ref: InputObjectRef<
  NoPartialInputMessageInput$Shape
> = builder.inputRef<NoPartialInputMessageInput$Shape>(
  "NoPartialInputMessageInput",
).implement({
  fields: (t) => ({
    id: t.field({
      type: "String",
      required: true,
      description: "Required.",
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.field({
      type: "String",
      required: true,
      description: "Required.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.no_partial.NoPartialInputMessage",
      name: "NoPartialInputMessage",
      package: "testapis.extensions.no_partial",
      options: { "[graphql.input_type]": { noPartial: true } },
    },
  },
});
",
    "name": "testapis/extensions/no_partial/no_partial.pb.pothos.ts",
  },
]
`;

exports[`'testapis.extensions.no_partial' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/no_partial/no_partial.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import {
  NoPartialInputMessage,
  ParentMessage,
  PartialableInputMessage,
} from "@testapis/ts-proto/testapis/extensions/no_partial/no_partial";
import { builder } from "../../../builder";

export const ParentMessage$Ref = builder.objectRef<ParentMessage>(
  "ParentMessage",
);
builder.objectType(ParentMessage$Ref, {
  name: "ParentMessage",
  fields: (t) => ({
    partialableInputMessage: t.field({
      type: PartialableInputMessage$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.partialableInputMessage!;
      },
      extensions: {
        protobufField: {
          name: "partialable_input_message",
          typeFullName:
            "testapis.extensions.no_partial.PartialableInputMessage",
        },
      },
    }),
    noPartialInputMessage: t.field({
      type: NoPartialInputMessage$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.noPartialInputMessage!;
      },
      extensions: {
        protobufField: {
          name: "no_partial_input_message",
          typeFullName: "testapis.extensions.no_partial.NoPartialInputMessage",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as ParentMessage | { $type: string & {}; }).$type ===
      "testapis.extensions.no_partial.ParentMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.no_partial.ParentMessage",
      name: "ParentMessage",
      package: "testapis.extensions.no_partial",
    },
  },
});

export const PartialableInputMessage$Ref = builder.objectRef<
  PartialableInputMessage
>("PartialableInputMessage");
builder.objectType(PartialableInputMessage$Ref, {
  name: "PartialableInputMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as PartialableInputMessage | { $type: string & {}; })
      .$type === "testapis.extensions.no_partial.PartialableInputMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.no_partial.PartialableInputMessage",
      name: "PartialableInputMessage",
      package: "testapis.extensions.no_partial",
    },
  },
});

export const NoPartialInputMessage$Ref = builder.objectRef<
  NoPartialInputMessage
>("NoPartialInputMessage");
builder.objectType(NoPartialInputMessage$Ref, {
  name: "NoPartialInputMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as NoPartialInputMessage | { $type: string & {}; }).$type ===
      "testapis.extensions.no_partial.NoPartialInputMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.no_partial.NoPartialInputMessage",
      name: "NoPartialInputMessage",
      package: "testapis.extensions.no_partial",
      options: { "[graphql.input_type]": { noPartial: true } },
    },
  },
});

export type ParentMessageInput$Shape = {
  partialableInputMessage: PartialableInputMessageInput$Shape;
  noPartialInputMessage: NoPartialInputMessageInput$Shape;
};

export const ParentMessageInput$Ref: InputObjectRef<ParentMessageInput$Shape> =
  builder.inputRef<ParentMessageInput$Shape>("ParentMessageInput").implement({
    fields: (t) => ({
      partialableInputMessage: t.field({
        type: PartialableInputMessageInput$Ref,
        required: true,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "partialable_input_message",
            typeFullName:
              "testapis.extensions.no_partial.PartialableInputMessage",
          },
        },
      }),
      noPartialInputMessage: t.field({
        type: NoPartialInputMessageInput$Ref,
        required: true,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "no_partial_input_message",
            typeFullName:
              "testapis.extensions.no_partial.NoPartialInputMessage",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.no_partial.ParentMessage",
        name: "ParentMessage",
        package: "testapis.extensions.no_partial",
      },
    },
  });

export type ParentMessagePartialInput$Shape = {
  partialableInputMessage?: PartialableInputMessagePartialInput$Shape | null;
  noPartialInputMessage?: NoPartialInputMessageInput$Shape | null;
};

export const ParentMessagePartialInput$Ref: InputObjectRef<
  ParentMessagePartialInput$Shape
> = builder.inputRef<ParentMessagePartialInput$Shape>(
  "ParentMessagePartialInput",
).implement({
  fields: (t) => ({
    partialableInputMessage: t.field({
      type: PartialableInputMessagePartialInput$Ref,
      required: false,
      description: "Required.",
      extensions: {
        protobufField: {
          name: "partialable_input_message",
          typeFullName:
            "testapis.extensions.no_partial.PartialableInputMessage",
        },
      },
    }),
    noPartialInputMessage: t.field({
      type: NoPartialInputMessageInput$Ref,
      required: false,
      description: "Required.",
      extensions: {
        protobufField: {
          name: "no_partial_input_message",
          typeFullName: "testapis.extensions.no_partial.NoPartialInputMessage",
        },
      },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.no_partial.ParentMessage",
      name: "ParentMessage",
      package: "testapis.extensions.no_partial",
    },
  },
});

export type PartialableInputMessageInput$Shape = {
  id: PartialableInputMessage["id"];
  body: PartialableInputMessage["body"];
};

export const PartialableInputMessageInput$Ref: InputObjectRef<
  PartialableInputMessageInput$Shape
> = builder.inputRef<PartialableInputMessageInput$Shape>(
  "PartialableInputMessageInput",
).implement({
  fields: (t) => ({
    id: t.field({
      type: "String",
      required: true,
      description: "Required.",
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.field({
      type: "String",
      required: true,
      description: "Required.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.no_partial.PartialableInputMessage",
      name: "PartialableInputMessage",
      package: "testapis.extensions.no_partial",
    },
  },
});

export type PartialableInputMessagePartialInput$Shape = {
  id?: PartialableInputMessage["id"] | null;
  body?: PartialableInputMessage["body"] | null;
};

export const PartialableInputMessagePartialInput$Ref: InputObjectRef<
  PartialableInputMessagePartialInput$Shape
> = builder.inputRef<PartialableInputMessagePartialInput$Shape>(
  "PartialableInputMessagePartialInput",
).implement({
  fields: (t) => ({
    id: t.field({
      type: "String",
      required: false,
      description: "Required.",
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.field({
      type: "String",
      required: false,
      description: "Required.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.no_partial.PartialableInputMessage",
      name: "PartialableInputMessage",
      package: "testapis.extensions.no_partial",
    },
  },
});

export type NoPartialInputMessageInput$Shape = {
  id: NoPartialInputMessage["id"];
  body: NoPartialInputMessage["body"];
};

export const NoPartialInputMessageInput$Ref: InputObjectRef<
  NoPartialInputMessageInput$Shape
> = builder.inputRef<NoPartialInputMessageInput$Shape>(
  "NoPartialInputMessageInput",
).implement({
  fields: (t) => ({
    id: t.field({
      type: "String",
      required: true,
      description: "Required.",
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.field({
      type: "String",
      required: true,
      description: "Required.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.no_partial.NoPartialInputMessage",
      name: "NoPartialInputMessage",
      package: "testapis.extensions.no_partial",
      options: { "[graphql.input_type]": { noPartial: true } },
    },
  },
});
",
    "name": "testapis/extensions/no_partial/no_partial.pb.pothos.ts",
  },
]
`;

exports[`'testapis.extensions.no_partial' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/no_partial/no_partial.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../../builder";
import {
  NoPartialInputMessage,
  ParentMessage,
  PartialableInputMessage,
} from "./testapis/extensions/no_partial/no_partial";

export const ParentMessage$Ref = builder.objectRef<ParentMessage>(
  "ParentMessage",
);
builder.objectType(ParentMessage$Ref, {
  name: "ParentMessage",
  fields: (t) => ({
    partialableInputMessage: t.field({
      type: PartialableInputMessage$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.partialableInputMessage!;
      },
      extensions: {
        protobufField: {
          name: "partialable_input_message",
          typeFullName:
            "testapis.extensions.no_partial.PartialableInputMessage",
        },
      },
    }),
    noPartialInputMessage: t.field({
      type: NoPartialInputMessage$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.noPartialInputMessage!;
      },
      extensions: {
        protobufField: {
          name: "no_partial_input_message",
          typeFullName: "testapis.extensions.no_partial.NoPartialInputMessage",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as ParentMessage | { $type: string & {}; }).$type ===
      "testapis.extensions.no_partial.ParentMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.no_partial.ParentMessage",
      name: "ParentMessage",
      package: "testapis.extensions.no_partial",
    },
  },
});

export const PartialableInputMessage$Ref = builder.objectRef<
  PartialableInputMessage
>("PartialableInputMessage");
builder.objectType(PartialableInputMessage$Ref, {
  name: "PartialableInputMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as PartialableInputMessage | { $type: string & {}; })
      .$type === "testapis.extensions.no_partial.PartialableInputMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.no_partial.PartialableInputMessage",
      name: "PartialableInputMessage",
      package: "testapis.extensions.no_partial",
    },
  },
});

export const NoPartialInputMessage$Ref = builder.objectRef<
  NoPartialInputMessage
>("NoPartialInputMessage");
builder.objectType(NoPartialInputMessage$Ref, {
  name: "NoPartialInputMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as NoPartialInputMessage | { $type: string & {}; }).$type ===
      "testapis.extensions.no_partial.NoPartialInputMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.no_partial.NoPartialInputMessage",
      name: "NoPartialInputMessage",
      package: "testapis.extensions.no_partial",
      options: { "[graphql.input_type]": { noPartial: true } },
    },
  },
});

export type ParentMessageInput$Shape = {
  partialableInputMessage: PartialableInputMessageInput$Shape;
  noPartialInputMessage: NoPartialInputMessageInput$Shape;
};

export const ParentMessageInput$Ref: InputObjectRef<ParentMessageInput$Shape> =
  builder.inputRef<ParentMessageInput$Shape>("ParentMessageInput").implement({
    fields: (t) => ({
      partialableInputMessage: t.field({
        type: PartialableInputMessageInput$Ref,
        required: true,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "partialable_input_message",
            typeFullName:
              "testapis.extensions.no_partial.PartialableInputMessage",
          },
        },
      }),
      noPartialInputMessage: t.field({
        type: NoPartialInputMessageInput$Ref,
        required: true,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "no_partial_input_message",
            typeFullName:
              "testapis.extensions.no_partial.NoPartialInputMessage",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.no_partial.ParentMessage",
        name: "ParentMessage",
        package: "testapis.extensions.no_partial",
      },
    },
  });

export type PartialableInputMessageInput$Shape = {
  id: PartialableInputMessage["id"];
  body: PartialableInputMessage["body"];
};

export const PartialableInputMessageInput$Ref: InputObjectRef<
  PartialableInputMessageInput$Shape
> = builder.inputRef<PartialableInputMessageInput$Shape>(
  "PartialableInputMessageInput",
).implement({
  fields: (t) => ({
    id: t.field({
      type: "String",
      required: true,
      description: "Required.",
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.field({
      type: "String",
      required: true,
      description: "Required.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.no_partial.PartialableInputMessage",
      name: "PartialableInputMessage",
      package: "testapis.extensions.no_partial",
    },
  },
});

export type NoPartialInputMessageInput$Shape = {
  id: NoPartialInputMessage["id"];
  body: NoPartialInputMessage["body"];
};

export const NoPartialInputMessageInput$Ref: InputObjectRef<
  NoPartialInputMessageInput$Shape
> = builder.inputRef<NoPartialInputMessageInput$Shape>(
  "NoPartialInputMessageInput",
).implement({
  fields: (t) => ({
    id: t.field({
      type: "String",
      required: true,
      description: "Required.",
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.field({
      type: "String",
      required: true,
      description: "Required.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.no_partial.NoPartialInputMessage",
      name: "NoPartialInputMessage",
      package: "testapis.extensions.no_partial",
      options: { "[graphql.input_type]": { noPartial: true } },
    },
  },
});
",
    "name": "testapis/extensions/no_partial/no_partial.pb.pothos.ts",
  },
]
`;

exports[`'testapis.field_behavior' > generates files by plugin 'with graphql_type layout' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/field_behavior/comments.proto

/* eslint-disable */

import { FieldBehaviorComentsMessage } from "@testapis/ts-proto/testapis/field_behavior/comments";
import { builder } from "../../builder";
import { FieldBehaviorComentsMessagePost$Ref } from "./FieldBehaviorComentsMessagePost.pothos";

export const FieldBehaviorComentsMessage$Ref = builder.objectRef<
  FieldBehaviorComentsMessage
>("FieldBehaviorComentsMessage");
builder.objectType(FieldBehaviorComentsMessage$Ref, {
  name: "FieldBehaviorComentsMessage",
  fields: (t) => ({
    requiredField: t.field({
      type: FieldBehaviorComentsMessagePost$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.requiredField!;
      },
      extensions: {
        protobufField: {
          name: "required_field",
          typeFullName: "testapis.deprecation.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
    requiredOutputOnlyField: t.field({
      type: FieldBehaviorComentsMessagePost$Ref,
      nullable: false,
      description: "Required. Output only.",
      resolve: (source) => {
        return source.requiredOutputOnlyField!;
      },
      extensions: {
        protobufField: {
          name: "required_output_only_field",
          typeFullName: "testapis.deprecation.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
    outputOnlyRequiredField: t.field({
      type: FieldBehaviorComentsMessagePost$Ref,
      nullable: false,
      description: "Output only. Required.",
      resolve: (source) => {
        return source.outputOnlyRequiredField!;
      },
      extensions: {
        protobufField: {
          name: "output_only_required_field",
          typeFullName: "testapis.deprecation.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
    outputOnlyField: t.expose("outputOnlyField", {
      type: FieldBehaviorComentsMessagePost$Ref,
      nullable: true,
      description: "Output only.",
      extensions: {
        protobufField: {
          name: "output_only_field",
          typeFullName: "testapis.deprecation.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as FieldBehaviorComentsMessage | { $type: string & {}; })
      .$type === "testapis.deprecation.FieldBehaviorComentsMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.FieldBehaviorComentsMessage",
      name: "FieldBehaviorComentsMessage",
      package: "testapis.deprecation",
    },
  },
});
",
    "name": "testapis/field_behavior/FieldBehaviorComentsMessage.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/field_behavior/comments.proto

/* eslint-disable */

import { FieldBehaviorComentsMessage_Post } from "@testapis/ts-proto/testapis/field_behavior/comments";
import { builder } from "../../builder";

export const FieldBehaviorComentsMessagePost$Ref = builder.objectRef<
  FieldBehaviorComentsMessage_Post
>("FieldBehaviorComentsMessagePost");
builder.objectType(FieldBehaviorComentsMessagePost$Ref, {
  name: "FieldBehaviorComentsMessagePost",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as FieldBehaviorComentsMessage_Post | {
      $type: string & {};
    }).$type === "testapis.deprecation.FieldBehaviorComentsMessage.Post";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.FieldBehaviorComentsMessage.Post",
      name: "Post",
      package: "testapis.deprecation",
    },
  },
});
",
    "name": "testapis/field_behavior/FieldBehaviorComentsMessagePost.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/field_behavior/comments.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import {
  FieldBehaviorComentsMessagePostInput$Ref,
  FieldBehaviorComentsMessagePostInput$Shape,
} from "./FieldBehaviorComentsMessagePostInput.pothos";

export type FieldBehaviorComentsMessageInput$Shape = {
  requiredField: FieldBehaviorComentsMessagePostInput$Shape;
  requiredInputOnlyField: FieldBehaviorComentsMessagePostInput$Shape;
  inputOnlyRequiredField: FieldBehaviorComentsMessagePostInput$Shape;
  inputOnlyField?: FieldBehaviorComentsMessagePostInput$Shape | null;
};

export const FieldBehaviorComentsMessageInput$Ref: InputObjectRef<
  FieldBehaviorComentsMessageInput$Shape
> = builder.inputRef<FieldBehaviorComentsMessageInput$Shape>(
  "FieldBehaviorComentsMessageInput",
).implement({
  fields: (t) => ({
    requiredField: t.field({
      type: FieldBehaviorComentsMessagePostInput$Ref,
      required: true,
      description: "Required.",
      extensions: {
        protobufField: {
          name: "required_field",
          typeFullName: "testapis.deprecation.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
    requiredInputOnlyField: t.field({
      type: FieldBehaviorComentsMessagePostInput$Ref,
      required: true,
      description: "Required. Input only.",
      extensions: {
        protobufField: {
          name: "required_input_only_field",
          typeFullName: "testapis.deprecation.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
    inputOnlyRequiredField: t.field({
      type: FieldBehaviorComentsMessagePostInput$Ref,
      required: true,
      description: "Input only. Required.",
      extensions: {
        protobufField: {
          name: "input_only_required_field",
          typeFullName: "testapis.deprecation.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
    inputOnlyField: t.field({
      type: FieldBehaviorComentsMessagePostInput$Ref,
      required: false,
      description: "Input only.",
      extensions: {
        protobufField: {
          name: "input_only_field",
          typeFullName: "testapis.deprecation.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.FieldBehaviorComentsMessage",
      name: "FieldBehaviorComentsMessage",
      package: "testapis.deprecation",
    },
  },
});
",
    "name": "testapis/field_behavior/FieldBehaviorComentsMessageInput.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/field_behavior/comments.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { FieldBehaviorComentsMessage_Post } from "@testapis/ts-proto/testapis/field_behavior/comments";
import { builder } from "../../builder";

export type FieldBehaviorComentsMessagePostInput$Shape = {
  body: FieldBehaviorComentsMessage_Post["body"];
};

export const FieldBehaviorComentsMessagePostInput$Ref: InputObjectRef<
  FieldBehaviorComentsMessagePostInput$Shape
> = builder.inputRef<FieldBehaviorComentsMessagePostInput$Shape>(
  "FieldBehaviorComentsMessagePostInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.FieldBehaviorComentsMessage.Post",
      name: "Post",
      package: "testapis.deprecation",
    },
  },
});
",
    "name": "testapis/field_behavior/FieldBehaviorComentsMessagePostInput.pothos.ts",
  },
]
`;

exports[`'testapis.field_behavior' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/field_behavior/comments.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import {
  FieldBehaviorComentsMessage,
  FieldBehaviorComentsMessage_Post,
} from "@testapis/ts-proto/testapis/field_behavior/comments";
import { builder } from "../../builder";

export const FieldBehaviorComentsMessage$Ref = builder.objectRef<
  FieldBehaviorComentsMessage
>("FieldBehaviorComentsMessage");
builder.objectType(FieldBehaviorComentsMessage$Ref, {
  name: "FieldBehaviorComentsMessage",
  fields: (t) => ({
    requiredField: t.field({
      type: FieldBehaviorComentsMessagePost$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.requiredField!;
      },
      extensions: {
        protobufField: {
          name: "required_field",
          typeFullName: "testapis.deprecation.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
    requiredOutputOnlyField: t.field({
      type: FieldBehaviorComentsMessagePost$Ref,
      nullable: false,
      description: "Required. Output only.",
      resolve: (source) => {
        return source.requiredOutputOnlyField!;
      },
      extensions: {
        protobufField: {
          name: "required_output_only_field",
          typeFullName: "testapis.deprecation.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
    outputOnlyRequiredField: t.field({
      type: FieldBehaviorComentsMessagePost$Ref,
      nullable: false,
      description: "Output only. Required.",
      resolve: (source) => {
        return source.outputOnlyRequiredField!;
      },
      extensions: {
        protobufField: {
          name: "output_only_required_field",
          typeFullName: "testapis.deprecation.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
    outputOnlyField: t.expose("outputOnlyField", {
      type: FieldBehaviorComentsMessagePost$Ref,
      nullable: true,
      description: "Output only.",
      extensions: {
        protobufField: {
          name: "output_only_field",
          typeFullName: "testapis.deprecation.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as FieldBehaviorComentsMessage | { $type: string & {}; })
      .$type === "testapis.deprecation.FieldBehaviorComentsMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.FieldBehaviorComentsMessage",
      name: "FieldBehaviorComentsMessage",
      package: "testapis.deprecation",
    },
  },
});

export const FieldBehaviorComentsMessagePost$Ref = builder.objectRef<
  FieldBehaviorComentsMessage_Post
>("FieldBehaviorComentsMessagePost");
builder.objectType(FieldBehaviorComentsMessagePost$Ref, {
  name: "FieldBehaviorComentsMessagePost",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as FieldBehaviorComentsMessage_Post | {
      $type: string & {};
    }).$type === "testapis.deprecation.FieldBehaviorComentsMessage.Post";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.FieldBehaviorComentsMessage.Post",
      name: "Post",
      package: "testapis.deprecation",
    },
  },
});

export type FieldBehaviorComentsMessageInput$Shape = {
  requiredField: FieldBehaviorComentsMessagePostInput$Shape;
  requiredInputOnlyField: FieldBehaviorComentsMessagePostInput$Shape;
  inputOnlyRequiredField: FieldBehaviorComentsMessagePostInput$Shape;
  inputOnlyField?: FieldBehaviorComentsMessagePostInput$Shape | null;
};

export const FieldBehaviorComentsMessageInput$Ref: InputObjectRef<
  FieldBehaviorComentsMessageInput$Shape
> = builder.inputRef<FieldBehaviorComentsMessageInput$Shape>(
  "FieldBehaviorComentsMessageInput",
).implement({
  fields: (t) => ({
    requiredField: t.field({
      type: FieldBehaviorComentsMessagePostInput$Ref,
      required: true,
      description: "Required.",
      extensions: {
        protobufField: {
          name: "required_field",
          typeFullName: "testapis.deprecation.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
    requiredInputOnlyField: t.field({
      type: FieldBehaviorComentsMessagePostInput$Ref,
      required: true,
      description: "Required. Input only.",
      extensions: {
        protobufField: {
          name: "required_input_only_field",
          typeFullName: "testapis.deprecation.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
    inputOnlyRequiredField: t.field({
      type: FieldBehaviorComentsMessagePostInput$Ref,
      required: true,
      description: "Input only. Required.",
      extensions: {
        protobufField: {
          name: "input_only_required_field",
          typeFullName: "testapis.deprecation.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
    inputOnlyField: t.field({
      type: FieldBehaviorComentsMessagePostInput$Ref,
      required: false,
      description: "Input only.",
      extensions: {
        protobufField: {
          name: "input_only_field",
          typeFullName: "testapis.deprecation.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.FieldBehaviorComentsMessage",
      name: "FieldBehaviorComentsMessage",
      package: "testapis.deprecation",
    },
  },
});

export type FieldBehaviorComentsMessagePostInput$Shape = {
  body: FieldBehaviorComentsMessage_Post["body"];
};

export const FieldBehaviorComentsMessagePostInput$Ref: InputObjectRef<
  FieldBehaviorComentsMessagePostInput$Shape
> = builder.inputRef<FieldBehaviorComentsMessagePostInput$Shape>(
  "FieldBehaviorComentsMessagePostInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.FieldBehaviorComentsMessage.Post",
      name: "Post",
      package: "testapis.deprecation",
    },
  },
});
",
    "name": "testapis/field_behavior/comments.pb.pothos.ts",
  },
]
`;

exports[`'testapis.field_behavior' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/field_behavior/comments.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import {
  FieldBehaviorComentsMessage,
  FieldBehaviorComentsMessage_Post,
} from "@testapis/ts-proto/testapis/field_behavior/comments";
import { builder } from "../../builder";

export const FieldBehaviorComentsMessage$Ref = builder.objectRef<
  FieldBehaviorComentsMessage
>("FieldBehaviorComentsMessage");
builder.objectType(FieldBehaviorComentsMessage$Ref, {
  name: "FieldBehaviorComentsMessage",
  fields: (t) => ({
    requiredField: t.field({
      type: FieldBehaviorComentsMessagePost$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.requiredField!;
      },
      extensions: {
        protobufField: {
          name: "required_field",
          typeFullName: "testapis.deprecation.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
    requiredOutputOnlyField: t.field({
      type: FieldBehaviorComentsMessagePost$Ref,
      nullable: false,
      description: "Required. Output only.",
      resolve: (source) => {
        return source.requiredOutputOnlyField!;
      },
      extensions: {
        protobufField: {
          name: "required_output_only_field",
          typeFullName: "testapis.deprecation.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
    outputOnlyRequiredField: t.field({
      type: FieldBehaviorComentsMessagePost$Ref,
      nullable: false,
      description: "Output only. Required.",
      resolve: (source) => {
        return source.outputOnlyRequiredField!;
      },
      extensions: {
        protobufField: {
          name: "output_only_required_field",
          typeFullName: "testapis.deprecation.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
    outputOnlyField: t.expose("outputOnlyField", {
      type: FieldBehaviorComentsMessagePost$Ref,
      nullable: true,
      description: "Output only.",
      extensions: {
        protobufField: {
          name: "output_only_field",
          typeFullName: "testapis.deprecation.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as FieldBehaviorComentsMessage | { $type: string & {}; })
      .$type === "testapis.deprecation.FieldBehaviorComentsMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.FieldBehaviorComentsMessage",
      name: "FieldBehaviorComentsMessage",
      package: "testapis.deprecation",
    },
  },
});

export const FieldBehaviorComentsMessagePost$Ref = builder.objectRef<
  FieldBehaviorComentsMessage_Post
>("FieldBehaviorComentsMessagePost");
builder.objectType(FieldBehaviorComentsMessagePost$Ref, {
  name: "FieldBehaviorComentsMessagePost",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as FieldBehaviorComentsMessage_Post | {
      $type: string & {};
    }).$type === "testapis.deprecation.FieldBehaviorComentsMessage.Post";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.FieldBehaviorComentsMessage.Post",
      name: "Post",
      package: "testapis.deprecation",
    },
  },
});

export type FieldBehaviorComentsMessageInput$Shape = {
  requiredField: FieldBehaviorComentsMessagePostInput$Shape;
  requiredInputOnlyField: FieldBehaviorComentsMessagePostInput$Shape;
  inputOnlyRequiredField: FieldBehaviorComentsMessagePostInput$Shape;
  inputOnlyField?: FieldBehaviorComentsMessagePostInput$Shape | null;
};

export const FieldBehaviorComentsMessageInput$Ref: InputObjectRef<
  FieldBehaviorComentsMessageInput$Shape
> = builder.inputRef<FieldBehaviorComentsMessageInput$Shape>(
  "FieldBehaviorComentsMessageInput",
).implement({
  fields: (t) => ({
    requiredField: t.field({
      type: FieldBehaviorComentsMessagePostInput$Ref,
      required: true,
      description: "Required.",
      extensions: {
        protobufField: {
          name: "required_field",
          typeFullName: "testapis.deprecation.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
    requiredInputOnlyField: t.field({
      type: FieldBehaviorComentsMessagePostInput$Ref,
      required: true,
      description: "Required. Input only.",
      extensions: {
        protobufField: {
          name: "required_input_only_field",
          typeFullName: "testapis.deprecation.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
    inputOnlyRequiredField: t.field({
      type: FieldBehaviorComentsMessagePostInput$Ref,
      required: true,
      description: "Input only. Required.",
      extensions: {
        protobufField: {
          name: "input_only_required_field",
          typeFullName: "testapis.deprecation.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
    inputOnlyField: t.field({
      type: FieldBehaviorComentsMessagePostInput$Ref,
      required: false,
      description: "Input only.",
      extensions: {
        protobufField: {
          name: "input_only_field",
          typeFullName: "testapis.deprecation.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.FieldBehaviorComentsMessage",
      name: "FieldBehaviorComentsMessage",
      package: "testapis.deprecation",
    },
  },
});

export type FieldBehaviorComentsMessagePartialInput$Shape = {
  requiredField?: FieldBehaviorComentsMessagePostPartialInput$Shape | null;
  requiredInputOnlyField?:
    | FieldBehaviorComentsMessagePostPartialInput$Shape
    | null;
  inputOnlyRequiredField?:
    | FieldBehaviorComentsMessagePostPartialInput$Shape
    | null;
  inputOnlyField?: FieldBehaviorComentsMessagePostPartialInput$Shape | null;
};

export const FieldBehaviorComentsMessagePartialInput$Ref: InputObjectRef<
  FieldBehaviorComentsMessagePartialInput$Shape
> = builder.inputRef<FieldBehaviorComentsMessagePartialInput$Shape>(
  "FieldBehaviorComentsMessagePartialInput",
).implement({
  fields: (t) => ({
    requiredField: t.field({
      type: FieldBehaviorComentsMessagePostPartialInput$Ref,
      required: false,
      description: "Required.",
      extensions: {
        protobufField: {
          name: "required_field",
          typeFullName: "testapis.deprecation.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
    requiredInputOnlyField: t.field({
      type: FieldBehaviorComentsMessagePostPartialInput$Ref,
      required: false,
      description: "Required. Input only.",
      extensions: {
        protobufField: {
          name: "required_input_only_field",
          typeFullName: "testapis.deprecation.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
    inputOnlyRequiredField: t.field({
      type: FieldBehaviorComentsMessagePostPartialInput$Ref,
      required: false,
      description: "Input only. Required.",
      extensions: {
        protobufField: {
          name: "input_only_required_field",
          typeFullName: "testapis.deprecation.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
    inputOnlyField: t.field({
      type: FieldBehaviorComentsMessagePostPartialInput$Ref,
      required: false,
      description: "Input only.",
      extensions: {
        protobufField: {
          name: "input_only_field",
          typeFullName: "testapis.deprecation.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.FieldBehaviorComentsMessage",
      name: "FieldBehaviorComentsMessage",
      package: "testapis.deprecation",
    },
  },
});

export type FieldBehaviorComentsMessagePostInput$Shape = {
  body: FieldBehaviorComentsMessage_Post["body"];
};

export const FieldBehaviorComentsMessagePostInput$Ref: InputObjectRef<
  FieldBehaviorComentsMessagePostInput$Shape
> = builder.inputRef<FieldBehaviorComentsMessagePostInput$Shape>(
  "FieldBehaviorComentsMessagePostInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.FieldBehaviorComentsMessage.Post",
      name: "Post",
      package: "testapis.deprecation",
    },
  },
});

export type FieldBehaviorComentsMessagePostPartialInput$Shape = {
  body?: FieldBehaviorComentsMessage_Post["body"] | null;
};

export const FieldBehaviorComentsMessagePostPartialInput$Ref: InputObjectRef<
  FieldBehaviorComentsMessagePostPartialInput$Shape
> = builder.inputRef<FieldBehaviorComentsMessagePostPartialInput$Shape>(
  "FieldBehaviorComentsMessagePostPartialInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.FieldBehaviorComentsMessage.Post",
      name: "Post",
      package: "testapis.deprecation",
    },
  },
});
",
    "name": "testapis/field_behavior/comments.pb.pothos.ts",
  },
]
`;

exports[`'testapis.field_behavior' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/field_behavior/comments.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import {
  FieldBehaviorComentsMessage,
  FieldBehaviorComentsMessage_Post,
} from "./testapis/field_behavior/comments";

export const FieldBehaviorComentsMessage$Ref = builder.objectRef<
  FieldBehaviorComentsMessage
>("FieldBehaviorComentsMessage");
builder.objectType(FieldBehaviorComentsMessage$Ref, {
  name: "FieldBehaviorComentsMessage",
  fields: (t) => ({
    requiredField: t.field({
      type: FieldBehaviorComentsMessagePost$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.requiredField!;
      },
      extensions: {
        protobufField: {
          name: "required_field",
          typeFullName: "testapis.deprecation.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
    requiredOutputOnlyField: t.field({
      type: FieldBehaviorComentsMessagePost$Ref,
      nullable: false,
      description: "Required. Output only.",
      resolve: (source) => {
        return source.requiredOutputOnlyField!;
      },
      extensions: {
        protobufField: {
          name: "required_output_only_field",
          typeFullName: "testapis.deprecation.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
    outputOnlyRequiredField: t.field({
      type: FieldBehaviorComentsMessagePost$Ref,
      nullable: false,
      description: "Output only. Required.",
      resolve: (source) => {
        return source.outputOnlyRequiredField!;
      },
      extensions: {
        protobufField: {
          name: "output_only_required_field",
          typeFullName: "testapis.deprecation.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
    outputOnlyField: t.expose("outputOnlyField", {
      type: FieldBehaviorComentsMessagePost$Ref,
      nullable: true,
      description: "Output only.",
      extensions: {
        protobufField: {
          name: "output_only_field",
          typeFullName: "testapis.deprecation.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as FieldBehaviorComentsMessage | { $type: string & {}; })
      .$type === "testapis.deprecation.FieldBehaviorComentsMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.FieldBehaviorComentsMessage",
      name: "FieldBehaviorComentsMessage",
      package: "testapis.deprecation",
    },
  },
});

export const FieldBehaviorComentsMessagePost$Ref = builder.objectRef<
  FieldBehaviorComentsMessage_Post
>("FieldBehaviorComentsMessagePost");
builder.objectType(FieldBehaviorComentsMessagePost$Ref, {
  name: "FieldBehaviorComentsMessagePost",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as FieldBehaviorComentsMessage_Post | {
      $type: string & {};
    }).$type === "testapis.deprecation.FieldBehaviorComentsMessage.Post";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.FieldBehaviorComentsMessage.Post",
      name: "Post",
      package: "testapis.deprecation",
    },
  },
});

export type FieldBehaviorComentsMessageInput$Shape = {
  requiredField: FieldBehaviorComentsMessagePostInput$Shape;
  requiredInputOnlyField: FieldBehaviorComentsMessagePostInput$Shape;
  inputOnlyRequiredField: FieldBehaviorComentsMessagePostInput$Shape;
  inputOnlyField?: FieldBehaviorComentsMessagePostInput$Shape | null;
};

export const FieldBehaviorComentsMessageInput$Ref: InputObjectRef<
  FieldBehaviorComentsMessageInput$Shape
> = builder.inputRef<FieldBehaviorComentsMessageInput$Shape>(
  "FieldBehaviorComentsMessageInput",
).implement({
  fields: (t) => ({
    requiredField: t.field({
      type: FieldBehaviorComentsMessagePostInput$Ref,
      required: true,
      description: "Required.",
      extensions: {
        protobufField: {
          name: "required_field",
          typeFullName: "testapis.deprecation.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
    requiredInputOnlyField: t.field({
      type: FieldBehaviorComentsMessagePostInput$Ref,
      required: true,
      description: "Required. Input only.",
      extensions: {
        protobufField: {
          name: "required_input_only_field",
          typeFullName: "testapis.deprecation.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
    inputOnlyRequiredField: t.field({
      type: FieldBehaviorComentsMessagePostInput$Ref,
      required: true,
      description: "Input only. Required.",
      extensions: {
        protobufField: {
          name: "input_only_required_field",
          typeFullName: "testapis.deprecation.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
    inputOnlyField: t.field({
      type: FieldBehaviorComentsMessagePostInput$Ref,
      required: false,
      description: "Input only.",
      extensions: {
        protobufField: {
          name: "input_only_field",
          typeFullName: "testapis.deprecation.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.FieldBehaviorComentsMessage",
      name: "FieldBehaviorComentsMessage",
      package: "testapis.deprecation",
    },
  },
});

export type FieldBehaviorComentsMessagePostInput$Shape = {
  body: FieldBehaviorComentsMessage_Post["body"];
};

export const FieldBehaviorComentsMessagePostInput$Ref: InputObjectRef<
  FieldBehaviorComentsMessagePostInput$Shape
> = builder.inputRef<FieldBehaviorComentsMessagePostInput$Shape>(
  "FieldBehaviorComentsMessagePostInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.FieldBehaviorComentsMessage.Post",
      name: "Post",
      package: "testapis.deprecation",
    },
  },
});
",
    "name": "testapis/field_behavior/comments.pb.pothos.ts",
  },
]
`;

exports[`'testapis.multipkgs' > generates files by plugin 'with graphql_type layout' 1`] = `[]`;

exports[`'testapis.multipkgs' > generates files by plugin 'with import prefix' 1`] = `[]`;

exports[`'testapis.multipkgs' > generates files by plugin 'with partial inputs' 1`] = `[]`;

exports[`'testapis.multipkgs' > generates files by plugin 'without import prefix' 1`] = `[]`;

exports[`'testapis.multipkgs.subpkg1' > generates files by plugin 'with graphql_type layout' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/multipkgs/subpkg1/types.proto

/* eslint-disable */

import { SubpkgMessage } from "@testapis/ts-proto/testapis/multipkgs/subpkg1/types";
import { builder } from "../../../builder";

export const SubpkgMessage$Ref = builder.objectRef<SubpkgMessage>(
  "SubpkgMessage",
);
builder.objectType(SubpkgMessage$Ref, {
  name: "SubpkgMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as SubpkgMessage | { $type: string & {}; }).$type ===
      "testapis.multipkgs.subpkg1.SubpkgMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
      name: "SubpkgMessage",
      package: "testapis.multipkgs.subpkg1",
    },
  },
});
",
    "name": "testapis/multipkgs/subpkg1/SubpkgMessage.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/multipkgs/subpkg1/types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { SubpkgMessage } from "@testapis/ts-proto/testapis/multipkgs/subpkg1/types";
import { builder } from "../../../builder";

export type SubpkgMessageInput$Shape = { body: SubpkgMessage["body"]; };

export const SubpkgMessageInput$Ref: InputObjectRef<SubpkgMessageInput$Shape> =
  builder.inputRef<SubpkgMessageInput$Shape>("SubpkgMessageInput").implement({
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
        name: "SubpkgMessage",
        package: "testapis.multipkgs.subpkg1",
      },
    },
  });
",
    "name": "testapis/multipkgs/subpkg1/SubpkgMessageInput.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/multipkgs/subpkg1/types.proto

/* eslint-disable */

import { builder } from "../../../builder";

export const SubpkgEnum$Ref = builder.enumType("SubpkgEnum", {
  values: {
    FOO: { value: 1, extensions: { protobufEnumValue: { name: "FOO" } } },
    BAR: { value: 2, extensions: { protobufEnumValue: { name: "BAR" } } },
  } as const,
  extensions: {
    protobufEnum: {
      name: "SubpkgEnum",
      fullName: "testapis.multipkgs.subpkg1.SubpkgEnum",
      package: "testapis.multipkgs.subpkg1",
    },
  },
});
",
    "name": "testapis/multipkgs/subpkg1/SubpkgEnum.pothos.ts",
  },
]
`;

exports[`'testapis.multipkgs.subpkg1' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/multipkgs/subpkg1/types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { SubpkgMessage } from "@testapis/ts-proto/testapis/multipkgs/subpkg1/types";
import { builder } from "../../../builder";

export const SubpkgMessage$Ref = builder.objectRef<SubpkgMessage>(
  "SubpkgMessage",
);
builder.objectType(SubpkgMessage$Ref, {
  name: "SubpkgMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as SubpkgMessage | { $type: string & {}; }).$type ===
      "testapis.multipkgs.subpkg1.SubpkgMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
      name: "SubpkgMessage",
      package: "testapis.multipkgs.subpkg1",
    },
  },
});

export type SubpkgMessageInput$Shape = { body: SubpkgMessage["body"]; };

export const SubpkgMessageInput$Ref: InputObjectRef<SubpkgMessageInput$Shape> =
  builder.inputRef<SubpkgMessageInput$Shape>("SubpkgMessageInput").implement({
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
        name: "SubpkgMessage",
        package: "testapis.multipkgs.subpkg1",
      },
    },
  });

export const SubpkgEnum$Ref = builder.enumType("SubpkgEnum", {
  values: {
    FOO: { value: 1, extensions: { protobufEnumValue: { name: "FOO" } } },
    BAR: { value: 2, extensions: { protobufEnumValue: { name: "BAR" } } },
  } as const,
  extensions: {
    protobufEnum: {
      name: "SubpkgEnum",
      fullName: "testapis.multipkgs.subpkg1.SubpkgEnum",
      package: "testapis.multipkgs.subpkg1",
    },
  },
});
",
    "name": "testapis/multipkgs/subpkg1/types.pb.pothos.ts",
  },
]
`;

exports[`'testapis.multipkgs.subpkg1' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/multipkgs/subpkg1/types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { SubpkgMessage } from "@testapis/ts-proto/testapis/multipkgs/subpkg1/types";
import { builder } from "../../../builder";

export const SubpkgMessage$Ref = builder.objectRef<SubpkgMessage>(
  "SubpkgMessage",
);
builder.objectType(SubpkgMessage$Ref, {
  name: "SubpkgMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as SubpkgMessage | { $type: string & {}; }).$type ===
      "testapis.multipkgs.subpkg1.SubpkgMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
      name: "SubpkgMessage",
      package: "testapis.multipkgs.subpkg1",
    },
  },
});

export type SubpkgMessageInput$Shape = { body: SubpkgMessage["body"]; };

export const SubpkgMessageInput$Ref: InputObjectRef<SubpkgMessageInput$Shape> =
  builder.inputRef<SubpkgMessageInput$Shape>("SubpkgMessageInput").implement({
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
        name: "SubpkgMessage",
        package: "testapis.multipkgs.subpkg1",
      },
    },
  });

export type SubpkgMessagePartialInput$Shape = {
  body?: SubpkgMessage["body"] | null;
};

export const SubpkgMessagePartialInput$Ref: InputObjectRef<
  SubpkgMessagePartialInput$Shape
> = builder.inputRef<SubpkgMessagePartialInput$Shape>(
  "SubpkgMessagePartialInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
      name: "SubpkgMessage",
      package: "testapis.multipkgs.subpkg1",
    },
  },
});

export const SubpkgEnum$Ref = builder.enumType("SubpkgEnum", {
  values: {
    FOO: { value: 1, extensions: { protobufEnumValue: { name: "FOO" } } },
    BAR: { value: 2, extensions: { protobufEnumValue: { name: "BAR" } } },
  } as const,
  extensions: {
    protobufEnum: {
      name: "SubpkgEnum",
      fullName: "testapis.multipkgs.subpkg1.SubpkgEnum",
      package: "testapis.multipkgs.subpkg1",
    },
  },
});
",
    "name": "testapis/multipkgs/subpkg1/types.pb.pothos.ts",
  },
]
`;

exports[`'testapis.multipkgs.subpkg1' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/multipkgs/subpkg1/types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../../builder";
import { SubpkgMessage } from "./testapis/multipkgs/subpkg1/types";

export const SubpkgMessage$Ref = builder.objectRef<SubpkgMessage>(
  "SubpkgMessage",
);
builder.objectType(SubpkgMessage$Ref, {
  name: "SubpkgMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as SubpkgMessage | { $type: string & {}; }).$type ===
      "testapis.multipkgs.subpkg1.SubpkgMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
      name: "SubpkgMessage",
      package: "testapis.multipkgs.subpkg1",
    },
  },
});

export type SubpkgMessageInput$Shape = { body: SubpkgMessage["body"]; };

export const SubpkgMessageInput$Ref: InputObjectRef<SubpkgMessageInput$Shape> =
  builder.inputRef<SubpkgMessageInput$Shape>("SubpkgMessageInput").implement({
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
        name: "SubpkgMessage",
        package: "testapis.multipkgs.subpkg1",
      },
    },
  });

export const SubpkgEnum$Ref = builder.enumType("SubpkgEnum", {
  values: {
    FOO: { value: 1, extensions: { protobufEnumValue: { name: "FOO" } } },
    BAR: { value: 2, extensions: { protobufEnumValue: { name: "BAR" } } },
  } as const,
  extensions: {
    protobufEnum: {
      name: "SubpkgEnum",
      fullName: "testapis.multipkgs.subpkg1.SubpkgEnum",
      package: "testapis.multipkgs.subpkg1",
    },
  },
});
",
    "name": "testapis/multipkgs/subpkg1/types.pb.pothos.ts",
  },
]
`;

exports[`'testapis.multipkgs.subpkg2' > generates files by plugin 'with graphql_type layout' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/multipkgs/subpkg2/types.proto

/* eslint-disable */

import { SubpkgEnum } from "@testapis/ts-proto/testapis/multipkgs/subpkg1/types";
import { MessageWithSubpkg } from "@testapis/ts-proto/testapis/multipkgs/subpkg2/types";
import { builder } from "../../../builder";
import { SubpkgEnum$Ref } from "../subpkg1/SubpkgEnum.pothos";
import { SubpkgMessage$Ref } from "../subpkg1/SubpkgMessage.pothos";

export const MessageWithSubpkg$Ref = builder.objectRef<MessageWithSubpkg>(
  "MessageWithSubpkg",
);
builder.objectType(MessageWithSubpkg$Ref, {
  name: "MessageWithSubpkg",
  fields: (t) => ({
    message: t.expose("message", {
      type: SubpkgMessage$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "message",
          typeFullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
        },
      },
    }),
    enum: t.field({
      type: SubpkgEnum$Ref,
      nullable: true,
      resolve: (source) => {
        if (source.enum === SubpkgEnum.SUBPKG_ENUM_UNSPECIFIED) {
          return null;
        }

        return source.enum;
      },
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.multipkgs.subpkg1.SubpkgEnum",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as MessageWithSubpkg | { $type: string & {}; }).$type ===
      "testapis.multipkgs.subpkg1.MessageWithSubpkg";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.multipkgs.subpkg1.MessageWithSubpkg",
      name: "MessageWithSubpkg",
      package: "testapis.multipkgs.subpkg1",
    },
  },
});
",
    "name": "testapis/multipkgs/subpkg2/MessageWithSubpkg.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/multipkgs/subpkg2/types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { MessageWithSubpkg } from "@testapis/ts-proto/testapis/multipkgs/subpkg2/types";
import { builder } from "../../../builder";
import { SubpkgEnum$Ref } from "../subpkg1/SubpkgEnum.pothos";
import {
  SubpkgMessageInput$Ref,
  SubpkgMessageInput$Shape,
} from "../subpkg1/SubpkgMessageInput.pothos";

export type MessageWithSubpkgInput$Shape = {
  message?: SubpkgMessageInput$Shape | null;
  enum?: MessageWithSubpkg["enum"] | null;
};

export const MessageWithSubpkgInput$Ref: InputObjectRef<
  MessageWithSubpkgInput$Shape
> = builder.inputRef<MessageWithSubpkgInput$Shape>("MessageWithSubpkgInput")
  .implement({
    fields: (t) => ({
      message: t.field({
        type: SubpkgMessageInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "message",
            typeFullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
          },
        },
      }),
      enum: t.field({
        type: SubpkgEnum$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "enum",
            typeFullName: "testapis.multipkgs.subpkg1.SubpkgEnum",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.multipkgs.subpkg1.MessageWithSubpkg",
        name: "MessageWithSubpkg",
        package: "testapis.multipkgs.subpkg1",
      },
    },
  });
",
    "name": "testapis/multipkgs/subpkg2/MessageWithSubpkgInput.pothos.ts",
  },
]
`;

exports[`'testapis.multipkgs.subpkg2' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/multipkgs/subpkg2/types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { SubpkgEnum } from "@testapis/ts-proto/testapis/multipkgs/subpkg1/types";
import { MessageWithSubpkg } from "@testapis/ts-proto/testapis/multipkgs/subpkg2/types";
import { builder } from "../../../builder";
import {
  SubpkgEnum$Ref,
  SubpkgMessage$Ref,
  SubpkgMessageInput$Ref,
  SubpkgMessageInput$Shape,
} from "../subpkg1/types.pb.pothos";

export const MessageWithSubpkg$Ref = builder.objectRef<MessageWithSubpkg>(
  "MessageWithSubpkg",
);
builder.objectType(MessageWithSubpkg$Ref, {
  name: "MessageWithSubpkg",
  fields: (t) => ({
    message: t.expose("message", {
      type: SubpkgMessage$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "message",
          typeFullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
        },
      },
    }),
    enum: t.field({
      type: SubpkgEnum$Ref,
      nullable: true,
      resolve: (source) => {
        if (source.enum === SubpkgEnum.SUBPKG_ENUM_UNSPECIFIED) {
          return null;
        }

        return source.enum;
      },
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.multipkgs.subpkg1.SubpkgEnum",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as MessageWithSubpkg | { $type: string & {}; }).$type ===
      "testapis.multipkgs.subpkg1.MessageWithSubpkg";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.multipkgs.subpkg1.MessageWithSubpkg",
      name: "MessageWithSubpkg",
      package: "testapis.multipkgs.subpkg1",
    },
  },
});

export type MessageWithSubpkgInput$Shape = {
  message?: SubpkgMessageInput$Shape | null;
  enum?: MessageWithSubpkg["enum"] | null;
};

export const MessageWithSubpkgInput$Ref: InputObjectRef<
  MessageWithSubpkgInput$Shape
> = builder.inputRef<MessageWithSubpkgInput$Shape>("MessageWithSubpkgInput")
  .implement({
    fields: (t) => ({
      message: t.field({
        type: SubpkgMessageInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "message",
            typeFullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
          },
        },
      }),
      enum: t.field({
        type: SubpkgEnum$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "enum",
            typeFullName: "testapis.multipkgs.subpkg1.SubpkgEnum",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.multipkgs.subpkg1.MessageWithSubpkg",
        name: "MessageWithSubpkg",
        package: "testapis.multipkgs.subpkg1",
      },
    },
  });
",
    "name": "testapis/multipkgs/subpkg2/types.pb.pothos.ts",
  },
]
`;

exports[`'testapis.multipkgs.subpkg2' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/multipkgs/subpkg2/types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { SubpkgEnum } from "@testapis/ts-proto/testapis/multipkgs/subpkg1/types";
import { MessageWithSubpkg } from "@testapis/ts-proto/testapis/multipkgs/subpkg2/types";
import { builder } from "../../../builder";
import {
  SubpkgEnum$Ref,
  SubpkgMessage$Ref,
  SubpkgMessageInput$Ref,
  SubpkgMessageInput$Shape,
  SubpkgMessagePartialInput$Ref,
  SubpkgMessagePartialInput$Shape,
} from "../subpkg1/types.pb.pothos";

export const MessageWithSubpkg$Ref = builder.objectRef<MessageWithSubpkg>(
  "MessageWithSubpkg",
);
builder.objectType(MessageWithSubpkg$Ref, {
  name: "MessageWithSubpkg",
  fields: (t) => ({
    message: t.expose("message", {
      type: SubpkgMessage$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "message",
          typeFullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
        },
      },
    }),
    enum: t.field({
      type: SubpkgEnum$Ref,
      nullable: true,
      resolve: (source) => {
        if (source.enum === SubpkgEnum.SUBPKG_ENUM_UNSPECIFIED) {
          return null;
        }

        return source.enum;
      },
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.multipkgs.subpkg1.SubpkgEnum",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as MessageWithSubpkg | { $type: string & {}; }).$type ===
      "testapis.multipkgs.subpkg1.MessageWithSubpkg";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.multipkgs.subpkg1.MessageWithSubpkg",
      name: "MessageWithSubpkg",
      package: "testapis.multipkgs.subpkg1",
    },
  },
});

export type MessageWithSubpkgInput$Shape = {
  message?: SubpkgMessageInput$Shape | null;
  enum?: MessageWithSubpkg["enum"] | null;
};

export const MessageWithSubpkgInput$Ref: InputObjectRef<
  MessageWithSubpkgInput$Shape
> = builder.inputRef<MessageWithSubpkgInput$Shape>("MessageWithSubpkgInput")
  .implement({
    fields: (t) => ({
      message: t.field({
        type: SubpkgMessageInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "message",
            typeFullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
          },
        },
      }),
      enum: t.field({
        type: SubpkgEnum$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "enum",
            typeFullName: "testapis.multipkgs.subpkg1.SubpkgEnum",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.multipkgs.subpkg1.MessageWithSubpkg",
        name: "MessageWithSubpkg",
        package: "testapis.multipkgs.subpkg1",
      },
    },
  });

export type MessageWithSubpkgPartialInput$Shape = {
  message?: SubpkgMessagePartialInput$Shape | null;
  enum?: MessageWithSubpkg["enum"] | null;
};

export const MessageWithSubpkgPartialInput$Ref: InputObjectRef<
  MessageWithSubpkgPartialInput$Shape
> = builder.inputRef<MessageWithSubpkgPartialInput$Shape>(
  "MessageWithSubpkgPartialInput",
).implement({
  fields: (t) => ({
    message: t.field({
      type: SubpkgMessagePartialInput$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "message",
          typeFullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
        },
      },
    }),
    enum: t.field({
      type: SubpkgEnum$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.multipkgs.subpkg1.SubpkgEnum",
        },
      },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.multipkgs.subpkg1.MessageWithSubpkg",
      name: "MessageWithSubpkg",
      package: "testapis.multipkgs.subpkg1",
    },
  },
});
",
    "name": "testapis/multipkgs/subpkg2/types.pb.pothos.ts",
  },
]
`;

exports[`'testapis.multipkgs.subpkg2' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/multipkgs/subpkg2/types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../../builder";
import {
  SubpkgEnum$Ref,
  SubpkgMessage$Ref,
  SubpkgMessageInput$Ref,
  SubpkgMessageInput$Shape,
} from "../subpkg1/types.pb.pothos";
import { SubpkgEnum } from "./testapis/multipkgs/subpkg1/types";
import { MessageWithSubpkg } from "./testapis/multipkgs/subpkg2/types";

export const MessageWithSubpkg$Ref = builder.objectRef<MessageWithSubpkg>(
  "MessageWithSubpkg",
);
builder.objectType(MessageWithSubpkg$Ref, {
  name: "MessageWithSubpkg",
  fields: (t) => ({
    message: t.expose("message", {
      type: SubpkgMessage$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "message",
          typeFullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
        },
      },
    }),
    enum: t.field({
      type: SubpkgEnum$Ref,
      nullable: true,
      resolve: (source) => {
        if (source.enum === SubpkgEnum.SUBPKG_ENUM_UNSPECIFIED) {
          return null;
        }

        return source.enum;
      },
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.multipkgs.subpkg1.SubpkgEnum",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as MessageWithSubpkg | { $type: string & {}; }).$type ===
      "testapis.multipkgs.subpkg1.MessageWithSubpkg";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.multipkgs.subpkg1.MessageWithSubpkg",
      name: "MessageWithSubpkg",
      package: "testapis.multipkgs.subpkg1",
    },
  },
});

export type MessageWithSubpkgInput$Shape = {
  message?: SubpkgMessageInput$Shape | null;
  enum?: MessageWithSubpkg["enum"] | null;
};

export const MessageWithSubpkgInput$Ref: InputObjectRef<
  MessageWithSubpkgInput$Shape
> = builder.inputRef<MessageWithSubpkgInput$Shape>("MessageWithSubpkgInput")
  .implement({
    fields: (t) => ({
      message: t.field({
        type: SubpkgMessageInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "message",
            typeFullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
          },
        },
      }),
      enum: t.field({
        type: SubpkgEnum$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "enum",
            typeFullName: "testapis.multipkgs.subpkg1.SubpkgEnum",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.multipkgs.subpkg1.MessageWithSubpkg",
        name: "MessageWithSubpkg",
        package: "testapis.multipkgs.subpkg1",
      },
    },
  });
",
    "name": "testapis/multipkgs/subpkg2/types.pb.pothos.ts",
  },
]
`;

exports[`'testapis.nested' > generates files by plugin 'with graphql_type layout' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/nested/nested.proto

/* eslint-disable */

import {
  ParentMessage,
  ParentMessage_NestedEnum,
} from "@testapis/ts-proto/testapis/nested/nested";
import { builder } from "../../builder";
import { ParentMessageNestedEnum$Ref } from "./ParentMessageNestedEnum.pothos";
import { ParentMessageNestedMessage$Ref } from "./ParentMessageNestedMessage.pothos";

export const ParentMessage$Ref = builder.objectRef<ParentMessage>(
  "ParentMessage",
);
builder.objectType(ParentMessage$Ref, {
  name: "ParentMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    nested: t.expose("nested", {
      type: ParentMessageNestedMessage$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "nested",
          typeFullName: "testapis.nested.ParentMessage.NestedMessage",
        },
      },
    }),
    nestedEnum: t.field({
      type: ParentMessageNestedEnum$Ref,
      nullable: true,
      resolve: (source) => {
        if (
          source.nestedEnum === ParentMessage_NestedEnum.NESTED_ENUM_UNSPECIFIED
        ) {
          return null;
        }

        return source.nestedEnum;
      },
      extensions: {
        protobufField: {
          name: "nested_enum",
          typeFullName: "testapis.nested.ParentMessage.NestedEnum",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as ParentMessage | { $type: string & {}; }).$type ===
      "testapis.nested.ParentMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.nested.ParentMessage",
      name: "ParentMessage",
      package: "testapis.nested",
    },
  },
});
",
    "name": "testapis/nested/ParentMessage.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/nested/nested.proto

/* eslint-disable */

import { ParentMessage_NestedMessage } from "@testapis/ts-proto/testapis/nested/nested";
import { builder } from "../../builder";

export const ParentMessageNestedMessage$Ref = builder.objectRef<
  ParentMessage_NestedMessage
>("ParentMessageNestedMessage");
builder.objectType(ParentMessageNestedMessage$Ref, {
  name: "ParentMessageNestedMessage",
  fields: (t) => ({
    nestedBody: t.expose("nestedBody", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: { name: "nested_body", typeFullName: "string" },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as ParentMessage_NestedMessage | { $type: string & {}; })
      .$type === "testapis.nested.ParentMessage.NestedMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.nested.ParentMessage.NestedMessage",
      name: "NestedMessage",
      package: "testapis.nested",
    },
  },
});
",
    "name": "testapis/nested/ParentMessageNestedMessage.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/nested/nested.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { ParentMessage } from "@testapis/ts-proto/testapis/nested/nested";
import { builder } from "../../builder";
import { ParentMessageNestedEnum$Ref } from "./ParentMessageNestedEnum.pothos";
import {
  ParentMessageNestedMessageInput$Ref,
  ParentMessageNestedMessageInput$Shape,
} from "./ParentMessageNestedMessageInput.pothos";

export type ParentMessageInput$Shape = {
  body: ParentMessage["body"];
  nested?: ParentMessageNestedMessageInput$Shape | null;
  nestedEnum?: ParentMessage["nestedEnum"] | null;
};

export const ParentMessageInput$Ref: InputObjectRef<ParentMessageInput$Shape> =
  builder.inputRef<ParentMessageInput$Shape>("ParentMessageInput").implement({
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
      nested: t.field({
        type: ParentMessageNestedMessageInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "nested",
            typeFullName: "testapis.nested.ParentMessage.NestedMessage",
          },
        },
      }),
      nestedEnum: t.field({
        type: ParentMessageNestedEnum$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "nested_enum",
            typeFullName: "testapis.nested.ParentMessage.NestedEnum",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.nested.ParentMessage",
        name: "ParentMessage",
        package: "testapis.nested",
      },
    },
  });
",
    "name": "testapis/nested/ParentMessageInput.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/nested/nested.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { ParentMessage_NestedMessage } from "@testapis/ts-proto/testapis/nested/nested";
import { builder } from "../../builder";

export type ParentMessageNestedMessageInput$Shape = {
  nestedBody: ParentMessage_NestedMessage["nestedBody"];
};

export const ParentMessageNestedMessageInput$Ref: InputObjectRef<
  ParentMessageNestedMessageInput$Shape
> = builder.inputRef<ParentMessageNestedMessageInput$Shape>(
  "ParentMessageNestedMessageInput",
).implement({
  fields: (t) => ({
    nestedBody: t.field({
      type: "String",
      required: true,
      extensions: {
        protobufField: { name: "nested_body", typeFullName: "string" },
      },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.nested.ParentMessage.NestedMessage",
      name: "NestedMessage",
      package: "testapis.nested",
    },
  },
});
",
    "name": "testapis/nested/ParentMessageNestedMessageInput.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/nested/nested.proto

/* eslint-disable */

import { builder } from "../../builder";

export const ParentMessageNestedEnum$Ref = builder.enumType(
  "ParentMessageNestedEnum",
  {
    values: {
      FOO: { value: 1, extensions: { protobufEnumValue: { name: "FOO" } } },
      BAR: { value: 2, extensions: { protobufEnumValue: { name: "BAR" } } },
    } as const,
    extensions: {
      protobufEnum: {
        name: "NestedEnum",
        fullName: "testapis.nested.ParentMessage.NestedEnum",
        package: "testapis.nested",
      },
    },
  },
);
",
    "name": "testapis/nested/ParentMessageNestedEnum.pothos.ts",
  },
]
`;

exports[`'testapis.nested' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/nested/nested.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import {
  ParentMessage,
  ParentMessage_NestedEnum,
  ParentMessage_NestedMessage,
} from "@testapis/ts-proto/testapis/nested/nested";
import { builder } from "../../builder";

export const ParentMessage$Ref = builder.objectRef<ParentMessage>(
  "ParentMessage",
);
builder.objectType(ParentMessage$Ref, {
  name: "ParentMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    nested: t.expose("nested", {
      type: ParentMessageNestedMessage$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "nested",
          typeFullName: "testapis.nested.ParentMessage.NestedMessage",
        },
      },
    }),
    nestedEnum: t.field({
      type: ParentMessageNestedEnum$Ref,
      nullable: true,
      resolve: (source) => {
        if (
          source.nestedEnum === ParentMessage_NestedEnum.NESTED_ENUM_UNSPECIFIED
        ) {
          return null;
        }

        return source.nestedEnum;
      },
      extensions: {
        protobufField: {
          name: "nested_enum",
          typeFullName: "testapis.nested.ParentMessage.NestedEnum",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as ParentMessage | { $type: string & {}; }).$type ===
      "testapis.nested.ParentMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.nested.ParentMessage",
      name: "ParentMessage",
      package: "testapis.nested",
    },
  },
});

export const ParentMessageNestedMessage$Ref = builder.objectRef<
  ParentMessage_NestedMessage
>("ParentMessageNestedMessage");
builder.objectType(ParentMessageNestedMessage$Ref, {
  name: "ParentMessageNestedMessage",
  fields: (t) => ({
    nestedBody: t.expose("nestedBody", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: { name: "nested_body", typeFullName: "string" },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as ParentMessage_NestedMessage | { $type: string & {}; })
      .$type === "testapis.nested.ParentMessage.NestedMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.nested.ParentMessage.NestedMessage",
      name: "NestedMessage",
      package: "testapis.nested",
    },
  },
});

export type ParentMessageInput$Shape = {
  body: ParentMessage["body"];
  nested?: ParentMessageNestedMessageInput$Shape | null;
  nestedEnum?: ParentMessage["nestedEnum"] | null;
};

export const ParentMessageInput$Ref: InputObjectRef<ParentMessageInput$Shape> =
  builder.inputRef<ParentMessageInput$Shape>("ParentMessageInput").implement({
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
      nested: t.field({
        type: ParentMessageNestedMessageInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "nested",
            typeFullName: "testapis.nested.ParentMessage.NestedMessage",
          },
        },
      }),
      nestedEnum: t.field({
        type: ParentMessageNestedEnum$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "nested_enum",
            typeFullName: "testapis.nested.ParentMessage.NestedEnum",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.nested.ParentMessage",
        name: "ParentMessage",
        package: "testapis.nested",
      },
    },
  });

export type ParentMessageNestedMessageInput$Shape = {
  nestedBody: ParentMessage_NestedMessage["nestedBody"];
};

export const ParentMessageNestedMessageInput$Ref: InputObjectRef<
  ParentMessageNestedMessageInput$Shape
> = builder.inputRef<ParentMessageNestedMessageInput$Shape>(
  "ParentMessageNestedMessageInput",
).implement({
  fields: (t) => ({
    nestedBody: t.field({
      type: "String",
      required: true,
      extensions: {
        protobufField: { name: "nested_body", typeFullName: "string" },
      },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.nested.ParentMessage.NestedMessage",
      name: "NestedMessage",
      package: "testapis.nested",
    },
  },
});

export const ParentMessageNestedEnum$Ref = builder.enumType(
  "ParentMessageNestedEnum",
  {
    values: {
      FOO: { value: 1, extensions: { protobufEnumValue: { name: "FOO" } } },
      BAR: { value: 2, extensions: { protobufEnumValue: { name: "BAR" } } },
    } as const,
    extensions: {
      protobufEnum: {
        name: "NestedEnum",
        fullName: "testapis.nested.ParentMessage.NestedEnum",
        package: "testapis.nested",
      },
    },
  },
);
",
    "name": "testapis/nested/nested.pb.pothos.ts",
  },
]
`;

exports[`'testapis.nested' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/nested/nested.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import {
  ParentMessage,
  ParentMessage_NestedEnum,
  ParentMessage_NestedMessage,
} from "@testapis/ts-proto/testapis/nested/nested";
import { builder } from "../../builder";

export const ParentMessage$Ref = builder.objectRef<ParentMessage>(
  "ParentMessage",
);
builder.objectType(ParentMessage$Ref, {
  name: "ParentMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    nested: t.expose("nested", {
      type: ParentMessageNestedMessage$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "nested",
          typeFullName: "testapis.nested.ParentMessage.NestedMessage",
        },
      },
    }),
    nestedEnum: t.field({
      type: ParentMessageNestedEnum$Ref,
      nullable: true,
      resolve: (source) => {
        if (
          source.nestedEnum === ParentMessage_NestedEnum.NESTED_ENUM_UNSPECIFIED
        ) {
          return null;
        }

        return source.nestedEnum;
      },
      extensions: {
        protobufField: {
          name: "nested_enum",
          typeFullName: "testapis.nested.ParentMessage.NestedEnum",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as ParentMessage | { $type: string & {}; }).$type ===
      "testapis.nested.ParentMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.nested.ParentMessage",
      name: "ParentMessage",
      package: "testapis.nested",
    },
  },
});

export const ParentMessageNestedMessage$Ref = builder.objectRef<
  ParentMessage_NestedMessage
>("ParentMessageNestedMessage");
builder.objectType(ParentMessageNestedMessage$Ref, {
  name: "ParentMessageNestedMessage",
  fields: (t) => ({
    nestedBody: t.expose("nestedBody", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: { name: "nested_body", typeFullName: "string" },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as ParentMessage_NestedMessage | { $type: string & {}; })
      .$type === "testapis.nested.ParentMessage.NestedMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.nested.ParentMessage.NestedMessage",
      name: "NestedMessage",
      package: "testapis.nested",
    },
  },
});

export type ParentMessageInput$Shape = {
  body: ParentMessage["body"];
  nested?: ParentMessageNestedMessageInput$Shape | null;
  nestedEnum?: ParentMessage["nestedEnum"] | null;
};

export const ParentMessageInput$Ref: InputObjectRef<ParentMessageInput$Shape> =
  builder.inputRef<ParentMessageInput$Shape>("ParentMessageInput").implement({
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
      nested: t.field({
        type: ParentMessageNestedMessageInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "nested",
            typeFullName: "testapis.nested.ParentMessage.NestedMessage",
          },
        },
      }),
      nestedEnum: t.field({
        type: ParentMessageNestedEnum$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "nested_enum",
            typeFullName: "testapis.nested.ParentMessage.NestedEnum",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.nested.ParentMessage",
        name: "ParentMessage",
        package: "testapis.nested",
      },
    },
  });

export type ParentMessagePartialInput$Shape = {
  body?: ParentMessage["body"] | null;
  nested?: ParentMessageNestedMessagePartialInput$Shape | null;
  nestedEnum?: ParentMessage["nestedEnum"] | null;
};

export const ParentMessagePartialInput$Ref: InputObjectRef<
  ParentMessagePartialInput$Shape
> = builder.inputRef<ParentMessagePartialInput$Shape>(
  "ParentMessagePartialInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    nested: t.field({
      type: ParentMessageNestedMessagePartialInput$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "nested",
          typeFullName: "testapis.nested.ParentMessage.NestedMessage",
        },
      },
    }),
    nestedEnum: t.field({
      type: ParentMessageNestedEnum$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "nested_enum",
          typeFullName: "testapis.nested.ParentMessage.NestedEnum",
        },
      },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.nested.ParentMessage",
      name: "ParentMessage",
      package: "testapis.nested",
    },
  },
});

export type ParentMessageNestedMessageInput$Shape = {
  nestedBody: ParentMessage_NestedMessage["nestedBody"];
};

export const ParentMessageNestedMessageInput$Ref: InputObjectRef<
  ParentMessageNestedMessageInput$Shape
> = builder.inputRef<ParentMessageNestedMessageInput$Shape>(
  "ParentMessageNestedMessageInput",
).implement({
  fields: (t) => ({
    nestedBody: t.field({
      type: "String",
      required: true,
      extensions: {
        protobufField: { name: "nested_body", typeFullName: "string" },
      },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.nested.ParentMessage.NestedMessage",
      name: "NestedMessage",
      package: "testapis.nested",
    },
  },
});

export type ParentMessageNestedMessagePartialInput$Shape = {
  nestedBody?: ParentMessage_NestedMessage["nestedBody"] | null;
};

export const ParentMessageNestedMessagePartialInput$Ref: InputObjectRef<
  ParentMessageNestedMessagePartialInput$Shape
> = builder.inputRef<ParentMessageNestedMessagePartialInput$Shape>(
  "ParentMessageNestedMessagePartialInput",
).implement({
  fields: (t) => ({
    nestedBody: t.field({
      type: "String",
      required: false,
      extensions: {
        protobufField: { name: "nested_body", typeFullName: "string" },
      },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.nested.ParentMessage.NestedMessage",
      name: "NestedMessage",
      package: "testapis.nested",
    },
  },
});

export const ParentMessageNestedEnum$Ref = builder.enumType(
  "ParentMessageNestedEnum",
  {
    values: {
      FOO: { value: 1, extensions: { protobufEnumValue: { name: "FOO" } } },
      BAR: { value: 2, extensions: { protobufEnumValue: { name: "BAR" } } },
    } as const,
    extensions: {
      protobufEnum: {
        name: "NestedEnum",
        fullName: "testapis.nested.ParentMessage.NestedEnum",
        package: "testapis.nested",
      },
    },
  },
);
",
    "name": "testapis/nested/nested.pb.pothos.ts",
  },
]
`;

exports[`'testapis.nested' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/nested/nested.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import {
  ParentMessage,
  ParentMessage_NestedEnum,
  ParentMessage_NestedMessage,
} from "./testapis/nested/nested";

export const ParentMessage$Ref = builder.objectRef<ParentMessage>(
  "ParentMessage",
);
builder.objectType(ParentMessage$Ref, {
  name: "ParentMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    nested: t.expose("nested", {
      type: ParentMessageNestedMessage$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "nested",
          typeFullName: "testapis.nested.ParentMessage.NestedMessage",
        },
      },
    }),
    nestedEnum: t.field({
      type: ParentMessageNestedEnum$Ref,
      nullable: true,
      resolve: (source) => {
        if (
          source.nestedEnum === ParentMessage_NestedEnum.NESTED_ENUM_UNSPECIFIED
        ) {
          return null;
        }

        return source.nestedEnum;
      },
      extensions: {
        protobufField: {
          name: "nested_enum",
          typeFullName: "testapis.nested.ParentMessage.NestedEnum",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as ParentMessage | { $type: string & {}; }).$type ===
      "testapis.nested.ParentMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.nested.ParentMessage",
      name: "ParentMessage",
      package: "testapis.nested",
    },
  },
});

export const ParentMessageNestedMessage$Ref = builder.objectRef<
  ParentMessage_NestedMessage
>("ParentMessageNestedMessage");
builder.objectType(ParentMessageNestedMessage$Ref, {
  name: "ParentMessageNestedMessage",
  fields: (t) => ({
    nestedBody: t.expose("nestedBody", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: { name: "nested_body", typeFullName: "string" },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as ParentMessage_NestedMessage | { $type: string & {}; })
      .$type === "testapis.nested.ParentMessage.NestedMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.nested.ParentMessage.NestedMessage",
      name: "NestedMessage",
      package: "testapis.nested",
    },
  },
});

export type ParentMessageInput$Shape = {
  body: ParentMessage["body"];
  nested?: ParentMessageNestedMessageInput$Shape | null;
  nestedEnum?: ParentMessage["nestedEnum"] | null;
};

export const ParentMessageInput$Ref: InputObjectRef<ParentMessageInput$Shape> =
  builder.inputRef<ParentMessageInput$Shape>("ParentMessageInput").implement({
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
      nested: t.field({
        type: ParentMessageNestedMessageInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "nested",
            typeFullName: "testapis.nested.ParentMessage.NestedMessage",
          },
        },
      }),
      nestedEnum: t.field({
        type: ParentMessageNestedEnum$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "nested_enum",
            typeFullName: "testapis.nested.ParentMessage.NestedEnum",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.nested.ParentMessage",
        name: "ParentMessage",
        package: "testapis.nested",
      },
    },
  });

export type ParentMessageNestedMessageInput$Shape = {
  nestedBody: ParentMessage_NestedMessage["nestedBody"];
};

export const ParentMessageNestedMessageInput$Ref: InputObjectRef<
  ParentMessageNestedMessageInput$Shape
> = builder.inputRef<ParentMessageNestedMessageInput$Shape>(
  "ParentMessageNestedMessageInput",
).implement({
  fields: (t) => ({
    nestedBody: t.field({
      type: "String",
      required: true,
      extensions: {
        protobufField: { name: "nested_body", typeFullName: "string" },
      },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.nested.ParentMessage.NestedMessage",
      name: "NestedMessage",
      package: "testapis.nested",
    },
  },
});

export const ParentMessageNestedEnum$Ref = builder.enumType(
  "ParentMessageNestedEnum",
  {
    values: {
      FOO: { value: 1, extensions: { protobufEnumValue: { name: "FOO" } } },
      BAR: { value: 2, extensions: { protobufEnumValue: { name: "BAR" } } },
    } as const,
    extensions: {
      protobufEnum: {
        name: "NestedEnum",
        fullName: "testapis.nested.ParentMessage.NestedEnum",
        package: "testapis.nested",
      },
    },
  },
);
",
    "name": "testapis/nested/nested.pb.pothos.ts",
  },
]
`;

exports[`'testapis.oneof' > generates files by plugin 'with graphql_type layout' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/oneof/oneof.proto

/* eslint-disable */

import { OneofParent } from "@testapis/ts-proto/testapis/oneof/oneof";
import { builder } from "../../builder";

export const OneofParent$Ref = builder.objectRef<OneofParent>("OneofParent");
builder.objectType(OneofParent$Ref, {
  name: "OneofParent",
  fields: (t) => ({
    normalField: t.expose("normalField", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: { name: "normal_field", typeFullName: "string" },
      },
    }),
    requiredOneofMembers: t.field({
      type: OneofParentRequiredOneofMembers$Ref,
      nullable: false,
      description: "Required. disallow not_set.",
      resolve: (source) => {
        const value = source.requiredMessage1 ?? source.requiredMessage2;
        if (value == null) {
          throw new Error("requiredOneofMembers should not be null");
        }
        return value;
      },
      extensions: { protobufField: { name: "required_oneof_members" } },
    }),
    optionalOneofMembers: t.field({
      type: OneofParentOptionalOneofMembers$Ref,
      nullable: true,
      resolve: (source) => {
        const value = source.optoinalMessage1 ?? source.optoinalMessage2;
        if (value == null) {
          return null;
        }
        return value;
      },
      extensions: { protobufField: { name: "optional_oneof_members" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as OneofParent | { $type: string & {}; }).$type ===
      "testapis.oneof.OneofParent";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.oneof.OneofParent",
      name: "OneofParent",
      package: "testapis.oneof",
    },
  },
});
",
    "name": "testapis/oneof/OneofParent.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/oneof/oneof.proto

/* eslint-disable */

import { OneofMemberMessage1 } from "@testapis/ts-proto/testapis/oneof/oneof";
import { builder } from "../../builder";

export const OneofMemberMessage1$Ref = builder.objectRef<OneofMemberMessage1>(
  "OneofMemberMessage1",
);
builder.objectType(OneofMemberMessage1$Ref, {
  name: "OneofMemberMessage1",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as OneofMemberMessage1 | { $type: string & {}; }).$type ===
      "testapis.oneof.OneofMemberMessage1";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.oneof.OneofMemberMessage1",
      name: "OneofMemberMessage1",
      package: "testapis.oneof",
    },
  },
});
",
    "name": "testapis/oneof/OneofMemberMessage1.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/oneof/oneof.proto

/* eslint-disable */

import { OneofMemberMessage2 } from "@testapis/ts-proto/testapis/oneof/oneof";
import { builder } from "../../builder";

export const OneofMemberMessage2$Ref = builder.objectRef<OneofMemberMessage2>(
  "OneofMemberMessage2",
);
builder.objectType(OneofMemberMessage2$Ref, {
  name: "OneofMemberMessage2",
  fields: (t) => ({
    imageUrl: t.expose("imageUrl", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: { name: "image_url", typeFullName: "string" },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as OneofMemberMessage2 | { $type: string & {}; }).$type ===
      "testapis.oneof.OneofMemberMessage2";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.oneof.OneofMemberMessage2",
      name: "OneofMemberMessage2",
      package: "testapis.oneof",
    },
  },
});
",
    "name": "testapis/oneof/OneofMemberMessage2.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/oneof/oneof.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { OneofParent } from "@testapis/ts-proto/testapis/oneof/oneof";
import { builder } from "../../builder";
import {
  OneofMemberMessage1Input$Ref,
  OneofMemberMessage1Input$Shape,
} from "./OneofMemberMessage1Input.pothos";
import {
  OneofMemberMessage2Input$Ref,
  OneofMemberMessage2Input$Shape,
} from "./OneofMemberMessage2Input.pothos";

export type OneofParentInput$Shape = {
  normalField: OneofParent["normalField"];
  requiredMessage1?: OneofMemberMessage1Input$Shape | null;
  requiredMessage2?: OneofMemberMessage2Input$Shape | null;
  optoinalMessage1?: OneofMemberMessage1Input$Shape | null;
  optoinalMessage2?: OneofMemberMessage2Input$Shape | null;
};

export const OneofParentInput$Ref: InputObjectRef<OneofParentInput$Shape> =
  builder.inputRef<OneofParentInput$Shape>("OneofParentInput").implement({
    fields: (t) => ({
      normalField: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: { name: "normal_field", typeFullName: "string" },
        },
      }),
      requiredMessage1: t.field({
        type: OneofMemberMessage1Input$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "required_message1",
            typeFullName: "testapis.oneof.OneofMemberMessage1",
          },
        },
      }),
      requiredMessage2: t.field({
        type: OneofMemberMessage2Input$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "required_message2",
            typeFullName: "testapis.oneof.OneofMemberMessage2",
          },
        },
      }),
      optoinalMessage1: t.field({
        type: OneofMemberMessage1Input$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "optoinal_message1",
            typeFullName: "testapis.oneof.OneofMemberMessage1",
          },
        },
      }),
      optoinalMessage2: t.field({
        type: OneofMemberMessage2Input$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "optoinal_message2",
            typeFullName: "testapis.oneof.OneofMemberMessage2",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.oneof.OneofParent",
        name: "OneofParent",
        package: "testapis.oneof",
      },
    },
  });
",
    "name": "testapis/oneof/OneofParentInput.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/oneof/oneof.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { OneofMemberMessage1 } from "@testapis/ts-proto/testapis/oneof/oneof";
import { builder } from "../../builder";

export type OneofMemberMessage1Input$Shape = {
  body: OneofMemberMessage1["body"];
};

export const OneofMemberMessage1Input$Ref: InputObjectRef<
  OneofMemberMessage1Input$Shape
> = builder.inputRef<OneofMemberMessage1Input$Shape>("OneofMemberMessage1Input")
  .implement({
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.oneof.OneofMemberMessage1",
        name: "OneofMemberMessage1",
        package: "testapis.oneof",
      },
    },
  });
",
    "name": "testapis/oneof/OneofMemberMessage1Input.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/oneof/oneof.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { OneofMemberMessage2 } from "@testapis/ts-proto/testapis/oneof/oneof";
import { builder } from "../../builder";

export type OneofMemberMessage2Input$Shape = {
  imageUrl: OneofMemberMessage2["imageUrl"];
};

export const OneofMemberMessage2Input$Ref: InputObjectRef<
  OneofMemberMessage2Input$Shape
> = builder.inputRef<OneofMemberMessage2Input$Shape>("OneofMemberMessage2Input")
  .implement({
    fields: (t) => ({
      imageUrl: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: { name: "image_url", typeFullName: "string" },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.oneof.OneofMemberMessage2",
        name: "OneofMemberMessage2",
        package: "testapis.oneof",
      },
    },
  });
",
    "name": "testapis/oneof/OneofMemberMessage2Input.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/oneof/oneof.proto

/* eslint-disable */

import { builder } from "../../builder";

export const OneofParentRequiredOneofMembers$Ref = builder.unionType(
  "OneofParentRequiredOneofMembers",
  {
    types: [OneofMemberMessage1$Ref, OneofMemberMessage2$Ref],
    description: "Required. disallow not_set.",
    extensions: {
      protobufOneof: {
        fullName: "testapis.oneof.OneofParent.required_oneof_members",
        name: "required_oneof_members",
        messageName: "OneofParent",
        package: "testapis.oneof",
        fields: [{
          name: "required_message1",
          type: "testapis.oneof.OneofMemberMessage1",
        }, {
          name: "required_message2",
          type: "testapis.oneof.OneofMemberMessage2",
        }],
      },
    },
  },
);
",
    "name": "testapis/oneof/OneofParentRequiredOneofMembers.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/oneof/oneof.proto

/* eslint-disable */

import { builder } from "../../builder";

export const OneofParentOptionalOneofMembers$Ref = builder.unionType(
  "OneofParentOptionalOneofMembers",
  {
    types: [OneofMemberMessage1$Ref, OneofMemberMessage2$Ref],
    extensions: {
      protobufOneof: {
        fullName: "testapis.oneof.OneofParent.optional_oneof_members",
        name: "optional_oneof_members",
        messageName: "OneofParent",
        package: "testapis.oneof",
        fields: [{
          name: "optoinal_message1",
          type: "testapis.oneof.OneofMemberMessage1",
        }, {
          name: "optoinal_message2",
          type: "testapis.oneof.OneofMemberMessage2",
        }],
      },
    },
  },
);
",
    "name": "testapis/oneof/OneofParentOptionalOneofMembers.pothos.ts",
  },
]
`;

exports[`'testapis.oneof' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/oneof/oneof.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import {
  OneofMemberMessage1,
  OneofMemberMessage2,
  OneofParent,
} from "@testapis/ts-proto/testapis/oneof/oneof";
import { builder } from "../../builder";

export const OneofParent$Ref = builder.objectRef<OneofParent>("OneofParent");
builder.objectType(OneofParent$Ref, {
  name: "OneofParent",
  fields: (t) => ({
    normalField: t.expose("normalField", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: { name: "normal_field", typeFullName: "string" },
      },
    }),
    requiredOneofMembers: t.field({
      type: OneofParentRequiredOneofMembers$Ref,
      nullable: false,
      description: "Required. disallow not_set.",
      resolve: (source) => {
        const value = source.requiredMessage1 ?? source.requiredMessage2;
        if (value == null) {
          throw new Error("requiredOneofMembers should not be null");
        }
        return value;
      },
      extensions: { protobufField: { name: "required_oneof_members" } },
    }),
    optionalOneofMembers: t.field({
      type: OneofParentOptionalOneofMembers$Ref,
      nullable: true,
      resolve: (source) => {
        const value = source.optoinalMessage1 ?? source.optoinalMessage2;
        if (value == null) {
          return null;
        }
        return value;
      },
      extensions: { protobufField: { name: "optional_oneof_members" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as OneofParent | { $type: string & {}; }).$type ===
      "testapis.oneof.OneofParent";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.oneof.OneofParent",
      name: "OneofParent",
      package: "testapis.oneof",
    },
  },
});

export const OneofMemberMessage1$Ref = builder.objectRef<OneofMemberMessage1>(
  "OneofMemberMessage1",
);
builder.objectType(OneofMemberMessage1$Ref, {
  name: "OneofMemberMessage1",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as OneofMemberMessage1 | { $type: string & {}; }).$type ===
      "testapis.oneof.OneofMemberMessage1";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.oneof.OneofMemberMessage1",
      name: "OneofMemberMessage1",
      package: "testapis.oneof",
    },
  },
});

export const OneofMemberMessage2$Ref = builder.objectRef<OneofMemberMessage2>(
  "OneofMemberMessage2",
);
builder.objectType(OneofMemberMessage2$Ref, {
  name: "OneofMemberMessage2",
  fields: (t) => ({
    imageUrl: t.expose("imageUrl", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: { name: "image_url", typeFullName: "string" },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as OneofMemberMessage2 | { $type: string & {}; }).$type ===
      "testapis.oneof.OneofMemberMessage2";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.oneof.OneofMemberMessage2",
      name: "OneofMemberMessage2",
      package: "testapis.oneof",
    },
  },
});

export type OneofParentInput$Shape = {
  normalField: OneofParent["normalField"];
  requiredMessage1?: OneofMemberMessage1Input$Shape | null;
  requiredMessage2?: OneofMemberMessage2Input$Shape | null;
  optoinalMessage1?: OneofMemberMessage1Input$Shape | null;
  optoinalMessage2?: OneofMemberMessage2Input$Shape | null;
};

export const OneofParentInput$Ref: InputObjectRef<OneofParentInput$Shape> =
  builder.inputRef<OneofParentInput$Shape>("OneofParentInput").implement({
    fields: (t) => ({
      normalField: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: { name: "normal_field", typeFullName: "string" },
        },
      }),
      requiredMessage1: t.field({
        type: OneofMemberMessage1Input$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "required_message1",
            typeFullName: "testapis.oneof.OneofMemberMessage1",
          },
        },
      }),
      requiredMessage2: t.field({
        type: OneofMemberMessage2Input$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "required_message2",
            typeFullName: "testapis.oneof.OneofMemberMessage2",
          },
        },
      }),
      optoinalMessage1: t.field({
        type: OneofMemberMessage1Input$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "optoinal_message1",
            typeFullName: "testapis.oneof.OneofMemberMessage1",
          },
        },
      }),
      optoinalMessage2: t.field({
        type: OneofMemberMessage2Input$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "optoinal_message2",
            typeFullName: "testapis.oneof.OneofMemberMessage2",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.oneof.OneofParent",
        name: "OneofParent",
        package: "testapis.oneof",
      },
    },
  });

export type OneofMemberMessage1Input$Shape = {
  body: OneofMemberMessage1["body"];
};

export const OneofMemberMessage1Input$Ref: InputObjectRef<
  OneofMemberMessage1Input$Shape
> = builder.inputRef<OneofMemberMessage1Input$Shape>("OneofMemberMessage1Input")
  .implement({
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.oneof.OneofMemberMessage1",
        name: "OneofMemberMessage1",
        package: "testapis.oneof",
      },
    },
  });

export type OneofMemberMessage2Input$Shape = {
  imageUrl: OneofMemberMessage2["imageUrl"];
};

export const OneofMemberMessage2Input$Ref: InputObjectRef<
  OneofMemberMessage2Input$Shape
> = builder.inputRef<OneofMemberMessage2Input$Shape>("OneofMemberMessage2Input")
  .implement({
    fields: (t) => ({
      imageUrl: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: { name: "image_url", typeFullName: "string" },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.oneof.OneofMemberMessage2",
        name: "OneofMemberMessage2",
        package: "testapis.oneof",
      },
    },
  });

export const OneofParentRequiredOneofMembers$Ref = builder.unionType(
  "OneofParentRequiredOneofMembers",
  {
    types: [OneofMemberMessage1$Ref, OneofMemberMessage2$Ref],
    description: "Required. disallow not_set.",
    extensions: {
      protobufOneof: {
        fullName: "testapis.oneof.OneofParent.required_oneof_members",
        name: "required_oneof_members",
        messageName: "OneofParent",
        package: "testapis.oneof",
        fields: [{
          name: "required_message1",
          type: "testapis.oneof.OneofMemberMessage1",
        }, {
          name: "required_message2",
          type: "testapis.oneof.OneofMemberMessage2",
        }],
      },
    },
  },
);

export const OneofParentOptionalOneofMembers$Ref = builder.unionType(
  "OneofParentOptionalOneofMembers",
  {
    types: [OneofMemberMessage1$Ref, OneofMemberMessage2$Ref],
    extensions: {
      protobufOneof: {
        fullName: "testapis.oneof.OneofParent.optional_oneof_members",
        name: "optional_oneof_members",
        messageName: "OneofParent",
        package: "testapis.oneof",
        fields: [{
          name: "optoinal_message1",
          type: "testapis.oneof.OneofMemberMessage1",
        }, {
          name: "optoinal_message2",
          type: "testapis.oneof.OneofMemberMessage2",
        }],
      },
    },
  },
);
",
    "name": "testapis/oneof/oneof.pb.pothos.ts",
  },
]
`;

exports[`'testapis.oneof' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/oneof/oneof.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import {
  OneofMemberMessage1,
  OneofMemberMessage2,
  OneofParent,
} from "@testapis/ts-proto/testapis/oneof/oneof";
import { builder } from "../../builder";

export const OneofParent$Ref = builder.objectRef<OneofParent>("OneofParent");
builder.objectType(OneofParent$Ref, {
  name: "OneofParent",
  fields: (t) => ({
    normalField: t.expose("normalField", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: { name: "normal_field", typeFullName: "string" },
      },
    }),
    requiredOneofMembers: t.field({
      type: OneofParentRequiredOneofMembers$Ref,
      nullable: false,
      description: "Required. disallow not_set.",
      resolve: (source) => {
        const value = source.requiredMessage1 ?? source.requiredMessage2;
        if (value == null) {
          throw new Error("requiredOneofMembers should not be null");
        }
        return value;
      },
      extensions: { protobufField: { name: "required_oneof_members" } },
    }),
    optionalOneofMembers: t.field({
      type: OneofParentOptionalOneofMembers$Ref,
      nullable: true,
      resolve: (source) => {
        const value = source.optoinalMessage1 ?? source.optoinalMessage2;
        if (value == null) {
          return null;
        }
        return value;
      },
      extensions: { protobufField: { name: "optional_oneof_members" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as OneofParent | { $type: string & {}; }).$type ===
      "testapis.oneof.OneofParent";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.oneof.OneofParent",
      name: "OneofParent",
      package: "testapis.oneof",
    },
  },
});

export const OneofMemberMessage1$Ref = builder.objectRef<OneofMemberMessage1>(
  "OneofMemberMessage1",
);
builder.objectType(OneofMemberMessage1$Ref, {
  name: "OneofMemberMessage1",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as OneofMemberMessage1 | { $type: string & {}; }).$type ===
      "testapis.oneof.OneofMemberMessage1";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.oneof.OneofMemberMessage1",
      name: "OneofMemberMessage1",
      package: "testapis.oneof",
    },
  },
});

export const OneofMemberMessage2$Ref = builder.objectRef<OneofMemberMessage2>(
  "OneofMemberMessage2",
);
builder.objectType(OneofMemberMessage2$Ref, {
  name: "OneofMemberMessage2",
  fields: (t) => ({
    imageUrl: t.expose("imageUrl", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: { name: "image_url", typeFullName: "string" },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as OneofMemberMessage2 | { $type: string & {}; }).$type ===
      "testapis.oneof.OneofMemberMessage2";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.oneof.OneofMemberMessage2",
      name: "OneofMemberMessage2",
      package: "testapis.oneof",
    },
  },
});

export type OneofParentInput$Shape = {
  normalField: OneofParent["normalField"];
  requiredMessage1?: OneofMemberMessage1Input$Shape | null;
  requiredMessage2?: OneofMemberMessage2Input$Shape | null;
  optoinalMessage1?: OneofMemberMessage1Input$Shape | null;
  optoinalMessage2?: OneofMemberMessage2Input$Shape | null;
};

export const OneofParentInput$Ref: InputObjectRef<OneofParentInput$Shape> =
  builder.inputRef<OneofParentInput$Shape>("OneofParentInput").implement({
    fields: (t) => ({
      normalField: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: { name: "normal_field", typeFullName: "string" },
        },
      }),
      requiredMessage1: t.field({
        type: OneofMemberMessage1Input$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "required_message1",
            typeFullName: "testapis.oneof.OneofMemberMessage1",
          },
        },
      }),
      requiredMessage2: t.field({
        type: OneofMemberMessage2Input$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "required_message2",
            typeFullName: "testapis.oneof.OneofMemberMessage2",
          },
        },
      }),
      optoinalMessage1: t.field({
        type: OneofMemberMessage1Input$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "optoinal_message1",
            typeFullName: "testapis.oneof.OneofMemberMessage1",
          },
        },
      }),
      optoinalMessage2: t.field({
        type: OneofMemberMessage2Input$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "optoinal_message2",
            typeFullName: "testapis.oneof.OneofMemberMessage2",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.oneof.OneofParent",
        name: "OneofParent",
        package: "testapis.oneof",
      },
    },
  });

export type OneofParentPartialInput$Shape = {
  normalField?: OneofParent["normalField"] | null;
  requiredMessage1?: OneofMemberMessage1PartialInput$Shape | null;
  requiredMessage2?: OneofMemberMessage2PartialInput$Shape | null;
  optoinalMessage1?: OneofMemberMessage1PartialInput$Shape | null;
  optoinalMessage2?: OneofMemberMessage2PartialInput$Shape | null;
};

export const OneofParentPartialInput$Ref: InputObjectRef<
  OneofParentPartialInput$Shape
> = builder.inputRef<OneofParentPartialInput$Shape>("OneofParentPartialInput")
  .implement({
    fields: (t) => ({
      normalField: t.field({
        type: "String",
        required: false,
        extensions: {
          protobufField: { name: "normal_field", typeFullName: "string" },
        },
      }),
      requiredMessage1: t.field({
        type: OneofMemberMessage1PartialInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "required_message1",
            typeFullName: "testapis.oneof.OneofMemberMessage1",
          },
        },
      }),
      requiredMessage2: t.field({
        type: OneofMemberMessage2PartialInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "required_message2",
            typeFullName: "testapis.oneof.OneofMemberMessage2",
          },
        },
      }),
      optoinalMessage1: t.field({
        type: OneofMemberMessage1PartialInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "optoinal_message1",
            typeFullName: "testapis.oneof.OneofMemberMessage1",
          },
        },
      }),
      optoinalMessage2: t.field({
        type: OneofMemberMessage2PartialInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "optoinal_message2",
            typeFullName: "testapis.oneof.OneofMemberMessage2",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.oneof.OneofParent",
        name: "OneofParent",
        package: "testapis.oneof",
      },
    },
  });

export type OneofMemberMessage1Input$Shape = {
  body: OneofMemberMessage1["body"];
};

export const OneofMemberMessage1Input$Ref: InputObjectRef<
  OneofMemberMessage1Input$Shape
> = builder.inputRef<OneofMemberMessage1Input$Shape>("OneofMemberMessage1Input")
  .implement({
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.oneof.OneofMemberMessage1",
        name: "OneofMemberMessage1",
        package: "testapis.oneof",
      },
    },
  });

export type OneofMemberMessage1PartialInput$Shape = {
  body?: OneofMemberMessage1["body"] | null;
};

export const OneofMemberMessage1PartialInput$Ref: InputObjectRef<
  OneofMemberMessage1PartialInput$Shape
> = builder.inputRef<OneofMemberMessage1PartialInput$Shape>(
  "OneofMemberMessage1PartialInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.oneof.OneofMemberMessage1",
      name: "OneofMemberMessage1",
      package: "testapis.oneof",
    },
  },
});

export type OneofMemberMessage2Input$Shape = {
  imageUrl: OneofMemberMessage2["imageUrl"];
};

export const OneofMemberMessage2Input$Ref: InputObjectRef<
  OneofMemberMessage2Input$Shape
> = builder.inputRef<OneofMemberMessage2Input$Shape>("OneofMemberMessage2Input")
  .implement({
    fields: (t) => ({
      imageUrl: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: { name: "image_url", typeFullName: "string" },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.oneof.OneofMemberMessage2",
        name: "OneofMemberMessage2",
        package: "testapis.oneof",
      },
    },
  });

export type OneofMemberMessage2PartialInput$Shape = {
  imageUrl?: OneofMemberMessage2["imageUrl"] | null;
};

export const OneofMemberMessage2PartialInput$Ref: InputObjectRef<
  OneofMemberMessage2PartialInput$Shape
> = builder.inputRef<OneofMemberMessage2PartialInput$Shape>(
  "OneofMemberMessage2PartialInput",
).implement({
  fields: (t) => ({
    imageUrl: t.field({
      type: "String",
      required: false,
      extensions: {
        protobufField: { name: "image_url", typeFullName: "string" },
      },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.oneof.OneofMemberMessage2",
      name: "OneofMemberMessage2",
      package: "testapis.oneof",
    },
  },
});

export const OneofParentRequiredOneofMembers$Ref = builder.unionType(
  "OneofParentRequiredOneofMembers",
  {
    types: [OneofMemberMessage1$Ref, OneofMemberMessage2$Ref],
    description: "Required. disallow not_set.",
    extensions: {
      protobufOneof: {
        fullName: "testapis.oneof.OneofParent.required_oneof_members",
        name: "required_oneof_members",
        messageName: "OneofParent",
        package: "testapis.oneof",
        fields: [{
          name: "required_message1",
          type: "testapis.oneof.OneofMemberMessage1",
        }, {
          name: "required_message2",
          type: "testapis.oneof.OneofMemberMessage2",
        }],
      },
    },
  },
);

export const OneofParentOptionalOneofMembers$Ref = builder.unionType(
  "OneofParentOptionalOneofMembers",
  {
    types: [OneofMemberMessage1$Ref, OneofMemberMessage2$Ref],
    extensions: {
      protobufOneof: {
        fullName: "testapis.oneof.OneofParent.optional_oneof_members",
        name: "optional_oneof_members",
        messageName: "OneofParent",
        package: "testapis.oneof",
        fields: [{
          name: "optoinal_message1",
          type: "testapis.oneof.OneofMemberMessage1",
        }, {
          name: "optoinal_message2",
          type: "testapis.oneof.OneofMemberMessage2",
        }],
      },
    },
  },
);
",
    "name": "testapis/oneof/oneof.pb.pothos.ts",
  },
]
`;

exports[`'testapis.oneof' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/oneof/oneof.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import {
  OneofMemberMessage1,
  OneofMemberMessage2,
  OneofParent,
} from "./testapis/oneof/oneof";

export const OneofParent$Ref = builder.objectRef<OneofParent>("OneofParent");
builder.objectType(OneofParent$Ref, {
  name: "OneofParent",
  fields: (t) => ({
    normalField: t.expose("normalField", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: { name: "normal_field", typeFullName: "string" },
      },
    }),
    requiredOneofMembers: t.field({
      type: OneofParentRequiredOneofMembers$Ref,
      nullable: false,
      description: "Required. disallow not_set.",
      resolve: (source) => {
        const value = source.requiredMessage1 ?? source.requiredMessage2;
        if (value == null) {
          throw new Error("requiredOneofMembers should not be null");
        }
        return value;
      },
      extensions: { protobufField: { name: "required_oneof_members" } },
    }),
    optionalOneofMembers: t.field({
      type: OneofParentOptionalOneofMembers$Ref,
      nullable: true,
      resolve: (source) => {
        const value = source.optoinalMessage1 ?? source.optoinalMessage2;
        if (value == null) {
          return null;
        }
        return value;
      },
      extensions: { protobufField: { name: "optional_oneof_members" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as OneofParent | { $type: string & {}; }).$type ===
      "testapis.oneof.OneofParent";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.oneof.OneofParent",
      name: "OneofParent",
      package: "testapis.oneof",
    },
  },
});

export const OneofMemberMessage1$Ref = builder.objectRef<OneofMemberMessage1>(
  "OneofMemberMessage1",
);
builder.objectType(OneofMemberMessage1$Ref, {
  name: "OneofMemberMessage1",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as OneofMemberMessage1 | { $type: string & {}; }).$type ===
      "testapis.oneof.OneofMemberMessage1";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.oneof.OneofMemberMessage1",
      name: "OneofMemberMessage1",
      package: "testapis.oneof",
    },
  },
});

export const OneofMemberMessage2$Ref = builder.objectRef<OneofMemberMessage2>(
  "OneofMemberMessage2",
);
builder.objectType(OneofMemberMessage2$Ref, {
  name: "OneofMemberMessage2",
  fields: (t) => ({
    imageUrl: t.expose("imageUrl", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: { name: "image_url", typeFullName: "string" },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as OneofMemberMessage2 | { $type: string & {}; }).$type ===
      "testapis.oneof.OneofMemberMessage2";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.oneof.OneofMemberMessage2",
      name: "OneofMemberMessage2",
      package: "testapis.oneof",
    },
  },
});

export type OneofParentInput$Shape = {
  normalField: OneofParent["normalField"];
  requiredMessage1?: OneofMemberMessage1Input$Shape | null;
  requiredMessage2?: OneofMemberMessage2Input$Shape | null;
  optoinalMessage1?: OneofMemberMessage1Input$Shape | null;
  optoinalMessage2?: OneofMemberMessage2Input$Shape | null;
};

export const OneofParentInput$Ref: InputObjectRef<OneofParentInput$Shape> =
  builder.inputRef<OneofParentInput$Shape>("OneofParentInput").implement({
    fields: (t) => ({
      normalField: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: { name: "normal_field", typeFullName: "string" },
        },
      }),
      requiredMessage1: t.field({
        type: OneofMemberMessage1Input$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "required_message1",
            typeFullName: "testapis.oneof.OneofMemberMessage1",
          },
        },
      }),
      requiredMessage2: t.field({
        type: OneofMemberMessage2Input$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "required_message2",
            typeFullName: "testapis.oneof.OneofMemberMessage2",
          },
        },
      }),
      optoinalMessage1: t.field({
        type: OneofMemberMessage1Input$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "optoinal_message1",
            typeFullName: "testapis.oneof.OneofMemberMessage1",
          },
        },
      }),
      optoinalMessage2: t.field({
        type: OneofMemberMessage2Input$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "optoinal_message2",
            typeFullName: "testapis.oneof.OneofMemberMessage2",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.oneof.OneofParent",
        name: "OneofParent",
        package: "testapis.oneof",
      },
    },
  });

export type OneofMemberMessage1Input$Shape = {
  body: OneofMemberMessage1["body"];
};

export const OneofMemberMessage1Input$Ref: InputObjectRef<
  OneofMemberMessage1Input$Shape
> = builder.inputRef<OneofMemberMessage1Input$Shape>("OneofMemberMessage1Input")
  .implement({
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.oneof.OneofMemberMessage1",
        name: "OneofMemberMessage1",
        package: "testapis.oneof",
      },
    },
  });

export type OneofMemberMessage2Input$Shape = {
  imageUrl: OneofMemberMessage2["imageUrl"];
};

export const OneofMemberMessage2Input$Ref: InputObjectRef<
  OneofMemberMessage2Input$Shape
> = builder.inputRef<OneofMemberMessage2Input$Shape>("OneofMemberMessage2Input")
  .implement({
    fields: (t) => ({
      imageUrl: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: { name: "image_url", typeFullName: "string" },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.oneof.OneofMemberMessage2",
        name: "OneofMemberMessage2",
        package: "testapis.oneof",
      },
    },
  });

export const OneofParentRequiredOneofMembers$Ref = builder.unionType(
  "OneofParentRequiredOneofMembers",
  {
    types: [OneofMemberMessage1$Ref, OneofMemberMessage2$Ref],
    description: "Required. disallow not_set.",
    extensions: {
      protobufOneof: {
        fullName: "testapis.oneof.OneofParent.required_oneof_members",
        name: "required_oneof_members",
        messageName: "OneofParent",
        package: "testapis.oneof",
        fields: [{
          name: "required_message1",
          type: "testapis.oneof.OneofMemberMessage1",
        }, {
          name: "required_message2",
          type: "testapis.oneof.OneofMemberMessage2",
        }],
      },
    },
  },
);

export const OneofParentOptionalOneofMembers$Ref = builder.unionType(
  "OneofParentOptionalOneofMembers",
  {
    types: [OneofMemberMessage1$Ref, OneofMemberMessage2$Ref],
    extensions: {
      protobufOneof: {
        fullName: "testapis.oneof.OneofParent.optional_oneof_members",
        name: "optional_oneof_members",
        messageName: "OneofParent",
        package: "testapis.oneof",
        fields: [{
          name: "optoinal_message1",
          type: "testapis.oneof.OneofMemberMessage1",
        }, {
          name: "optoinal_message2",
          type: "testapis.oneof.OneofMemberMessage2",
        }],
      },
    },
  },
);
",
    "name": "testapis/oneof/oneof.pb.pothos.ts",
  },
]
`;

exports[`'testapis.primitives' > generates files by plugin 'with graphql_type layout' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/primitives/primitives.proto

/* eslint-disable */

import { Message } from "@testapis/ts-proto/testapis/primitives/primitives";
import { builder } from "../../builder";
import { Primitives$Ref } from "./Primitives.pothos";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    requiredPrimitives: t.field({
      type: Primitives$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.requiredPrimitives!;
      },
      extensions: {
        protobufField: {
          name: "required_primitives",
          typeFullName: "testapis.primitives.Primitives",
        },
      },
    }),
    optionalPrimitives: t.expose("optionalPrimitives", {
      type: Primitives$Ref,
      nullable: true,
      description: "Optional.",
      extensions: {
        protobufField: {
          name: "optional_primitives",
          typeFullName: "testapis.primitives.Primitives",
        },
      },
    }),
    requiredPrimitivesList: t.field({
      type: [Primitives$Ref],
      nullable: { list: false, items: false },
      description: "Required.",
      resolve: (source) => {
        return source.requiredPrimitivesList!;
      },
      extensions: {
        protobufField: {
          name: "required_primitives_list",
          typeFullName: "testapis.primitives.Primitives",
        },
      },
    }),
    optionalPrimitivesList: t.expose("optionalPrimitivesList", {
      type: [Primitives$Ref],
      nullable: { list: true, items: false },
      description: "Optional.",
      extensions: {
        protobufField: {
          name: "optional_primitives_list",
          typeFullName: "testapis.primitives.Primitives",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Message | { $type: string & {}; }).$type ===
      "testapis.primitives.Message";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.primitives.Message",
      name: "Message",
      package: "testapis.primitives",
    },
  },
});
",
    "name": "testapis/primitives/Message.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/primitives/primitives.proto

/* eslint-disable */

import { Primitives } from "@testapis/ts-proto/testapis/primitives/primitives";
import { builder } from "../../builder";

export const Primitives$Ref = builder.objectRef<Primitives>("Primitives");
builder.objectType(Primitives$Ref, {
  name: "Primitives",
  fields: (t) => ({
    requiredDoubleValue: t.expose("requiredDoubleValue", {
      type: "Float",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_double_value",
          typeFullName: "double",
        },
      },
    }),
    requiredFloatValue: t.expose("requiredFloatValue", {
      type: "Float",
      nullable: false,
      extensions: {
        protobufField: { name: "required_float_value", typeFullName: "float" },
      },
    }),
    requiredInt32Value: t.expose("requiredInt32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: { name: "required_int32_value", typeFullName: "int32" },
      },
    }),
    requiredInt64Value: t.expose("requiredInt64Value", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: { name: "required_int64_value", typeFullName: "int64" },
      },
    }),
    requiredUint32Value: t.expose("requiredUint32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_uint32_value",
          typeFullName: "uint32",
        },
      },
    }),
    requiredUint64Value: t.expose("requiredUint64Value", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_uint64_value",
          typeFullName: "uint64",
        },
      },
    }),
    requiredSint32Value: t.expose("requiredSint32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_sint32_value",
          typeFullName: "sint32",
        },
      },
    }),
    requiredSint64Value: t.expose("requiredSint64Value", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_sint64_value",
          typeFullName: "sint64",
        },
      },
    }),
    requiredFixed32Value: t.expose("requiredFixed32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_fixed32_value",
          typeFullName: "fixed32",
        },
      },
    }),
    requiredFixed64Value: t.expose("requiredFixed64Value", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_fixed64_value",
          typeFullName: "fixed64",
        },
      },
    }),
    requiredSfixed32Value: t.expose("requiredSfixed32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_sfixed32_value",
          typeFullName: "sfixed32",
        },
      },
    }),
    requiredSfixed64Value: t.expose("requiredSfixed64Value", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_sfixed64_value",
          typeFullName: "sfixed64",
        },
      },
    }),
    requiredBoolValue: t.expose("requiredBoolValue", {
      type: "Boolean",
      nullable: false,
      extensions: {
        protobufField: { name: "required_bool_value", typeFullName: "bool" },
      },
    }),
    requiredStringValue: t.expose("requiredStringValue", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_string_value",
          typeFullName: "string",
        },
      },
    }),
    requiredBytesValue: t.field({
      type: "Byte",
      nullable: false,
      resolve: (source) => {
        return Buffer.from(source.requiredBytesValue);
      },
      extensions: {
        protobufField: { name: "required_bytes_value", typeFullName: "bytes" },
      },
    }),
    requiredDoubleValues: t.expose("requiredDoubleValues", {
      type: ["Float"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_double_values",
          typeFullName: "double",
        },
      },
    }),
    requiredFloatValues: t.expose("requiredFloatValues", {
      type: ["Float"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: { name: "required_float_values", typeFullName: "float" },
      },
    }),
    requiredInt32Values: t.expose("requiredInt32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: { name: "required_int32_values", typeFullName: "int32" },
      },
    }),
    requiredInt64Values: t.expose("requiredInt64Values", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: { name: "required_int64_values", typeFullName: "int64" },
      },
    }),
    requiredUint32Values: t.expose("requiredUint32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_uint32_values",
          typeFullName: "uint32",
        },
      },
    }),
    requiredUint64Values: t.expose("requiredUint64Values", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_uint64_values",
          typeFullName: "uint64",
        },
      },
    }),
    requiredSint32Values: t.expose("requiredSint32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_sint32_values",
          typeFullName: "sint32",
        },
      },
    }),
    requiredSint64Values: t.expose("requiredSint64Values", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_sint64_values",
          typeFullName: "sint64",
        },
      },
    }),
    requiredFixed32Values: t.expose("requiredFixed32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_fixed32_values",
          typeFullName: "fixed32",
        },
      },
    }),
    requiredFixed64Values: t.expose("requiredFixed64Values", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_fixed64_values",
          typeFullName: "fixed64",
        },
      },
    }),
    requiredSfixed32Values: t.expose("requiredSfixed32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_sfixed32_values",
          typeFullName: "sfixed32",
        },
      },
    }),
    requiredSfixed64Values: t.expose("requiredSfixed64Values", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_sfixed64_values",
          typeFullName: "sfixed64",
        },
      },
    }),
    requiredBoolValues: t.expose("requiredBoolValues", {
      type: ["Boolean"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: { name: "required_bool_values", typeFullName: "bool" },
      },
    }),
    requiredStringValues: t.expose("requiredStringValues", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_string_values",
          typeFullName: "string",
        },
      },
    }),
    requiredBytesValues: t.field({
      type: ["Byte"],
      nullable: { list: false, items: false },
      resolve: (source) => {
        return source.requiredBytesValues.map((v) => Buffer.from(v));
      },
      extensions: {
        protobufField: { name: "required_bytes_values", typeFullName: "bytes" },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Primitives | { $type: string & {}; }).$type ===
      "testapis.primitives.Primitives";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.primitives.Primitives",
      name: "Primitives",
      package: "testapis.primitives",
    },
  },
});
",
    "name": "testapis/primitives/Primitives.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/primitives/primitives.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import {
  PrimitivesInput$Ref,
  PrimitivesInput$Shape,
} from "./PrimitivesInput.pothos";

export type MessageInput$Shape = {
  requiredPrimitives: PrimitivesInput$Shape;
  optionalPrimitives?: PrimitivesInput$Shape | null;
  requiredPrimitivesList: Array<PrimitivesInput$Shape>;
  optionalPrimitivesList?: Array<PrimitivesInput$Shape> | null;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement({
    fields: (t) => ({
      requiredPrimitives: t.field({
        type: PrimitivesInput$Ref,
        required: true,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_primitives",
            typeFullName: "testapis.primitives.Primitives",
          },
        },
      }),
      optionalPrimitives: t.field({
        type: PrimitivesInput$Ref,
        required: false,
        description: "Optional.",
        extensions: {
          protobufField: {
            name: "optional_primitives",
            typeFullName: "testapis.primitives.Primitives",
          },
        },
      }),
      requiredPrimitivesList: t.field({
        type: [PrimitivesInput$Ref],
        required: { list: true, items: true },
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_primitives_list",
            typeFullName: "testapis.primitives.Primitives",
          },
        },
      }),
      optionalPrimitivesList: t.field({
        type: [PrimitivesInput$Ref],
        required: { list: false, items: true },
        description: "Optional.",
        extensions: {
          protobufField: {
            name: "optional_primitives_list",
            typeFullName: "testapis.primitives.Primitives",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.primitives.Message",
        name: "Message",
        package: "testapis.primitives",
      },
    },
  });
",
    "name": "testapis/primitives/MessageInput.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/primitives/primitives.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { Primitives } from "@testapis/ts-proto/testapis/primitives/primitives";
import { builder } from "../../builder";

export type PrimitivesInput$Shape = {
  requiredDoubleValue: Primitives["requiredDoubleValue"];
  requiredFloatValue: Primitives["requiredFloatValue"];
  requiredInt32Value: Primitives["requiredInt32Value"];
  requiredInt64Value: Primitives["requiredInt64Value"];
  requiredUint32Value: Primitives["requiredUint32Value"];
  requiredUint64Value: Primitives["requiredUint64Value"];
  requiredSint32Value: Primitives["requiredSint32Value"];
  requiredSint64Value: Primitives["requiredSint64Value"];
  requiredFixed32Value: Primitives["requiredFixed32Value"];
  requiredFixed64Value: Primitives["requiredFixed64Value"];
  requiredSfixed32Value: Primitives["requiredSfixed32Value"];
  requiredSfixed64Value: Primitives["requiredSfixed64Value"];
  requiredBoolValue: Primitives["requiredBoolValue"];
  requiredStringValue: Primitives["requiredStringValue"];
  requiredBytesValue: Primitives["requiredBytesValue"];
  requiredDoubleValues: Primitives["requiredDoubleValues"];
  requiredFloatValues: Primitives["requiredFloatValues"];
  requiredInt32Values: Primitives["requiredInt32Values"];
  requiredInt64Values: Primitives["requiredInt64Values"];
  requiredUint32Values: Primitives["requiredUint32Values"];
  requiredUint64Values: Primitives["requiredUint64Values"];
  requiredSint32Values: Primitives["requiredSint32Values"];
  requiredSint64Values: Primitives["requiredSint64Values"];
  requiredFixed32Values: Primitives["requiredFixed32Values"];
  requiredFixed64Values: Primitives["requiredFixed64Values"];
  requiredSfixed32Values: Primitives["requiredSfixed32Values"];
  requiredSfixed64Values: Primitives["requiredSfixed64Values"];
  requiredBoolValues: Primitives["requiredBoolValues"];
  requiredStringValues: Primitives["requiredStringValues"];
  requiredBytesValues: Primitives["requiredBytesValues"];
};

export const PrimitivesInput$Ref: InputObjectRef<PrimitivesInput$Shape> =
  builder.inputRef<PrimitivesInput$Shape>("PrimitivesInput").implement({
    fields: (t) => ({
      requiredDoubleValue: t.field({
        type: "Float",
        required: true,
        extensions: {
          protobufField: {
            name: "required_double_value",
            typeFullName: "double",
          },
        },
      }),
      requiredFloatValue: t.field({
        type: "Float",
        required: true,
        extensions: {
          protobufField: {
            name: "required_float_value",
            typeFullName: "float",
          },
        },
      }),
      requiredInt32Value: t.field({
        type: "Int",
        required: true,
        extensions: {
          protobufField: {
            name: "required_int32_value",
            typeFullName: "int32",
          },
        },
      }),
      requiredInt64Value: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: {
            name: "required_int64_value",
            typeFullName: "int64",
          },
        },
      }),
      requiredUint32Value: t.field({
        type: "Int",
        required: true,
        extensions: {
          protobufField: {
            name: "required_uint32_value",
            typeFullName: "uint32",
          },
        },
      }),
      requiredUint64Value: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: {
            name: "required_uint64_value",
            typeFullName: "uint64",
          },
        },
      }),
      requiredSint32Value: t.field({
        type: "Int",
        required: true,
        extensions: {
          protobufField: {
            name: "required_sint32_value",
            typeFullName: "sint32",
          },
        },
      }),
      requiredSint64Value: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: {
            name: "required_sint64_value",
            typeFullName: "sint64",
          },
        },
      }),
      requiredFixed32Value: t.field({
        type: "Int",
        required: true,
        extensions: {
          protobufField: {
            name: "required_fixed32_value",
            typeFullName: "fixed32",
          },
        },
      }),
      requiredFixed64Value: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: {
            name: "required_fixed64_value",
            typeFullName: "fixed64",
          },
        },
      }),
      requiredSfixed32Value: t.field({
        type: "Int",
        required: true,
        extensions: {
          protobufField: {
            name: "required_sfixed32_value",
            typeFullName: "sfixed32",
          },
        },
      }),
      requiredSfixed64Value: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: {
            name: "required_sfixed64_value",
            typeFullName: "sfixed64",
          },
        },
      }),
      requiredBoolValue: t.field({
        type: "Boolean",
        required: true,
        extensions: {
          protobufField: { name: "required_bool_value", typeFullName: "bool" },
        },
      }),
      requiredStringValue: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: {
            name: "required_string_value",
            typeFullName: "string",
          },
        },
      }),
      requiredBytesValue: t.field({
        type: "Byte",
        required: true,
        extensions: {
          protobufField: {
            name: "required_bytes_value",
            typeFullName: "bytes",
          },
        },
      }),
      requiredDoubleValues: t.field({
        type: ["Float"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_double_values",
            typeFullName: "double",
          },
        },
      }),
      requiredFloatValues: t.field({
        type: ["Float"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_float_values",
            typeFullName: "float",
          },
        },
      }),
      requiredInt32Values: t.field({
        type: ["Int"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_int32_values",
            typeFullName: "int32",
          },
        },
      }),
      requiredInt64Values: t.field({
        type: ["String"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_int64_values",
            typeFullName: "int64",
          },
        },
      }),
      requiredUint32Values: t.field({
        type: ["Int"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_uint32_values",
            typeFullName: "uint32",
          },
        },
      }),
      requiredUint64Values: t.field({
        type: ["String"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_uint64_values",
            typeFullName: "uint64",
          },
        },
      }),
      requiredSint32Values: t.field({
        type: ["Int"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_sint32_values",
            typeFullName: "sint32",
          },
        },
      }),
      requiredSint64Values: t.field({
        type: ["String"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_sint64_values",
            typeFullName: "sint64",
          },
        },
      }),
      requiredFixed32Values: t.field({
        type: ["Int"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_fixed32_values",
            typeFullName: "fixed32",
          },
        },
      }),
      requiredFixed64Values: t.field({
        type: ["String"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_fixed64_values",
            typeFullName: "fixed64",
          },
        },
      }),
      requiredSfixed32Values: t.field({
        type: ["Int"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_sfixed32_values",
            typeFullName: "sfixed32",
          },
        },
      }),
      requiredSfixed64Values: t.field({
        type: ["String"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_sfixed64_values",
            typeFullName: "sfixed64",
          },
        },
      }),
      requiredBoolValues: t.field({
        type: ["Boolean"],
        required: { list: true, items: true },
        extensions: {
          protobufField: { name: "required_bool_values", typeFullName: "bool" },
        },
      }),
      requiredStringValues: t.field({
        type: ["String"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_string_values",
            typeFullName: "string",
          },
        },
      }),
      requiredBytesValues: t.field({
        type: ["Byte"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_bytes_values",
            typeFullName: "bytes",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.primitives.Primitives",
        name: "Primitives",
        package: "testapis.primitives",
      },
    },
  });
",
    "name": "testapis/primitives/PrimitivesInput.pothos.ts",
  },
]
`;

exports[`'testapis.primitives' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/primitives/primitives.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import {
  Message,
  Primitives,
} from "@testapis/ts-proto/testapis/primitives/primitives";
import { builder } from "../../builder";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    requiredPrimitives: t.field({
      type: Primitives$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.requiredPrimitives!;
      },
      extensions: {
        protobufField: {
          name: "required_primitives",
          typeFullName: "testapis.primitives.Primitives",
        },
      },
    }),
    optionalPrimitives: t.expose("optionalPrimitives", {
      type: Primitives$Ref,
      nullable: true,
      description: "Optional.",
      extensions: {
        protobufField: {
          name: "optional_primitives",
          typeFullName: "testapis.primitives.Primitives",
        },
      },
    }),
    requiredPrimitivesList: t.field({
      type: [Primitives$Ref],
      nullable: { list: false, items: false },
      description: "Required.",
      resolve: (source) => {
        return source.requiredPrimitivesList!;
      },
      extensions: {
        protobufField: {
          name: "required_primitives_list",
          typeFullName: "testapis.primitives.Primitives",
        },
      },
    }),
    optionalPrimitivesList: t.expose("optionalPrimitivesList", {
      type: [Primitives$Ref],
      nullable: { list: true, items: false },
      description: "Optional.",
      extensions: {
        protobufField: {
          name: "optional_primitives_list",
          typeFullName: "testapis.primitives.Primitives",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Message | { $type: string & {}; }).$type ===
      "testapis.primitives.Message";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.primitives.Message",
      name: "Message",
      package: "testapis.primitives",
    },
  },
});

export const Primitives$Ref = builder.objectRef<Primitives>("Primitives");
builder.objectType(Primitives$Ref, {
  name: "Primitives",
  fields: (t) => ({
    requiredDoubleValue: t.expose("requiredDoubleValue", {
      type: "Float",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_double_value",
          typeFullName: "double",
        },
      },
    }),
    requiredFloatValue: t.expose("requiredFloatValue", {
      type: "Float",
      nullable: false,
      extensions: {
        protobufField: { name: "required_float_value", typeFullName: "float" },
      },
    }),
    requiredInt32Value: t.expose("requiredInt32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: { name: "required_int32_value", typeFullName: "int32" },
      },
    }),
    requiredInt64Value: t.expose("requiredInt64Value", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: { name: "required_int64_value", typeFullName: "int64" },
      },
    }),
    requiredUint32Value: t.expose("requiredUint32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_uint32_value",
          typeFullName: "uint32",
        },
      },
    }),
    requiredUint64Value: t.expose("requiredUint64Value", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_uint64_value",
          typeFullName: "uint64",
        },
      },
    }),
    requiredSint32Value: t.expose("requiredSint32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_sint32_value",
          typeFullName: "sint32",
        },
      },
    }),
    requiredSint64Value: t.expose("requiredSint64Value", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_sint64_value",
          typeFullName: "sint64",
        },
      },
    }),
    requiredFixed32Value: t.expose("requiredFixed32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_fixed32_value",
          typeFullName: "fixed32",
        },
      },
    }),
    requiredFixed64Value: t.expose("requiredFixed64Value", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_fixed64_value",
          typeFullName: "fixed64",
        },
      },
    }),
    requiredSfixed32Value: t.expose("requiredSfixed32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_sfixed32_value",
          typeFullName: "sfixed32",
        },
      },
    }),
    requiredSfixed64Value: t.expose("requiredSfixed64Value", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_sfixed64_value",
          typeFullName: "sfixed64",
        },
      },
    }),
    requiredBoolValue: t.expose("requiredBoolValue", {
      type: "Boolean",
      nullable: false,
      extensions: {
        protobufField: { name: "required_bool_value", typeFullName: "bool" },
      },
    }),
    requiredStringValue: t.expose("requiredStringValue", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_string_value",
          typeFullName: "string",
        },
      },
    }),
    requiredBytesValue: t.field({
      type: "Byte",
      nullable: false,
      resolve: (source) => {
        return Buffer.from(source.requiredBytesValue);
      },
      extensions: {
        protobufField: { name: "required_bytes_value", typeFullName: "bytes" },
      },
    }),
    requiredDoubleValues: t.expose("requiredDoubleValues", {
      type: ["Float"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_double_values",
          typeFullName: "double",
        },
      },
    }),
    requiredFloatValues: t.expose("requiredFloatValues", {
      type: ["Float"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: { name: "required_float_values", typeFullName: "float" },
      },
    }),
    requiredInt32Values: t.expose("requiredInt32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: { name: "required_int32_values", typeFullName: "int32" },
      },
    }),
    requiredInt64Values: t.expose("requiredInt64Values", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: { name: "required_int64_values", typeFullName: "int64" },
      },
    }),
    requiredUint32Values: t.expose("requiredUint32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_uint32_values",
          typeFullName: "uint32",
        },
      },
    }),
    requiredUint64Values: t.expose("requiredUint64Values", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_uint64_values",
          typeFullName: "uint64",
        },
      },
    }),
    requiredSint32Values: t.expose("requiredSint32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_sint32_values",
          typeFullName: "sint32",
        },
      },
    }),
    requiredSint64Values: t.expose("requiredSint64Values", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_sint64_values",
          typeFullName: "sint64",
        },
      },
    }),
    requiredFixed32Values: t.expose("requiredFixed32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_fixed32_values",
          typeFullName: "fixed32",
        },
      },
    }),
    requiredFixed64Values: t.expose("requiredFixed64Values", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_fixed64_values",
          typeFullName: "fixed64",
        },
      },
    }),
    requiredSfixed32Values: t.expose("requiredSfixed32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_sfixed32_values",
          typeFullName: "sfixed32",
        },
      },
    }),
    requiredSfixed64Values: t.expose("requiredSfixed64Values", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_sfixed64_values",
          typeFullName: "sfixed64",
        },
      },
    }),
    requiredBoolValues: t.expose("requiredBoolValues", {
      type: ["Boolean"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: { name: "required_bool_values", typeFullName: "bool" },
      },
    }),
    requiredStringValues: t.expose("requiredStringValues", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_string_values",
          typeFullName: "string",
        },
      },
    }),
    requiredBytesValues: t.field({
      type: ["Byte"],
      nullable: { list: false, items: false },
      resolve: (source) => {
        return source.requiredBytesValues.map((v) => Buffer.from(v));
      },
      extensions: {
        protobufField: { name: "required_bytes_values", typeFullName: "bytes" },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Primitives | { $type: string & {}; }).$type ===
      "testapis.primitives.Primitives";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.primitives.Primitives",
      name: "Primitives",
      package: "testapis.primitives",
    },
  },
});

export type MessageInput$Shape = {
  requiredPrimitives: PrimitivesInput$Shape;
  optionalPrimitives?: PrimitivesInput$Shape | null;
  requiredPrimitivesList: Array<PrimitivesInput$Shape>;
  optionalPrimitivesList?: Array<PrimitivesInput$Shape> | null;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement({
    fields: (t) => ({
      requiredPrimitives: t.field({
        type: PrimitivesInput$Ref,
        required: true,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_primitives",
            typeFullName: "testapis.primitives.Primitives",
          },
        },
      }),
      optionalPrimitives: t.field({
        type: PrimitivesInput$Ref,
        required: false,
        description: "Optional.",
        extensions: {
          protobufField: {
            name: "optional_primitives",
            typeFullName: "testapis.primitives.Primitives",
          },
        },
      }),
      requiredPrimitivesList: t.field({
        type: [PrimitivesInput$Ref],
        required: { list: true, items: true },
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_primitives_list",
            typeFullName: "testapis.primitives.Primitives",
          },
        },
      }),
      optionalPrimitivesList: t.field({
        type: [PrimitivesInput$Ref],
        required: { list: false, items: true },
        description: "Optional.",
        extensions: {
          protobufField: {
            name: "optional_primitives_list",
            typeFullName: "testapis.primitives.Primitives",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.primitives.Message",
        name: "Message",
        package: "testapis.primitives",
      },
    },
  });

export type PrimitivesInput$Shape = {
  requiredDoubleValue: Primitives["requiredDoubleValue"];
  requiredFloatValue: Primitives["requiredFloatValue"];
  requiredInt32Value: Primitives["requiredInt32Value"];
  requiredInt64Value: Primitives["requiredInt64Value"];
  requiredUint32Value: Primitives["requiredUint32Value"];
  requiredUint64Value: Primitives["requiredUint64Value"];
  requiredSint32Value: Primitives["requiredSint32Value"];
  requiredSint64Value: Primitives["requiredSint64Value"];
  requiredFixed32Value: Primitives["requiredFixed32Value"];
  requiredFixed64Value: Primitives["requiredFixed64Value"];
  requiredSfixed32Value: Primitives["requiredSfixed32Value"];
  requiredSfixed64Value: Primitives["requiredSfixed64Value"];
  requiredBoolValue: Primitives["requiredBoolValue"];
  requiredStringValue: Primitives["requiredStringValue"];
  requiredBytesValue: Primitives["requiredBytesValue"];
  requiredDoubleValues: Primitives["requiredDoubleValues"];
  requiredFloatValues: Primitives["requiredFloatValues"];
  requiredInt32Values: Primitives["requiredInt32Values"];
  requiredInt64Values: Primitives["requiredInt64Values"];
  requiredUint32Values: Primitives["requiredUint32Values"];
  requiredUint64Values: Primitives["requiredUint64Values"];
  requiredSint32Values: Primitives["requiredSint32Values"];
  requiredSint64Values: Primitives["requiredSint64Values"];
  requiredFixed32Values: Primitives["requiredFixed32Values"];
  requiredFixed64Values: Primitives["requiredFixed64Values"];
  requiredSfixed32Values: Primitives["requiredSfixed32Values"];
  requiredSfixed64Values: Primitives["requiredSfixed64Values"];
  requiredBoolValues: Primitives["requiredBoolValues"];
  requiredStringValues: Primitives["requiredStringValues"];
  requiredBytesValues: Primitives["requiredBytesValues"];
};

export const PrimitivesInput$Ref: InputObjectRef<PrimitivesInput$Shape> =
  builder.inputRef<PrimitivesInput$Shape>("PrimitivesInput").implement({
    fields: (t) => ({
      requiredDoubleValue: t.field({
        type: "Float",
        required: true,
        extensions: {
          protobufField: {
            name: "required_double_value",
            typeFullName: "double",
          },
        },
      }),
      requiredFloatValue: t.field({
        type: "Float",
        required: true,
        extensions: {
          protobufField: {
            name: "required_float_value",
            typeFullName: "float",
          },
        },
      }),
      requiredInt32Value: t.field({
        type: "Int",
        required: true,
        extensions: {
          protobufField: {
            name: "required_int32_value",
            typeFullName: "int32",
          },
        },
      }),
      requiredInt64Value: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: {
            name: "required_int64_value",
            typeFullName: "int64",
          },
        },
      }),
      requiredUint32Value: t.field({
        type: "Int",
        required: true,
        extensions: {
          protobufField: {
            name: "required_uint32_value",
            typeFullName: "uint32",
          },
        },
      }),
      requiredUint64Value: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: {
            name: "required_uint64_value",
            typeFullName: "uint64",
          },
        },
      }),
      requiredSint32Value: t.field({
        type: "Int",
        required: true,
        extensions: {
          protobufField: {
            name: "required_sint32_value",
            typeFullName: "sint32",
          },
        },
      }),
      requiredSint64Value: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: {
            name: "required_sint64_value",
            typeFullName: "sint64",
          },
        },
      }),
      requiredFixed32Value: t.field({
        type: "Int",
        required: true,
        extensions: {
          protobufField: {
            name: "required_fixed32_value",
            typeFullName: "fixed32",
          },
        },
      }),
      requiredFixed64Value: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: {
            name: "required_fixed64_value",
            typeFullName: "fixed64",
          },
        },
      }),
      requiredSfixed32Value: t.field({
        type: "Int",
        required: true,
        extensions: {
          protobufField: {
            name: "required_sfixed32_value",
            typeFullName: "sfixed32",
          },
        },
      }),
      requiredSfixed64Value: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: {
            name: "required_sfixed64_value",
            typeFullName: "sfixed64",
          },
        },
      }),
      requiredBoolValue: t.field({
        type: "Boolean",
        required: true,
        extensions: {
          protobufField: { name: "required_bool_value", typeFullName: "bool" },
        },
      }),
      requiredStringValue: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: {
            name: "required_string_value",
            typeFullName: "string",
          },
        },
      }),
      requiredBytesValue: t.field({
        type: "Byte",
        required: true,
        extensions: {
          protobufField: {
            name: "required_bytes_value",
            typeFullName: "bytes",
          },
        },
      }),
      requiredDoubleValues: t.field({
        type: ["Float"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_double_values",
            typeFullName: "double",
          },
        },
      }),
      requiredFloatValues: t.field({
        type: ["Float"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_float_values",
            typeFullName: "float",
          },
        },
      }),
      requiredInt32Values: t.field({
        type: ["Int"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_int32_values",
            typeFullName: "int32",
          },
        },
      }),
      requiredInt64Values: t.field({
        type: ["String"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_int64_values",
            typeFullName: "int64",
          },
        },
      }),
      requiredUint32Values: t.field({
        type: ["Int"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_uint32_values",
            typeFullName: "uint32",
          },
        },
      }),
      requiredUint64Values: t.field({
        type: ["String"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_uint64_values",
            typeFullName: "uint64",
          },
        },
      }),
      requiredSint32Values: t.field({
        type: ["Int"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_sint32_values",
            typeFullName: "sint32",
          },
        },
      }),
      requiredSint64Values: t.field({
        type: ["String"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_sint64_values",
            typeFullName: "sint64",
          },
        },
      }),
      requiredFixed32Values: t.field({
        type: ["Int"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_fixed32_values",
            typeFullName: "fixed32",
          },
        },
      }),
      requiredFixed64Values: t.field({
        type: ["String"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_fixed64_values",
            typeFullName: "fixed64",
          },
        },
      }),
      requiredSfixed32Values: t.field({
        type: ["Int"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_sfixed32_values",
            typeFullName: "sfixed32",
          },
        },
      }),
      requiredSfixed64Values: t.field({
        type: ["String"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_sfixed64_values",
            typeFullName: "sfixed64",
          },
        },
      }),
      requiredBoolValues: t.field({
        type: ["Boolean"],
        required: { list: true, items: true },
        extensions: {
          protobufField: { name: "required_bool_values", typeFullName: "bool" },
        },
      }),
      requiredStringValues: t.field({
        type: ["String"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_string_values",
            typeFullName: "string",
          },
        },
      }),
      requiredBytesValues: t.field({
        type: ["Byte"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_bytes_values",
            typeFullName: "bytes",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.primitives.Primitives",
        name: "Primitives",
        package: "testapis.primitives",
      },
    },
  });
",
    "name": "testapis/primitives/primitives.pb.pothos.ts",
  },
]
`;

exports[`'testapis.primitives' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/primitives/primitives.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import {
  Message,
  Primitives,
} from "@testapis/ts-proto/testapis/primitives/primitives";
import { builder } from "../../builder";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    requiredPrimitives: t.field({
      type: Primitives$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.requiredPrimitives!;
      },
      extensions: {
        protobufField: {
          name: "required_primitives",
          typeFullName: "testapis.primitives.Primitives",
        },
      },
    }),
    optionalPrimitives: t.expose("optionalPrimitives", {
      type: Primitives$Ref,
      nullable: true,
      description: "Optional.",
      extensions: {
        protobufField: {
          name: "optional_primitives",
          typeFullName: "testapis.primitives.Primitives",
        },
      },
    }),
    requiredPrimitivesList: t.field({
      type: [Primitives$Ref],
      nullable: { list: false, items: false },
      description: "Required.",
      resolve: (source) => {
        return source.requiredPrimitivesList!;
      },
      extensions: {
        protobufField: {
          name: "required_primitives_list",
          typeFullName: "testapis.primitives.Primitives",
        },
      },
    }),
    optionalPrimitivesList: t.expose("optionalPrimitivesList", {
      type: [Primitives$Ref],
      nullable: { list: true, items: false },
      description: "Optional.",
      extensions: {
        protobufField: {
          name: "optional_primitives_list",
          typeFullName: "testapis.primitives.Primitives",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Message | { $type: string & {}; }).$type ===
      "testapis.primitives.Message";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.primitives.Message",
      name: "Message",
      package: "testapis.primitives",
    },
  },
});

export const Primitives$Ref = builder.objectRef<Primitives>("Primitives");
builder.objectType(Primitives$Ref, {
  name: "Primitives",
  fields: (t) => ({
    requiredDoubleValue: t.expose("requiredDoubleValue", {
      type: "Float",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_double_value",
          typeFullName: "double",
        },
      },
    }),
    requiredFloatValue: t.expose("requiredFloatValue", {
      type: "Float",
      nullable: false,
      extensions: {
        protobufField: { name: "required_float_value", typeFullName: "float" },
      },
    }),
    requiredInt32Value: t.expose("requiredInt32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: { name: "required_int32_value", typeFullName: "int32" },
      },
    }),
    requiredInt64Value: t.expose("requiredInt64Value", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: { name: "required_int64_value", typeFullName: "int64" },
      },
    }),
    requiredUint32Value: t.expose("requiredUint32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_uint32_value",
          typeFullName: "uint32",
        },
      },
    }),
    requiredUint64Value: t.expose("requiredUint64Value", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_uint64_value",
          typeFullName: "uint64",
        },
      },
    }),
    requiredSint32Value: t.expose("requiredSint32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_sint32_value",
          typeFullName: "sint32",
        },
      },
    }),
    requiredSint64Value: t.expose("requiredSint64Value", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_sint64_value",
          typeFullName: "sint64",
        },
      },
    }),
    requiredFixed32Value: t.expose("requiredFixed32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_fixed32_value",
          typeFullName: "fixed32",
        },
      },
    }),
    requiredFixed64Value: t.expose("requiredFixed64Value", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_fixed64_value",
          typeFullName: "fixed64",
        },
      },
    }),
    requiredSfixed32Value: t.expose("requiredSfixed32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_sfixed32_value",
          typeFullName: "sfixed32",
        },
      },
    }),
    requiredSfixed64Value: t.expose("requiredSfixed64Value", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_sfixed64_value",
          typeFullName: "sfixed64",
        },
      },
    }),
    requiredBoolValue: t.expose("requiredBoolValue", {
      type: "Boolean",
      nullable: false,
      extensions: {
        protobufField: { name: "required_bool_value", typeFullName: "bool" },
      },
    }),
    requiredStringValue: t.expose("requiredStringValue", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_string_value",
          typeFullName: "string",
        },
      },
    }),
    requiredBytesValue: t.field({
      type: "Byte",
      nullable: false,
      resolve: (source) => {
        return Buffer.from(source.requiredBytesValue);
      },
      extensions: {
        protobufField: { name: "required_bytes_value", typeFullName: "bytes" },
      },
    }),
    requiredDoubleValues: t.expose("requiredDoubleValues", {
      type: ["Float"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_double_values",
          typeFullName: "double",
        },
      },
    }),
    requiredFloatValues: t.expose("requiredFloatValues", {
      type: ["Float"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: { name: "required_float_values", typeFullName: "float" },
      },
    }),
    requiredInt32Values: t.expose("requiredInt32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: { name: "required_int32_values", typeFullName: "int32" },
      },
    }),
    requiredInt64Values: t.expose("requiredInt64Values", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: { name: "required_int64_values", typeFullName: "int64" },
      },
    }),
    requiredUint32Values: t.expose("requiredUint32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_uint32_values",
          typeFullName: "uint32",
        },
      },
    }),
    requiredUint64Values: t.expose("requiredUint64Values", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_uint64_values",
          typeFullName: "uint64",
        },
      },
    }),
    requiredSint32Values: t.expose("requiredSint32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_sint32_values",
          typeFullName: "sint32",
        },
      },
    }),
    requiredSint64Values: t.expose("requiredSint64Values", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_sint64_values",
          typeFullName: "sint64",
        },
      },
    }),
    requiredFixed32Values: t.expose("requiredFixed32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_fixed32_values",
          typeFullName: "fixed32",
        },
      },
    }),
    requiredFixed64Values: t.expose("requiredFixed64Values", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_fixed64_values",
          typeFullName: "fixed64",
        },
      },
    }),
    requiredSfixed32Values: t.expose("requiredSfixed32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_sfixed32_values",
          typeFullName: "sfixed32",
        },
      },
    }),
    requiredSfixed64Values: t.expose("requiredSfixed64Values", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_sfixed64_values",
          typeFullName: "sfixed64",
        },
      },
    }),
    requiredBoolValues: t.expose("requiredBoolValues", {
      type: ["Boolean"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: { name: "required_bool_values", typeFullName: "bool" },
      },
    }),
    requiredStringValues: t.expose("requiredStringValues", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_string_values",
          typeFullName: "string",
        },
      },
    }),
    requiredBytesValues: t.field({
      type: ["Byte"],
      nullable: { list: false, items: false },
      resolve: (source) => {
        return source.requiredBytesValues.map((v) => Buffer.from(v));
      },
      extensions: {
        protobufField: { name: "required_bytes_values", typeFullName: "bytes" },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Primitives | { $type: string & {}; }).$type ===
      "testapis.primitives.Primitives";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.primitives.Primitives",
      name: "Primitives",
      package: "testapis.primitives",
    },
  },
});

export type MessageInput$Shape = {
  requiredPrimitives: PrimitivesInput$Shape;
  optionalPrimitives?: PrimitivesInput$Shape | null;
  requiredPrimitivesList: Array<PrimitivesInput$Shape>;
  optionalPrimitivesList?: Array<PrimitivesInput$Shape> | null;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement({
    fields: (t) => ({
      requiredPrimitives: t.field({
        type: PrimitivesInput$Ref,
        required: true,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_primitives",
            typeFullName: "testapis.primitives.Primitives",
          },
        },
      }),
      optionalPrimitives: t.field({
        type: PrimitivesInput$Ref,
        required: false,
        description: "Optional.",
        extensions: {
          protobufField: {
            name: "optional_primitives",
            typeFullName: "testapis.primitives.Primitives",
          },
        },
      }),
      requiredPrimitivesList: t.field({
        type: [PrimitivesInput$Ref],
        required: { list: true, items: true },
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_primitives_list",
            typeFullName: "testapis.primitives.Primitives",
          },
        },
      }),
      optionalPrimitivesList: t.field({
        type: [PrimitivesInput$Ref],
        required: { list: false, items: true },
        description: "Optional.",
        extensions: {
          protobufField: {
            name: "optional_primitives_list",
            typeFullName: "testapis.primitives.Primitives",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.primitives.Message",
        name: "Message",
        package: "testapis.primitives",
      },
    },
  });

export type MessagePartialInput$Shape = {
  requiredPrimitives?: PrimitivesPartialInput$Shape | null;
  optionalPrimitives?: PrimitivesPartialInput$Shape | null;
  requiredPrimitivesList?: Array<PrimitivesPartialInput$Shape> | null;
  optionalPrimitivesList?: Array<PrimitivesPartialInput$Shape> | null;
};

export const MessagePartialInput$Ref: InputObjectRef<
  MessagePartialInput$Shape
> = builder.inputRef<MessagePartialInput$Shape>("MessagePartialInput")
  .implement({
    fields: (t) => ({
      requiredPrimitives: t.field({
        type: PrimitivesPartialInput$Ref,
        required: false,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_primitives",
            typeFullName: "testapis.primitives.Primitives",
          },
        },
      }),
      optionalPrimitives: t.field({
        type: PrimitivesPartialInput$Ref,
        required: false,
        description: "Optional.",
        extensions: {
          protobufField: {
            name: "optional_primitives",
            typeFullName: "testapis.primitives.Primitives",
          },
        },
      }),
      requiredPrimitivesList: t.field({
        type: [PrimitivesPartialInput$Ref],
        required: { list: false, items: true },
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_primitives_list",
            typeFullName: "testapis.primitives.Primitives",
          },
        },
      }),
      optionalPrimitivesList: t.field({
        type: [PrimitivesPartialInput$Ref],
        required: { list: false, items: true },
        description: "Optional.",
        extensions: {
          protobufField: {
            name: "optional_primitives_list",
            typeFullName: "testapis.primitives.Primitives",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.primitives.Message",
        name: "Message",
        package: "testapis.primitives",
      },
    },
  });

export type PrimitivesInput$Shape = {
  requiredDoubleValue: Primitives["requiredDoubleValue"];
  requiredFloatValue: Primitives["requiredFloatValue"];
  requiredInt32Value: Primitives["requiredInt32Value"];
  requiredInt64Value: Primitives["requiredInt64Value"];
  requiredUint32Value: Primitives["requiredUint32Value"];
  requiredUint64Value: Primitives["requiredUint64Value"];
  requiredSint32Value: Primitives["requiredSint32Value"];
  requiredSint64Value: Primitives["requiredSint64Value"];
  requiredFixed32Value: Primitives["requiredFixed32Value"];
  requiredFixed64Value: Primitives["requiredFixed64Value"];
  requiredSfixed32Value: Primitives["requiredSfixed32Value"];
  requiredSfixed64Value: Primitives["requiredSfixed64Value"];
  requiredBoolValue: Primitives["requiredBoolValue"];
  requiredStringValue: Primitives["requiredStringValue"];
  requiredBytesValue: Primitives["requiredBytesValue"];
  requiredDoubleValues: Primitives["requiredDoubleValues"];
  requiredFloatValues: Primitives["requiredFloatValues"];
  requiredInt32Values: Primitives["requiredInt32Values"];
  requiredInt64Values: Primitives["requiredInt64Values"];
  requiredUint32Values: Primitives["requiredUint32Values"];
  requiredUint64Values: Primitives["requiredUint64Values"];
  requiredSint32Values: Primitives["requiredSint32Values"];
  requiredSint64Values: Primitives["requiredSint64Values"];
  requiredFixed32Values: Primitives["requiredFixed32Values"];
  requiredFixed64Values: Primitives["requiredFixed64Values"];
  requiredSfixed32Values: Primitives["requiredSfixed32Values"];
  requiredSfixed64Values: Primitives["requiredSfixed64Values"];
  requiredBoolValues: Primitives["requiredBoolValues"];
  requiredStringValues: Primitives["requiredStringValues"];
  requiredBytesValues: Primitives["requiredBytesValues"];
};

export const PrimitivesInput$Ref: InputObjectRef<PrimitivesInput$Shape> =
  builder.inputRef<PrimitivesInput$Shape>("PrimitivesInput").implement({
    fields: (t) => ({
      requiredDoubleValue: t.field({
        type: "Float",
        required: true,
        extensions: {
          protobufField: {
            name: "required_double_value",
            typeFullName: "double",
          },
        },
      }),
      requiredFloatValue: t.field({
        type: "Float",
        required: true,
        extensions: {
          protobufField: {
            name: "required_float_value",
            typeFullName: "float",
          },
        },
      }),
      requiredInt32Value: t.field({
        type: "Int",
        required: true,
        extensions: {
          protobufField: {
            name: "required_int32_value",
            typeFullName: "int32",
          },
        },
      }),
      requiredInt64Value: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: {
            name: "required_int64_value",
            typeFullName: "int64",
          },
        },
      }),
      requiredUint32Value: t.field({
        type: "Int",
        required: true,
        extensions: {
          protobufField: {
            name: "required_uint32_value",
            typeFullName: "uint32",
          },
        },
      }),
      requiredUint64Value: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: {
            name: "required_uint64_value",
            typeFullName: "uint64",
          },
        },
      }),
      requiredSint32Value: t.field({
        type: "Int",
        required: true,
        extensions: {
          protobufField: {
            name: "required_sint32_value",
            typeFullName: "sint32",
          },
        },
      }),
      requiredSint64Value: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: {
            name: "required_sint64_value",
            typeFullName: "sint64",
          },
        },
      }),
      requiredFixed32Value: t.field({
        type: "Int",
        required: true,
        extensions: {
          protobufField: {
            name: "required_fixed32_value",
            typeFullName: "fixed32",
          },
        },
      }),
      requiredFixed64Value: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: {
            name: "required_fixed64_value",
            typeFullName: "fixed64",
          },
        },
      }),
      requiredSfixed32Value: t.field({
        type: "Int",
        required: true,
        extensions: {
          protobufField: {
            name: "required_sfixed32_value",
            typeFullName: "sfixed32",
          },
        },
      }),
      requiredSfixed64Value: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: {
            name: "required_sfixed64_value",
            typeFullName: "sfixed64",
          },
        },
      }),
      requiredBoolValue: t.field({
        type: "Boolean",
        required: true,
        extensions: {
          protobufField: { name: "required_bool_value", typeFullName: "bool" },
        },
      }),
      requiredStringValue: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: {
            name: "required_string_value",
            typeFullName: "string",
          },
        },
      }),
      requiredBytesValue: t.field({
        type: "Byte",
        required: true,
        extensions: {
          protobufField: {
            name: "required_bytes_value",
            typeFullName: "bytes",
          },
        },
      }),
      requiredDoubleValues: t.field({
        type: ["Float"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_double_values",
            typeFullName: "double",
          },
        },
      }),
      requiredFloatValues: t.field({
        type: ["Float"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_float_values",
            typeFullName: "float",
          },
        },
      }),
      requiredInt32Values: t.field({
        type: ["Int"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_int32_values",
            typeFullName: "int32",
          },
        },
      }),
      requiredInt64Values: t.field({
        type: ["String"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_int64_values",
            typeFullName: "int64",
          },
        },
      }),
      requiredUint32Values: t.field({
        type: ["Int"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_uint32_values",
            typeFullName: "uint32",
          },
        },
      }),
      requiredUint64Values: t.field({
        type: ["String"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_uint64_values",
            typeFullName: "uint64",
          },
        },
      }),
      requiredSint32Values: t.field({
        type: ["Int"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_sint32_values",
            typeFullName: "sint32",
          },
        },
      }),
      requiredSint64Values: t.field({
        type: ["String"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_sint64_values",
            typeFullName: "sint64",
          },
        },
      }),
      requiredFixed32Values: t.field({
        type: ["Int"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_fixed32_values",
            typeFullName: "fixed32",
          },
        },
      }),
      requiredFixed64Values: t.field({
        type: ["String"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_fixed64_values",
            typeFullName: "fixed64",
          },
        },
      }),
      requiredSfixed32Values: t.field({
        type: ["Int"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_sfixed32_values",
            typeFullName: "sfixed32",
          },
        },
      }),
      requiredSfixed64Values: t.field({
        type: ["String"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_sfixed64_values",
            typeFullName: "sfixed64",
          },
        },
      }),
      requiredBoolValues: t.field({
        type: ["Boolean"],
        required: { list: true, items: true },
        extensions: {
          protobufField: { name: "required_bool_values", typeFullName: "bool" },
        },
      }),
      requiredStringValues: t.field({
        type: ["String"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_string_values",
            typeFullName: "string",
          },
        },
      }),
      requiredBytesValues: t.field({
        type: ["Byte"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_bytes_values",
            typeFullName: "bytes",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.primitives.Primitives",
        name: "Primitives",
        package: "testapis.primitives",
      },
    },
  });

export type PrimitivesPartialInput$Shape = {
  requiredDoubleValue?: Primitives["requiredDoubleValue"] | null;
  requiredFloatValue?: Primitives["requiredFloatValue"] | null;
  requiredInt32Value?: Primitives["requiredInt32Value"] | null;
  requiredInt64Value?: Primitives["requiredInt64Value"] | null;
  requiredUint32Value?: Primitives["requiredUint32Value"] | null;
  requiredUint64Value?: Primitives["requiredUint64Value"] | null;
  requiredSint32Value?: Primitives["requiredSint32Value"] | null;
  requiredSint64Value?: Primitives["requiredSint64Value"] | null;
  requiredFixed32Value?: Primitives["requiredFixed32Value"] | null;
  requiredFixed64Value?: Primitives["requiredFixed64Value"] | null;
  requiredSfixed32Value?: Primitives["requiredSfixed32Value"] | null;
  requiredSfixed64Value?: Primitives["requiredSfixed64Value"] | null;
  requiredBoolValue?: Primitives["requiredBoolValue"] | null;
  requiredStringValue?: Primitives["requiredStringValue"] | null;
  requiredBytesValue?: Primitives["requiredBytesValue"] | null;
  requiredDoubleValues?: Primitives["requiredDoubleValues"] | null;
  requiredFloatValues?: Primitives["requiredFloatValues"] | null;
  requiredInt32Values?: Primitives["requiredInt32Values"] | null;
  requiredInt64Values?: Primitives["requiredInt64Values"] | null;
  requiredUint32Values?: Primitives["requiredUint32Values"] | null;
  requiredUint64Values?: Primitives["requiredUint64Values"] | null;
  requiredSint32Values?: Primitives["requiredSint32Values"] | null;
  requiredSint64Values?: Primitives["requiredSint64Values"] | null;
  requiredFixed32Values?: Primitives["requiredFixed32Values"] | null;
  requiredFixed64Values?: Primitives["requiredFixed64Values"] | null;
  requiredSfixed32Values?: Primitives["requiredSfixed32Values"] | null;
  requiredSfixed64Values?: Primitives["requiredSfixed64Values"] | null;
  requiredBoolValues?: Primitives["requiredBoolValues"] | null;
  requiredStringValues?: Primitives["requiredStringValues"] | null;
  requiredBytesValues?: Primitives["requiredBytesValues"] | null;
};

export const PrimitivesPartialInput$Ref: InputObjectRef<
  PrimitivesPartialInput$Shape
> = builder.inputRef<PrimitivesPartialInput$Shape>("PrimitivesPartialInput")
  .implement({
    fields: (t) => ({
      requiredDoubleValue: t.field({
        type: "Float",
        required: false,
        extensions: {
          protobufField: {
            name: "required_double_value",
            typeFullName: "double",
          },
        },
      }),
      requiredFloatValue: t.field({
        type: "Float",
        required: false,
        extensions: {
          protobufField: {
            name: "required_float_value",
            typeFullName: "float",
          },
        },
      }),
      requiredInt32Value: t.field({
        type: "Int",
        required: false,
        extensions: {
          protobufField: {
            name: "required_int32_value",
            typeFullName: "int32",
          },
        },
      }),
      requiredInt64Value: t.field({
        type: "String",
        required: false,
        extensions: {
          protobufField: {
            name: "required_int64_value",
            typeFullName: "int64",
          },
        },
      }),
      requiredUint32Value: t.field({
        type: "Int",
        required: false,
        extensions: {
          protobufField: {
            name: "required_uint32_value",
            typeFullName: "uint32",
          },
        },
      }),
      requiredUint64Value: t.field({
        type: "String",
        required: false,
        extensions: {
          protobufField: {
            name: "required_uint64_value",
            typeFullName: "uint64",
          },
        },
      }),
      requiredSint32Value: t.field({
        type: "Int",
        required: false,
        extensions: {
          protobufField: {
            name: "required_sint32_value",
            typeFullName: "sint32",
          },
        },
      }),
      requiredSint64Value: t.field({
        type: "String",
        required: false,
        extensions: {
          protobufField: {
            name: "required_sint64_value",
            typeFullName: "sint64",
          },
        },
      }),
      requiredFixed32Value: t.field({
        type: "Int",
        required: false,
        extensions: {
          protobufField: {
            name: "required_fixed32_value",
            typeFullName: "fixed32",
          },
        },
      }),
      requiredFixed64Value: t.field({
        type: "String",
        required: false,
        extensions: {
          protobufField: {
            name: "required_fixed64_value",
            typeFullName: "fixed64",
          },
        },
      }),
      requiredSfixed32Value: t.field({
        type: "Int",
        required: false,
        extensions: {
          protobufField: {
            name: "required_sfixed32_value",
            typeFullName: "sfixed32",
          },
        },
      }),
      requiredSfixed64Value: t.field({
        type: "String",
        required: false,
        extensions: {
          protobufField: {
            name: "required_sfixed64_value",
            typeFullName: "sfixed64",
          },
        },
      }),
      requiredBoolValue: t.field({
        type: "Boolean",
        required: false,
        extensions: {
          protobufField: { name: "required_bool_value", typeFullName: "bool" },
        },
      }),
      requiredStringValue: t.field({
        type: "String",
        required: false,
        extensions: {
          protobufField: {
            name: "required_string_value",
            typeFullName: "string",
          },
        },
      }),
      requiredBytesValue: t.field({
        type: "Byte",
        required: false,
        extensions: {
          protobufField: {
            name: "required_bytes_value",
            typeFullName: "bytes",
          },
        },
      }),
      requiredDoubleValues: t.field({
        type: ["Float"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "required_double_values",
            typeFullName: "double",
          },
        },
      }),
      requiredFloatValues: t.field({
        type: ["Float"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "required_float_values",
            typeFullName: "float",
          },
        },
      }),
      requiredInt32Values: t.field({
        type: ["Int"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "required_int32_values",
            typeFullName: "int32",
          },
        },
      }),
      requiredInt64Values: t.field({
        type: ["String"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "required_int64_values",
            typeFullName: "int64",
          },
        },
      }),
      requiredUint32Values: t.field({
        type: ["Int"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "required_uint32_values",
            typeFullName: "uint32",
          },
        },
      }),
      requiredUint64Values: t.field({
        type: ["String"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "required_uint64_values",
            typeFullName: "uint64",
          },
        },
      }),
      requiredSint32Values: t.field({
        type: ["Int"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "required_sint32_values",
            typeFullName: "sint32",
          },
        },
      }),
      requiredSint64Values: t.field({
        type: ["String"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "required_sint64_values",
            typeFullName: "sint64",
          },
        },
      }),
      requiredFixed32Values: t.field({
        type: ["Int"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "required_fixed32_values",
            typeFullName: "fixed32",
          },
        },
      }),
      requiredFixed64Values: t.field({
        type: ["String"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "required_fixed64_values",
            typeFullName: "fixed64",
          },
        },
      }),
      requiredSfixed32Values: t.field({
        type: ["Int"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "required_sfixed32_values",
            typeFullName: "sfixed32",
          },
        },
      }),
      requiredSfixed64Values: t.field({
        type: ["String"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "required_sfixed64_values",
            typeFullName: "sfixed64",
          },
        },
      }),
      requiredBoolValues: t.field({
        type: ["Boolean"],
        required: { list: false, items: true },
        extensions: {
          protobufField: { name: "required_bool_values", typeFullName: "bool" },
        },
      }),
      requiredStringValues: t.field({
        type: ["String"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "required_string_values",
            typeFullName: "string",
          },
        },
      }),
      requiredBytesValues: t.field({
        type: ["Byte"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "required_bytes_values",
            typeFullName: "bytes",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.primitives.Primitives",
        name: "Primitives",
        package: "testapis.primitives",
      },
    },
  });
",
    "name": "testapis/primitives/primitives.pb.pothos.ts",
  },
]
`;

exports[`'testapis.primitives' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/primitives/primitives.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import { Message, Primitives } from "./testapis/primitives/primitives";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    requiredPrimitives: t.field({
      type: Primitives$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.requiredPrimitives!;
      },
      extensions: {
        protobufField: {
          name: "required_primitives",
          typeFullName: "testapis.primitives.Primitives",
        },
      },
    }),
    optionalPrimitives: t.expose("optionalPrimitives", {
      type: Primitives$Ref,
      nullable: true,
      description: "Optional.",
      extensions: {
        protobufField: {
          name: "optional_primitives",
          typeFullName: "testapis.primitives.Primitives",
        },
      },
    }),
    requiredPrimitivesList: t.field({
      type: [Primitives$Ref],
      nullable: { list: false, items: false },
      description: "Required.",
      resolve: (source) => {
        return source.requiredPrimitivesList!;
      },
      extensions: {
        protobufField: {
          name: "required_primitives_list",
          typeFullName: "testapis.primitives.Primitives",
        },
      },
    }),
    optionalPrimitivesList: t.expose("optionalPrimitivesList", {
      type: [Primitives$Ref],
      nullable: { list: true, items: false },
      description: "Optional.",
      extensions: {
        protobufField: {
          name: "optional_primitives_list",
          typeFullName: "testapis.primitives.Primitives",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Message | { $type: string & {}; }).$type ===
      "testapis.primitives.Message";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.primitives.Message",
      name: "Message",
      package: "testapis.primitives",
    },
  },
});

export const Primitives$Ref = builder.objectRef<Primitives>("Primitives");
builder.objectType(Primitives$Ref, {
  name: "Primitives",
  fields: (t) => ({
    requiredDoubleValue: t.expose("requiredDoubleValue", {
      type: "Float",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_double_value",
          typeFullName: "double",
        },
      },
    }),
    requiredFloatValue: t.expose("requiredFloatValue", {
      type: "Float",
      nullable: false,
      extensions: {
        protobufField: { name: "required_float_value", typeFullName: "float" },
      },
    }),
    requiredInt32Value: t.expose("requiredInt32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: { name: "required_int32_value", typeFullName: "int32" },
      },
    }),
    requiredInt64Value: t.expose("requiredInt64Value", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: { name: "required_int64_value", typeFullName: "int64" },
      },
    }),
    requiredUint32Value: t.expose("requiredUint32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_uint32_value",
          typeFullName: "uint32",
        },
      },
    }),
    requiredUint64Value: t.expose("requiredUint64Value", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_uint64_value",
          typeFullName: "uint64",
        },
      },
    }),
    requiredSint32Value: t.expose("requiredSint32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_sint32_value",
          typeFullName: "sint32",
        },
      },
    }),
    requiredSint64Value: t.expose("requiredSint64Value", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_sint64_value",
          typeFullName: "sint64",
        },
      },
    }),
    requiredFixed32Value: t.expose("requiredFixed32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_fixed32_value",
          typeFullName: "fixed32",
        },
      },
    }),
    requiredFixed64Value: t.expose("requiredFixed64Value", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_fixed64_value",
          typeFullName: "fixed64",
        },
      },
    }),
    requiredSfixed32Value: t.expose("requiredSfixed32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_sfixed32_value",
          typeFullName: "sfixed32",
        },
      },
    }),
    requiredSfixed64Value: t.expose("requiredSfixed64Value", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_sfixed64_value",
          typeFullName: "sfixed64",
        },
      },
    }),
    requiredBoolValue: t.expose("requiredBoolValue", {
      type: "Boolean",
      nullable: false,
      extensions: {
        protobufField: { name: "required_bool_value", typeFullName: "bool" },
      },
    }),
    requiredStringValue: t.expose("requiredStringValue", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_string_value",
          typeFullName: "string",
        },
      },
    }),
    requiredBytesValue: t.field({
      type: "Byte",
      nullable: false,
      resolve: (source) => {
        return Buffer.from(source.requiredBytesValue);
      },
      extensions: {
        protobufField: { name: "required_bytes_value", typeFullName: "bytes" },
      },
    }),
    requiredDoubleValues: t.expose("requiredDoubleValues", {
      type: ["Float"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_double_values",
          typeFullName: "double",
        },
      },
    }),
    requiredFloatValues: t.expose("requiredFloatValues", {
      type: ["Float"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: { name: "required_float_values", typeFullName: "float" },
      },
    }),
    requiredInt32Values: t.expose("requiredInt32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: { name: "required_int32_values", typeFullName: "int32" },
      },
    }),
    requiredInt64Values: t.expose("requiredInt64Values", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: { name: "required_int64_values", typeFullName: "int64" },
      },
    }),
    requiredUint32Values: t.expose("requiredUint32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_uint32_values",
          typeFullName: "uint32",
        },
      },
    }),
    requiredUint64Values: t.expose("requiredUint64Values", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_uint64_values",
          typeFullName: "uint64",
        },
      },
    }),
    requiredSint32Values: t.expose("requiredSint32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_sint32_values",
          typeFullName: "sint32",
        },
      },
    }),
    requiredSint64Values: t.expose("requiredSint64Values", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_sint64_values",
          typeFullName: "sint64",
        },
      },
    }),
    requiredFixed32Values: t.expose("requiredFixed32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_fixed32_values",
          typeFullName: "fixed32",
        },
      },
    }),
    requiredFixed64Values: t.expose("requiredFixed64Values", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_fixed64_values",
          typeFullName: "fixed64",
        },
      },
    }),
    requiredSfixed32Values: t.expose("requiredSfixed32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_sfixed32_values",
          typeFullName: "sfixed32",
        },
      },
    }),
    requiredSfixed64Values: t.expose("requiredSfixed64Values", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_sfixed64_values",
          typeFullName: "sfixed64",
        },
      },
    }),
    requiredBoolValues: t.expose("requiredBoolValues", {
      type: ["Boolean"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: { name: "required_bool_values", typeFullName: "bool" },
      },
    }),
    requiredStringValues: t.expose("requiredStringValues", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_string_values",
          typeFullName: "string",
        },
      },
    }),
    requiredBytesValues: t.field({
      type: ["Byte"],
      nullable: { list: false, items: false },
      resolve: (source) => {
        return source.requiredBytesValues.map((v) => Buffer.from(v));
      },
      extensions: {
        protobufField: { name: "required_bytes_values", typeFullName: "bytes" },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Primitives | { $type: string & {}; }).$type ===
      "testapis.primitives.Primitives";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.primitives.Primitives",
      name: "Primitives",
      package: "testapis.primitives",
    },
  },
});

export type MessageInput$Shape = {
  requiredPrimitives: PrimitivesInput$Shape;
  optionalPrimitives?: PrimitivesInput$Shape | null;
  requiredPrimitivesList: Array<PrimitivesInput$Shape>;
  optionalPrimitivesList?: Array<PrimitivesInput$Shape> | null;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement({
    fields: (t) => ({
      requiredPrimitives: t.field({
        type: PrimitivesInput$Ref,
        required: true,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_primitives",
            typeFullName: "testapis.primitives.Primitives",
          },
        },
      }),
      optionalPrimitives: t.field({
        type: PrimitivesInput$Ref,
        required: false,
        description: "Optional.",
        extensions: {
          protobufField: {
            name: "optional_primitives",
            typeFullName: "testapis.primitives.Primitives",
          },
        },
      }),
      requiredPrimitivesList: t.field({
        type: [PrimitivesInput$Ref],
        required: { list: true, items: true },
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_primitives_list",
            typeFullName: "testapis.primitives.Primitives",
          },
        },
      }),
      optionalPrimitivesList: t.field({
        type: [PrimitivesInput$Ref],
        required: { list: false, items: true },
        description: "Optional.",
        extensions: {
          protobufField: {
            name: "optional_primitives_list",
            typeFullName: "testapis.primitives.Primitives",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.primitives.Message",
        name: "Message",
        package: "testapis.primitives",
      },
    },
  });

export type PrimitivesInput$Shape = {
  requiredDoubleValue: Primitives["requiredDoubleValue"];
  requiredFloatValue: Primitives["requiredFloatValue"];
  requiredInt32Value: Primitives["requiredInt32Value"];
  requiredInt64Value: Primitives["requiredInt64Value"];
  requiredUint32Value: Primitives["requiredUint32Value"];
  requiredUint64Value: Primitives["requiredUint64Value"];
  requiredSint32Value: Primitives["requiredSint32Value"];
  requiredSint64Value: Primitives["requiredSint64Value"];
  requiredFixed32Value: Primitives["requiredFixed32Value"];
  requiredFixed64Value: Primitives["requiredFixed64Value"];
  requiredSfixed32Value: Primitives["requiredSfixed32Value"];
  requiredSfixed64Value: Primitives["requiredSfixed64Value"];
  requiredBoolValue: Primitives["requiredBoolValue"];
  requiredStringValue: Primitives["requiredStringValue"];
  requiredBytesValue: Primitives["requiredBytesValue"];
  requiredDoubleValues: Primitives["requiredDoubleValues"];
  requiredFloatValues: Primitives["requiredFloatValues"];
  requiredInt32Values: Primitives["requiredInt32Values"];
  requiredInt64Values: Primitives["requiredInt64Values"];
  requiredUint32Values: Primitives["requiredUint32Values"];
  requiredUint64Values: Primitives["requiredUint64Values"];
  requiredSint32Values: Primitives["requiredSint32Values"];
  requiredSint64Values: Primitives["requiredSint64Values"];
  requiredFixed32Values: Primitives["requiredFixed32Values"];
  requiredFixed64Values: Primitives["requiredFixed64Values"];
  requiredSfixed32Values: Primitives["requiredSfixed32Values"];
  requiredSfixed64Values: Primitives["requiredSfixed64Values"];
  requiredBoolValues: Primitives["requiredBoolValues"];
  requiredStringValues: Primitives["requiredStringValues"];
  requiredBytesValues: Primitives["requiredBytesValues"];
};

export const PrimitivesInput$Ref: InputObjectRef<PrimitivesInput$Shape> =
  builder.inputRef<PrimitivesInput$Shape>("PrimitivesInput").implement({
    fields: (t) => ({
      requiredDoubleValue: t.field({
        type: "Float",
        required: true,
        extensions: {
          protobufField: {
            name: "required_double_value",
            typeFullName: "double",
          },
        },
      }),
      requiredFloatValue: t.field({
        type: "Float",
        required: true,
        extensions: {
          protobufField: {
            name: "required_float_value",
            typeFullName: "float",
          },
        },
      }),
      requiredInt32Value: t.field({
        type: "Int",
        required: true,
        extensions: {
          protobufField: {
            name: "required_int32_value",
            typeFullName: "int32",
          },
        },
      }),
      requiredInt64Value: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: {
            name: "required_int64_value",
            typeFullName: "int64",
          },
        },
      }),
      requiredUint32Value: t.field({
        type: "Int",
        required: true,
        extensions: {
          protobufField: {
            name: "required_uint32_value",
            typeFullName: "uint32",
          },
        },
      }),
      requiredUint64Value: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: {
            name: "required_uint64_value",
            typeFullName: "uint64",
          },
        },
      }),
      requiredSint32Value: t.field({
        type: "Int",
        required: true,
        extensions: {
          protobufField: {
            name: "required_sint32_value",
            typeFullName: "sint32",
          },
        },
      }),
      requiredSint64Value: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: {
            name: "required_sint64_value",
            typeFullName: "sint64",
          },
        },
      }),
      requiredFixed32Value: t.field({
        type: "Int",
        required: true,
        extensions: {
          protobufField: {
            name: "required_fixed32_value",
            typeFullName: "fixed32",
          },
        },
      }),
      requiredFixed64Value: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: {
            name: "required_fixed64_value",
            typeFullName: "fixed64",
          },
        },
      }),
      requiredSfixed32Value: t.field({
        type: "Int",
        required: true,
        extensions: {
          protobufField: {
            name: "required_sfixed32_value",
            typeFullName: "sfixed32",
          },
        },
      }),
      requiredSfixed64Value: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: {
            name: "required_sfixed64_value",
            typeFullName: "sfixed64",
          },
        },
      }),
      requiredBoolValue: t.field({
        type: "Boolean",
        required: true,
        extensions: {
          protobufField: { name: "required_bool_value", typeFullName: "bool" },
        },
      }),
      requiredStringValue: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: {
            name: "required_string_value",
            typeFullName: "string",
          },
        },
      }),
      requiredBytesValue: t.field({
        type: "Byte",
        required: true,
        extensions: {
          protobufField: {
            name: "required_bytes_value",
            typeFullName: "bytes",
          },
        },
      }),
      requiredDoubleValues: t.field({
        type: ["Float"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_double_values",
            typeFullName: "double",
          },
        },
      }),
      requiredFloatValues: t.field({
        type: ["Float"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_float_values",
            typeFullName: "float",
          },
        },
      }),
      requiredInt32Values: t.field({
        type: ["Int"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_int32_values",
            typeFullName: "int32",
          },
        },
      }),
      requiredInt64Values: t.field({
        type: ["String"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_int64_values",
            typeFullName: "int64",
          },
        },
      }),
      requiredUint32Values: t.field({
        type: ["Int"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_uint32_values",
            typeFullName: "uint32",
          },
        },
      }),
      requiredUint64Values: t.field({
        type: ["String"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_uint64_values",
            typeFullName: "uint64",
          },
        },
      }),
      requiredSint32Values: t.field({
        type: ["Int"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_sint32_values",
            typeFullName: "sint32",
          },
        },
      }),
      requiredSint64Values: t.field({
        type: ["String"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_sint64_values",
            typeFullName: "sint64",
          },
        },
      }),
      requiredFixed32Values: t.field({
        type: ["Int"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_fixed32_values",
            typeFullName: "fixed32",
          },
        },
      }),
      requiredFixed64Values: t.field({
        type: ["String"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_fixed64_values",
            typeFullName: "fixed64",
          },
        },
      }),
      requiredSfixed32Values: t.field({
        type: ["Int"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_sfixed32_values",
            typeFullName: "sfixed32",
          },
        },
      }),
      requiredSfixed64Values: t.field({
        type: ["String"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_sfixed64_values",
            typeFullName: "sfixed64",
          },
        },
      }),
      requiredBoolValues: t.field({
        type: ["Boolean"],
        required: { list: true, items: true },
        extensions: {
          protobufField: { name: "required_bool_values", typeFullName: "bool" },
        },
      }),
      requiredStringValues: t.field({
        type: ["String"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_string_values",
            typeFullName: "string",
          },
        },
      }),
      requiredBytesValues: t.field({
        type: ["Byte"],
        required: { list: true, items: true },
        extensions: {
          protobufField: {
            name: "required_bytes_values",
            typeFullName: "bytes",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.primitives.Primitives",
        name: "Primitives",
        package: "testapis.primitives",
      },
    },
  });
",
    "name": "testapis/primitives/primitives.pb.pothos.ts",
  },
]
`;

exports[`'testapis.proto3_optional' > generates files by plugin 'with graphql_type layout' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/proto3_optional/proto3_optional.proto

/* eslint-disable */

import { Message } from "@testapis/ts-proto/testapis/proto3_optional/proto3_optional";
import { builder } from "../../builder";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    requiredStringValue: t.expose("requiredStringValue", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_string_value",
          typeFullName: "string",
        },
      },
    }),
    optionalStringValue: t.expose("optionalStringValue", {
      type: "String",
      nullable: true,
      extensions: {
        protobufField: {
          name: "optional_string_value",
          typeFullName: "string",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Message | { $type: string & {}; }).$type ===
      "testapis.proto3_optional.Message";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.proto3_optional.Message",
      name: "Message",
      package: "testapis.proto3_optional",
    },
  },
});
",
    "name": "testapis/proto3_optional/Message.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/proto3_optional/proto3_optional.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { Message } from "@testapis/ts-proto/testapis/proto3_optional/proto3_optional";
import { builder } from "../../builder";

export type MessageInput$Shape = {
  requiredStringValue: Message["requiredStringValue"];
  optionalStringValue?: Message["optionalStringValue"] | null;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement({
    fields: (t) => ({
      requiredStringValue: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: {
            name: "required_string_value",
            typeFullName: "string",
          },
        },
      }),
      optionalStringValue: t.field({
        type: "String",
        required: false,
        extensions: {
          protobufField: {
            name: "optional_string_value",
            typeFullName: "string",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.proto3_optional.Message",
        name: "Message",
        package: "testapis.proto3_optional",
      },
    },
  });
",
    "name": "testapis/proto3_optional/MessageInput.pothos.ts",
  },
]
`;

exports[`'testapis.proto3_optional' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/proto3_optional/proto3_optional.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { Message } from "@testapis/ts-proto/testapis/proto3_optional/proto3_optional";
import { builder } from "../../builder";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    requiredStringValue: t.expose("requiredStringValue", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_string_value",
          typeFullName: "string",
        },
      },
    }),
    optionalStringValue: t.expose("optionalStringValue", {
      type: "String",
      nullable: true,
      extensions: {
        protobufField: {
          name: "optional_string_value",
          typeFullName: "string",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Message | { $type: string & {}; }).$type ===
      "testapis.proto3_optional.Message";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.proto3_optional.Message",
      name: "Message",
      package: "testapis.proto3_optional",
    },
  },
});

export type MessageInput$Shape = {
  requiredStringValue: Message["requiredStringValue"];
  optionalStringValue?: Message["optionalStringValue"] | null;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement({
    fields: (t) => ({
      requiredStringValue: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: {
            name: "required_string_value",
            typeFullName: "string",
          },
        },
      }),
      optionalStringValue: t.field({
        type: "String",
        required: false,
        extensions: {
          protobufField: {
            name: "optional_string_value",
            typeFullName: "string",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.proto3_optional.Message",
        name: "Message",
        package: "testapis.proto3_optional",
      },
    },
  });
",
    "name": "testapis/proto3_optional/proto3_optional.pb.pothos.ts",
  },
]
`;

exports[`'testapis.proto3_optional' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/proto3_optional/proto3_optional.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { Message } from "@testapis/ts-proto/testapis/proto3_optional/proto3_optional";
import { builder } from "../../builder";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    requiredStringValue: t.expose("requiredStringValue", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_string_value",
          typeFullName: "string",
        },
      },
    }),
    optionalStringValue: t.expose("optionalStringValue", {
      type: "String",
      nullable: true,
      extensions: {
        protobufField: {
          name: "optional_string_value",
          typeFullName: "string",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Message | { $type: string & {}; }).$type ===
      "testapis.proto3_optional.Message";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.proto3_optional.Message",
      name: "Message",
      package: "testapis.proto3_optional",
    },
  },
});

export type MessageInput$Shape = {
  requiredStringValue: Message["requiredStringValue"];
  optionalStringValue?: Message["optionalStringValue"] | null;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement({
    fields: (t) => ({
      requiredStringValue: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: {
            name: "required_string_value",
            typeFullName: "string",
          },
        },
      }),
      optionalStringValue: t.field({
        type: "String",
        required: false,
        extensions: {
          protobufField: {
            name: "optional_string_value",
            typeFullName: "string",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.proto3_optional.Message",
        name: "Message",
        package: "testapis.proto3_optional",
      },
    },
  });

export type MessagePartialInput$Shape = {
  requiredStringValue?: Message["requiredStringValue"] | null;
  optionalStringValue?: Message["optionalStringValue"] | null;
};

export const MessagePartialInput$Ref: InputObjectRef<
  MessagePartialInput$Shape
> = builder.inputRef<MessagePartialInput$Shape>("MessagePartialInput")
  .implement({
    fields: (t) => ({
      requiredStringValue: t.field({
        type: "String",
        required: false,
        extensions: {
          protobufField: {
            name: "required_string_value",
            typeFullName: "string",
          },
        },
      }),
      optionalStringValue: t.field({
        type: "String",
        required: false,
        extensions: {
          protobufField: {
            name: "optional_string_value",
            typeFullName: "string",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.proto3_optional.Message",
        name: "Message",
        package: "testapis.proto3_optional",
      },
    },
  });
",
    "name": "testapis/proto3_optional/proto3_optional.pb.pothos.ts",
  },
]
`;

exports[`'testapis.proto3_optional' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/proto3_optional/proto3_optional.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import { Message } from "./testapis/proto3_optional/proto3_optional";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    requiredStringValue: t.expose("requiredStringValue", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_string_value",
          typeFullName: "string",
        },
      },
    }),
    optionalStringValue: t.expose("optionalStringValue", {
      type: "String",
      nullable: true,
      extensions: {
        protobufField: {
          name: "optional_string_value",
          typeFullName: "string",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Message | { $type: string & {}; }).$type ===
      "testapis.proto3_optional.Message";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.proto3_optional.Message",
      name: "Message",
      package: "testapis.proto3_optional",
    },
  },
});

export type MessageInput$Shape = {
  requiredStringValue: Message["requiredStringValue"];
  optionalStringValue?: Message["optionalStringValue"] | null;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement({
    fields: (t) => ({
      requiredStringValue: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: {
            name: "required_string_value",
            typeFullName: "string",
          },
        },
      }),
      optionalStringValue: t.field({
        type: "String",
        required: false,
        extensions: {
          protobufField: {
            name: "optional_string_value",
            typeFullName: "string",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.proto3_optional.Message",
        name: "Message",
        package: "testapis.proto3_optional",
      },
    },
  });
",
    "name": "testapis/proto3_optional/proto3_optional.pb.pothos.ts",
  },
]
`;

exports[`'testapis.wktypes' > generates files by plugin 'with graphql_type layout' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/wktypes/well_known_types.proto

/* eslint-disable */

import { Message } from "@testapis/ts-proto/testapis/wktypes/well_known_types";
import { builder } from "../../builder";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    timestamp: t.expose("timestamp", {
      type: "DateTime",
      nullable: true,
      extensions: {
        protobufField: {
          name: "timestamp",
          typeFullName: "google.protobuf.Timestamp",
        },
      },
    }),
    int32Value: t.expose("int32Value", {
      type: "Int",
      nullable: true,
      extensions: {
        protobufField: {
          name: "int32_value",
          typeFullName: "google.protobuf.Int32Value",
        },
      },
    }),
    int64Value: t.expose("int64Value", {
      type: "String",
      nullable: true,
      extensions: {
        protobufField: {
          name: "int64_value",
          typeFullName: "google.protobuf.Int64Value",
        },
      },
    }),
    uint32Value: t.expose("uint32Value", {
      type: "Int",
      nullable: true,
      extensions: {
        protobufField: {
          name: "uint32_value",
          typeFullName: "google.protobuf.UInt32Value",
        },
      },
    }),
    uint64Value: t.expose("uint64Value", {
      type: "String",
      nullable: true,
      extensions: {
        protobufField: {
          name: "uint64_value",
          typeFullName: "google.protobuf.UInt64Value",
        },
      },
    }),
    floatValue: t.expose("floatValue", {
      type: "Float",
      nullable: true,
      extensions: {
        protobufField: {
          name: "float_value",
          typeFullName: "google.protobuf.FloatValue",
        },
      },
    }),
    doubleValue: t.expose("doubleValue", {
      type: "Float",
      nullable: true,
      extensions: {
        protobufField: {
          name: "double_value",
          typeFullName: "google.protobuf.DoubleValue",
        },
      },
    }),
    boolValue: t.expose("boolValue", {
      type: "Boolean",
      nullable: true,
      extensions: {
        protobufField: {
          name: "bool_value",
          typeFullName: "google.protobuf.BoolValue",
        },
      },
    }),
    stringValue: t.expose("stringValue", {
      type: "String",
      nullable: true,
      extensions: {
        protobufField: {
          name: "string_value",
          typeFullName: "google.protobuf.StringValue",
        },
      },
    }),
    bytesValue: t.field({
      type: "Byte",
      nullable: true,
      resolve: (source) => {
        return source.bytesValue == null
          ? null
          : Buffer.from(source.bytesValue);
      },
      extensions: {
        protobufField: {
          name: "bytes_value",
          typeFullName: "google.protobuf.BytesValue",
        },
      },
    }),
    timestamps: t.expose("timestamps", {
      type: ["DateTime"],
      nullable: { list: true, items: false },
      extensions: {
        protobufField: {
          name: "timestamps",
          typeFullName: "google.protobuf.Timestamp",
        },
      },
    }),
    int32Values: t.expose("int32Values", {
      type: ["Int"],
      nullable: { list: true, items: false },
      extensions: {
        protobufField: {
          name: "int32_values",
          typeFullName: "google.protobuf.Int32Value",
        },
      },
    }),
    int64Values: t.expose("int64Values", {
      type: ["String"],
      nullable: { list: true, items: false },
      extensions: {
        protobufField: {
          name: "int64_values",
          typeFullName: "google.protobuf.Int64Value",
        },
      },
    }),
    uint32Values: t.expose("uint32Values", {
      type: ["Int"],
      nullable: { list: true, items: false },
      extensions: {
        protobufField: {
          name: "uint32_values",
          typeFullName: "google.protobuf.UInt32Value",
        },
      },
    }),
    uint64Values: t.expose("uint64Values", {
      type: ["String"],
      nullable: { list: true, items: false },
      extensions: {
        protobufField: {
          name: "uint64_values",
          typeFullName: "google.protobuf.UInt64Value",
        },
      },
    }),
    floatValues: t.expose("floatValues", {
      type: ["Float"],
      nullable: { list: true, items: false },
      extensions: {
        protobufField: {
          name: "float_values",
          typeFullName: "google.protobuf.FloatValue",
        },
      },
    }),
    doubleValues: t.expose("doubleValues", {
      type: ["Float"],
      nullable: { list: true, items: false },
      extensions: {
        protobufField: {
          name: "double_values",
          typeFullName: "google.protobuf.DoubleValue",
        },
      },
    }),
    boolValues: t.expose("boolValues", {
      type: ["Boolean"],
      nullable: { list: true, items: false },
      extensions: {
        protobufField: {
          name: "bool_values",
          typeFullName: "google.protobuf.BoolValue",
        },
      },
    }),
    stringValues: t.expose("stringValues", {
      type: ["String"],
      nullable: { list: true, items: false },
      extensions: {
        protobufField: {
          name: "string_values",
          typeFullName: "google.protobuf.StringValue",
        },
      },
    }),
    bytesValues: t.field({
      type: ["Byte"],
      nullable: { list: true, items: false },
      resolve: (source) => {
        return source.bytesValues.map((v) => Buffer.from(v));
      },
      extensions: {
        protobufField: {
          name: "bytes_values",
          typeFullName: "google.protobuf.BytesValue",
        },
      },
    }),
    requiredTimestamp: t.field({
      type: "DateTime",
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.requiredTimestamp!;
      },
      extensions: {
        protobufField: {
          name: "required_timestamp",
          typeFullName: "google.protobuf.Timestamp",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Message | { $type: string & {}; }).$type ===
      "testapis.wktypes.Message";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.wktypes.Message",
      name: "Message",
      package: "testapis.wktypes",
    },
  },
});
",
    "name": "testapis/wktypes/Message.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/wktypes/well_known_types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { Message } from "@testapis/ts-proto/testapis/wktypes/well_known_types";
import { builder } from "../../builder";

export type MessageInput$Shape = {
  timestamp?: Message["timestamp"] | null;
  int32Value?: Message["int32Value"] | null;
  int64Value?: Message["int64Value"] | null;
  uint32Value?: Message["uint32Value"] | null;
  uint64Value?: Message["uint64Value"] | null;
  floatValue?: Message["floatValue"] | null;
  doubleValue?: Message["doubleValue"] | null;
  boolValue?: Message["boolValue"] | null;
  stringValue?: Message["stringValue"] | null;
  bytesValue?: Message["bytesValue"] | null;
  timestamps?: Message["timestamps"] | null;
  int32Values?: Message["int32Values"] | null;
  int64Values?: Message["int64Values"] | null;
  uint32Values?: Message["uint32Values"] | null;
  uint64Values?: Message["uint64Values"] | null;
  floatValues?: Message["floatValues"] | null;
  doubleValues?: Message["doubleValues"] | null;
  boolValues?: Message["boolValues"] | null;
  stringValues?: Message["stringValues"] | null;
  bytesValues?: Message["bytesValues"] | null;
  requiredTimestamp: NonNullable<Message["requiredTimestamp"]>;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement({
    fields: (t) => ({
      timestamp: t.field({
        type: "DateTime",
        required: false,
        extensions: {
          protobufField: {
            name: "timestamp",
            typeFullName: "google.protobuf.Timestamp",
          },
        },
      }),
      int32Value: t.field({
        type: "Int",
        required: false,
        extensions: {
          protobufField: {
            name: "int32_value",
            typeFullName: "google.protobuf.Int32Value",
          },
        },
      }),
      int64Value: t.field({
        type: "String",
        required: false,
        extensions: {
          protobufField: {
            name: "int64_value",
            typeFullName: "google.protobuf.Int64Value",
          },
        },
      }),
      uint32Value: t.field({
        type: "Int",
        required: false,
        extensions: {
          protobufField: {
            name: "uint32_value",
            typeFullName: "google.protobuf.UInt32Value",
          },
        },
      }),
      uint64Value: t.field({
        type: "String",
        required: false,
        extensions: {
          protobufField: {
            name: "uint64_value",
            typeFullName: "google.protobuf.UInt64Value",
          },
        },
      }),
      floatValue: t.field({
        type: "Float",
        required: false,
        extensions: {
          protobufField: {
            name: "float_value",
            typeFullName: "google.protobuf.FloatValue",
          },
        },
      }),
      doubleValue: t.field({
        type: "Float",
        required: false,
        extensions: {
          protobufField: {
            name: "double_value",
            typeFullName: "google.protobuf.DoubleValue",
          },
        },
      }),
      boolValue: t.field({
        type: "Boolean",
        required: false,
        extensions: {
          protobufField: {
            name: "bool_value",
            typeFullName: "google.protobuf.BoolValue",
          },
        },
      }),
      stringValue: t.field({
        type: "String",
        required: false,
        extensions: {
          protobufField: {
            name: "string_value",
            typeFullName: "google.protobuf.StringValue",
          },
        },
      }),
      bytesValue: t.field({
        type: "Byte",
        required: false,
        extensions: {
          protobufField: {
            name: "bytes_value",
            typeFullName: "google.protobuf.BytesValue",
          },
        },
      }),
      timestamps: t.field({
        type: ["DateTime"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "timestamps",
            typeFullName: "google.protobuf.Timestamp",
          },
        },
      }),
      int32Values: t.field({
        type: ["Int"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "int32_values",
            typeFullName: "google.protobuf.Int32Value",
          },
        },
      }),
      int64Values: t.field({
        type: ["String"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "int64_values",
            typeFullName: "google.protobuf.Int64Value",
          },
        },
      }),
      uint32Values: t.field({
        type: ["Int"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "uint32_values",
            typeFullName: "google.protobuf.UInt32Value",
          },
        },
      }),
      uint64Values: t.field({
        type: ["String"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "uint64_values",
            typeFullName: "google.protobuf.UInt64Value",
          },
        },
      }),
      floatValues: t.field({
        type: ["Float"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "float_values",
            typeFullName: "google.protobuf.FloatValue",
          },
        },
      }),
      doubleValues: t.field({
        type: ["Float"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "double_values",
            typeFullName: "google.protobuf.DoubleValue",
          },
        },
      }),
      boolValues: t.field({
        type: ["Boolean"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "bool_values",
            typeFullName: "google.protobuf.BoolValue",
          },
        },
      }),
      stringValues: t.field({
        type: ["String"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "string_values",
            typeFullName: "google.protobuf.StringValue",
          },
        },
      }),
      bytesValues: t.field({
        type: ["Byte"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "bytes_values",
            typeFullName: "google.protobuf.BytesValue",
          },
        },
      }),
      requiredTimestamp: t.field({
        type: "DateTime",
        required: true,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_timestamp",
            typeFullName: "google.protobuf.Timestamp",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.wktypes.Message",
        name: "Message",
        package: "testapis.wktypes",
      },
    },
  });
",
    "name": "testapis/wktypes/MessageInput.pothos.ts",
  },
]
`;

exports[`'testapis.wktypes' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/wktypes/well_known_types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { Message } from "@testapis/ts-proto/testapis/wktypes/well_known_types";
import { builder } from "../../builder";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    timestamp: t.expose("timestamp", {
      type: "DateTime",
      nullable: true,
      extensions: {
        protobufField: {
          name: "timestamp",
          typeFullName: "google.protobuf.Timestamp",
        },
      },
    }),
    int32Value: t.expose("int32Value", {
      type: "Int",
      nullable: true,
      extensions: {
        protobufField: {
          name: "int32_value",
          typeFullName: "google.protobuf.Int32Value",
        },
      },
    }),
    int64Value: t.expose("int64Value", {
      type: "String",
      nullable: true,
      extensions: {
        protobufField: {
          name: "int64_value",
          typeFullName: "google.protobuf.Int64Value",
        },
      },
    }),
    uint32Value: t.expose("uint32Value", {
      type: "Int",
      nullable: true,
      extensions: {
        protobufField: {
          name: "uint32_value",
          typeFullName: "google.protobuf.UInt32Value",
        },
      },
    }),
    uint64Value: t.expose("uint64Value", {
      type: "String",
      nullable: true,
      extensions: {
        protobufField: {
          name: "uint64_value",
          typeFullName: "google.protobuf.UInt64Value",
        },
      },
    }),
    floatValue: t.expose("floatValue", {
      type: "Float",
      nullable: true,
      extensions: {
        protobufField: {
          name: "float_value",
          typeFullName: "google.protobuf.FloatValue",
        },
      },
    }),
    doubleValue: t.expose("doubleValue", {
      type: "Float",
      nullable: true,
      extensions: {
        protobufField: {
          name: "double_value",
          typeFullName: "google.protobuf.DoubleValue",
        },
      },
    }),
    boolValue: t.expose("boolValue", {
      type: "Boolean",
      nullable: true,
      extensions: {
        protobufField: {
          name: "bool_value",
          typeFullName: "google.protobuf.BoolValue",
        },
      },
    }),
    stringValue: t.expose("stringValue", {
      type: "String",
      nullable: true,
      extensions: {
        protobufField: {
          name: "string_value",
          typeFullName: "google.protobuf.StringValue",
        },
      },
    }),
    bytesValue: t.field({
      type: "Byte",
      nullable: true,
      resolve: (source) => {
        return source.bytesValue == null
          ? null
          : Buffer.from(source.bytesValue);
      },
      extensions: {
        protobufField: {
          name: "bytes_value",
          typeFullName: "google.protobuf.BytesValue",
        },
      },
    }),
    timestamps: t.expose("timestamps", {
      type: ["DateTime"],
      nullable: { list: true, items: false },
      extensions: {
        protobufField: {
          name: "timestamps",
          typeFullName: "google.protobuf.Timestamp",
        },
      },
    }),
    int32Values: t.expose("int32Values", {
      type: ["Int"],
      nullable: { list: true, items: false },
      extensions: {
        protobufField: {
          name: "int32_values",
          typeFullName: "google.protobuf.Int32Value",
        },
      },
    }),
    int64Values: t.expose("int64Values", {
      type: ["String"],
      nullable: { list: true, items: false },
      extensions: {
        protobufField: {
          name: "int64_values",
          typeFullName: "google.protobuf.Int64Value",
        },
      },
    }),
    uint32Values: t.expose("uint32Values", {
      type: ["Int"],
      nullable: { list: true, items: false },
      extensions: {
        protobufField: {
          name: "uint32_values",
          typeFullName: "google.protobuf.UInt32Value",
        },
      },
    }),
    uint64Values: t.expose("uint64Values", {
      type: ["String"],
      nullable: { list: true, items: false },
      extensions: {
        protobufField: {
          name: "uint64_values",
          typeFullName: "google.protobuf.UInt64Value",
        },
      },
    }),
    floatValues: t.expose("floatValues", {
      type: ["Float"],
      nullable: { list: true, items: false },
      extensions: {
        protobufField: {
          name: "float_values",
          typeFullName: "google.protobuf.FloatValue",
        },
      },
    }),
    doubleValues: t.expose("doubleValues", {
      type: ["Float"],
      nullable: { list: true, items: false },
      extensions: {
        protobufField: {
          name: "double_values",
          typeFullName: "google.protobuf.DoubleValue",
        },
      },
    }),
    boolValues: t.expose("boolValues", {
      type: ["Boolean"],
      nullable: { list: true, items: false },
      extensions: {
        protobufField: {
          name: "bool_values",
          typeFullName: "google.protobuf.BoolValue",
        },
      },
    }),
    stringValues: t.expose("stringValues", {
      type: ["String"],
      nullable: { list: true, items: false },
      extensions: {
        protobufField: {
          name: "string_values",
          typeFullName: "google.protobuf.StringValue",
        },
      },
    }),
    bytesValues: t.field({
      type: ["Byte"],
      nullable: { list: true, items: false },
      resolve: (source) => {
        return source.bytesValues.map((v) => Buffer.from(v));
      },
      extensions: {
        protobufField: {
          name: "bytes_values",
          typeFullName: "google.protobuf.BytesValue",
        },
      },
    }),
    requiredTimestamp: t.field({
      type: "DateTime",
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.requiredTimestamp!;
      },
      extensions: {
        protobufField: {
          name: "required_timestamp",
          typeFullName: "google.protobuf.Timestamp",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Message | { $type: string & {}; }).$type ===
      "testapis.wktypes.Message";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.wktypes.Message",
      name: "Message",
      package: "testapis.wktypes",
    },
  },
});

export type MessageInput$Shape = {
  timestamp?: Message["timestamp"] | null;
  int32Value?: Message["int32Value"] | null;
  int64Value?: Message["int64Value"] | null;
  uint32Value?: Message["uint32Value"] | null;
  uint64Value?: Message["uint64Value"] | null;
  floatValue?: Message["floatValue"] | null;
  doubleValue?: Message["doubleValue"] | null;
  boolValue?: Message["boolValue"] | null;
  stringValue?: Message["stringValue"] | null;
  bytesValue?: Message["bytesValue"] | null;
  timestamps?: Message["timestamps"] | null;
  int32Values?: Message["int32Values"] | null;
  int64Values?: Message["int64Values"] | null;
  uint32Values?: Message["uint32Values"] | null;
  uint64Values?: Message["uint64Values"] | null;
  floatValues?: Message["floatValues"] | null;
  doubleValues?: Message["doubleValues"] | null;
  boolValues?: Message["boolValues"] | null;
  stringValues?: Message["stringValues"] | null;
  bytesValues?: Message["bytesValues"] | null;
  requiredTimestamp: NonNullable<Message["requiredTimestamp"]>;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement({
    fields: (t) => ({
      timestamp: t.field({
        type: "DateTime",
        required: false,
        extensions: {
          protobufField: {
            name: "timestamp",
            typeFullName: "google.protobuf.Timestamp",
          },
        },
      }),
      int32Value: t.field({
        type: "Int",
        required: false,
        extensions: {
          protobufField: {
            name: "int32_value",
            typeFullName: "google.protobuf.Int32Value",
          },
        },
      }),
      int64Value: t.field({
        type: "String",
        required: false,
        extensions: {
          protobufField: {
            name: "int64_value",
            typeFullName: "google.protobuf.Int64Value",
          },
        },
      }),
      uint32Value: t.field({
        type: "Int",
        required: false,
        extensions: {
          protobufField: {
            name: "uint32_value",
            typeFullName: "google.protobuf.UInt32Value",
          },
        },
      }),
      uint64Value: t.field({
        type: "String",
        required: false,
        extensions: {
          protobufField: {
            name: "uint64_value",
            typeFullName: "google.protobuf.UInt64Value",
          },
        },
      }),
      floatValue: t.field({
        type: "Float",
        required: false,
        extensions: {
          protobufField: {
            name: "float_value",
            typeFullName: "google.protobuf.FloatValue",
          },
        },
      }),
      doubleValue: t.field({
        type: "Float",
        required: false,
        extensions: {
          protobufField: {
            name: "double_value",
            typeFullName: "google.protobuf.DoubleValue",
          },
        },
      }),
      boolValue: t.field({
        type: "Boolean",
        required: false,
        extensions: {
          protobufField: {
            name: "bool_value",
            typeFullName: "google.protobuf.BoolValue",
          },
        },
      }),
      stringValue: t.field({
        type: "String",
        required: false,
        extensions: {
          protobufField: {
            name: "string_value",
            typeFullName: "google.protobuf.StringValue",
          },
        },
      }),
      bytesValue: t.field({
        type: "Byte",
        required: false,
        extensions: {
          protobufField: {
            name: "bytes_value",
            typeFullName: "google.protobuf.BytesValue",
          },
        },
      }),
      timestamps: t.field({
        type: ["DateTime"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "timestamps",
            typeFullName: "google.protobuf.Timestamp",
          },
        },
      }),
      int32Values: t.field({
        type: ["Int"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "int32_values",
            typeFullName: "google.protobuf.Int32Value",
          },
        },
      }),
      int64Values: t.field({
        type: ["String"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "int64_values",
            typeFullName: "google.protobuf.Int64Value",
          },
        },
      }),
      uint32Values: t.field({
        type: ["Int"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "uint32_values",
            typeFullName: "google.protobuf.UInt32Value",
          },
        },
      }),
      uint64Values: t.field({
        type: ["String"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "uint64_values",
            typeFullName: "google.protobuf.UInt64Value",
          },
        },
      }),
      floatValues: t.field({
        type: ["Float"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "float_values",
            typeFullName: "google.protobuf.FloatValue",
          },
        },
      }),
      doubleValues: t.field({
        type: ["Float"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "double_values",
            typeFullName: "google.protobuf.DoubleValue",
          },
        },
      }),
      boolValues: t.field({
        type: ["Boolean"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "bool_values",
            typeFullName: "google.protobuf.BoolValue",
          },
        },
      }),
      stringValues: t.field({
        type: ["String"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "string_values",
            typeFullName: "google.protobuf.StringValue",
          },
        },
      }),
      bytesValues: t.field({
        type: ["Byte"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "bytes_values",
            typeFullName: "google.protobuf.BytesValue",
          },
        },
      }),
      requiredTimestamp: t.field({
        type: "DateTime",
        required: true,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_timestamp",
            typeFullName: "google.protobuf.Timestamp",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.wktypes.Message",
        name: "Message",
        package: "testapis.wktypes",
      },
    },
  });
",
    "name": "testapis/wktypes/well_known_types.pb.pothos.ts",
  },
]
`;

exports[`'testapis.wktypes' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/wktypes/well_known_types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { Message } from "@testapis/ts-proto/testapis/wktypes/well_known_types";
import { builder } from "../../builder";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    timestamp: t.expose("timestamp", {
      type: "DateTime",
      nullable: true,
      extensions: {
        protobufField: {
          name: "timestamp",
          typeFullName: "google.protobuf.Timestamp",
        },
      },
    }),
    int32Value: t.expose("int32Value", {
      type: "Int",
      nullable: true,
      extensions: {
        protobufField: {
          name: "int32_value",
          typeFullName: "google.protobuf.Int32Value",
        },
      },
    }),
    int64Value: t.expose("int64Value", {
      type: "String",
      nullable: true,
      extensions: {
        protobufField: {
          name: "int64_value",
          typeFullName: "google.protobuf.Int64Value",
        },
      },
    }),
    uint32Value: t.expose("uint32Value", {
      type: "Int",
      nullable: true,
      extensions: {
        protobufField: {
          name: "uint32_value",
          typeFullName: "google.protobuf.UInt32Value",
        },
      },
    }),
    uint64Value: t.expose("uint64Value", {
      type: "String",
      nullable: true,
      extensions: {
        protobufField: {
          name: "uint64_value",
          typeFullName: "google.protobuf.UInt64Value",
        },
      },
    }),
    floatValue: t.expose("floatValue", {
      type: "Float",
      nullable: true,
      extensions: {
        protobufField: {
          name: "float_value",
          typeFullName: "google.protobuf.FloatValue",
        },
      },
    }),
    doubleValue: t.expose("doubleValue", {
      type: "Float",
      nullable: true,
      extensions: {
        protobufField: {
          name: "double_value",
          typeFullName: "google.protobuf.DoubleValue",
        },
      },
    }),
    boolValue: t.expose("boolValue", {
      type: "Boolean",
      nullable: true,
      extensions: {
        protobufField: {
          name: "bool_value",
          typeFullName: "google.protobuf.BoolValue",
        },
      },
    }),
    stringValue: t.expose("stringValue", {
      type: "String",
      nullable: true,
      extensions: {
        protobufField: {
          name: "string_value",
          typeFullName: "google.protobuf.StringValue",
        },
      },
    }),
    bytesValue: t.field({
      type: "Byte",
      nullable: true,
      resolve: (source) => {
        return source.bytesValue == null
          ? null
          : Buffer.from(source.bytesValue);
      },
      extensions: {
        protobufField: {
          name: "bytes_value",
          typeFullName: "google.protobuf.BytesValue",
        },
      },
    }),
    timestamps: t.expose("timestamps", {
      type: ["DateTime"],
      nullable: { list: true, items: false },
      extensions: {
        protobufField: {
          name: "timestamps",
          typeFullName: "google.protobuf.Timestamp",
        },
      },
    }),
    int32Values: t.expose("int32Values", {
      type: ["Int"],
      nullable: { list: true, items: false },
      extensions: {
        protobufField: {
          name: "int32_values",
          typeFullName: "google.protobuf.Int32Value",
        },
      },
    }),
    int64Values: t.expose("int64Values", {
      type: ["String"],
      nullable: { list: true, items: false },
      extensions: {
        protobufField: {
          name: "int64_values",
          typeFullName: "google.protobuf.Int64Value",
        },
      },
    }),
    uint32Values: t.expose("uint32Values", {
      type: ["Int"],
      nullable: { list: true, items: false },
      extensions: {
        protobufField: {
          name: "uint32_values",
          typeFullName: "google.protobuf.UInt32Value",
        },
      },
    }),
    uint64Values: t.expose("uint64Values", {
      type: ["String"],
      nullable: { list: true, items: false },
      extensions: {
        protobufField: {
          name: "uint64_values",
          typeFullName: "google.protobuf.UInt64Value",
        },
      },
    }),
    floatValues: t.expose("floatValues", {
      type: ["Float"],
      nullable: { list: true, items: false },
      extensions: {
        protobufField: {
          name: "float_values",
          typeFullName: "google.protobuf.FloatValue",
        },
      },
    }),
    doubleValues: t.expose("doubleValues", {
      type: ["Float"],
      nullable: { list: true, items: false },
      extensions: {
        protobufField: {
          name: "double_values",
          typeFullName: "google.protobuf.DoubleValue",
        },
      },
    }),
    boolValues: t.expose("boolValues", {
      type: ["Boolean"],
      nullable: { list: true, items: false },
      extensions: {
        protobufField: {
          name: "bool_values",
          typeFullName: "google.protobuf.BoolValue",
        },
      },
    }),
    stringValues: t.expose("stringValues", {
      type: ["String"],
      nullable: { list: true, items: false },
      extensions: {
        protobufField: {
          name: "string_values",
          typeFullName: "google.protobuf.StringValue",
        },
      },
    }),
    bytesValues: t.field({
      type: ["Byte"],
      nullable: { list: true, items: false },
      resolve: (source) => {
        return source.bytesValues.map((v) => Buffer.from(v));
      },
      extensions: {
        protobufField: {
          name: "bytes_values",
          typeFullName: "google.protobuf.BytesValue",
        },
      },
    }),
    requiredTimestamp: t.field({
      type: "DateTime",
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.requiredTimestamp!;
      },
      extensions: {
        protobufField: {
          name: "required_timestamp",
          typeFullName: "google.protobuf.Timestamp",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Message | { $type: string & {}; }).$type ===
      "testapis.wktypes.Message";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.wktypes.Message",
      name: "Message",
      package: "testapis.wktypes",
    },
  },
});

export type MessageInput$Shape = {
  timestamp?: Message["timestamp"] | null;
  int32Value?: Message["int32Value"] | null;
  int64Value?: Message["int64Value"] | null;
  uint32Value?: Message["uint32Value"] | null;
  uint64Value?: Message["uint64Value"] | null;
  floatValue?: Message["floatValue"] | null;
  doubleValue?: Message["doubleValue"] | null;
  boolValue?: Message["boolValue"] | null;
  stringValue?: Message["stringValue"] | null;
  bytesValue?: Message["bytesValue"] | null;
  timestamps?: Message["timestamps"] | null;
  int32Values?: Message["int32Values"] | null;
  int64Values?: Message["int64Values"] | null;
  uint32Values?: Message["uint32Values"] | null;
  uint64Values?: Message["uint64Values"] | null;
  floatValues?: Message["floatValues"] | null;
  doubleValues?: Message["doubleValues"] | null;
  boolValues?: Message["boolValues"] | null;
  stringValues?: Message["stringValues"] | null;
  bytesValues?: Message["bytesValues"] | null;
  requiredTimestamp: NonNullable<Message["requiredTimestamp"]>;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement({
    fields: (t) => ({
      timestamp: t.field({
        type: "DateTime",
        required: false,
        extensions: {
          protobufField: {
            name: "timestamp",
            typeFullName: "google.protobuf.Timestamp",
          },
        },
      }),
      int32Value: t.field({
        type: "Int",
        required: false,
        extensions: {
          protobufField: {
            name: "int32_value",
            typeFullName: "google.protobuf.Int32Value",
          },
        },
      }),
      int64Value: t.field({
        type: "String",
        required: false,
        extensions: {
          protobufField: {
            name: "int64_value",
            typeFullName: "google.protobuf.Int64Value",
          },
        },
      }),
      uint32Value: t.field({
        type: "Int",
        required: false,
        extensions: {
          protobufField: {
            name: "uint32_value",
            typeFullName: "google.protobuf.UInt32Value",
          },
        },
      }),
      uint64Value: t.field({
        type: "String",
        required: false,
        extensions: {
          protobufField: {
            name: "uint64_value",
            typeFullName: "google.protobuf.UInt64Value",
          },
        },
      }),
      floatValue: t.field({
        type: "Float",
        required: false,
        extensions: {
          protobufField: {
            name: "float_value",
            typeFullName: "google.protobuf.FloatValue",
          },
        },
      }),
      doubleValue: t.field({
        type: "Float",
        required: false,
        extensions: {
          protobufField: {
            name: "double_value",
            typeFullName: "google.protobuf.DoubleValue",
          },
        },
      }),
      boolValue: t.field({
        type: "Boolean",
        required: false,
        extensions: {
          protobufField: {
            name: "bool_value",
            typeFullName: "google.protobuf.BoolValue",
          },
        },
      }),
      stringValue: t.field({
        type: "String",
        required: false,
        extensions: {
          protobufField: {
            name: "string_value",
            typeFullName: "google.protobuf.StringValue",
          },
        },
      }),
      bytesValue: t.field({
        type: "Byte",
        required: false,
        extensions: {
          protobufField: {
            name: "bytes_value",
            typeFullName: "google.protobuf.BytesValue",
          },
        },
      }),
      timestamps: t.field({
        type: ["DateTime"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "timestamps",
            typeFullName: "google.protobuf.Timestamp",
          },
        },
      }),
      int32Values: t.field({
        type: ["Int"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "int32_values",
            typeFullName: "google.protobuf.Int32Value",
          },
        },
      }),
      int64Values: t.field({
        type: ["String"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "int64_values",
            typeFullName: "google.protobuf.Int64Value",
          },
        },
      }),
      uint32Values: t.field({
        type: ["Int"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "uint32_values",
            typeFullName: "google.protobuf.UInt32Value",
          },
        },
      }),
      uint64Values: t.field({
        type: ["String"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "uint64_values",
            typeFullName: "google.protobuf.UInt64Value",
          },
        },
      }),
      floatValues: t.field({
        type: ["Float"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "float_values",
            typeFullName: "google.protobuf.FloatValue",
          },
        },
      }),
      doubleValues: t.field({
        type: ["Float"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "double_values",
            typeFullName: "google.protobuf.DoubleValue",
          },
        },
      }),
      boolValues: t.field({
        type: ["Boolean"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "bool_values",
            typeFullName: "google.protobuf.BoolValue",
          },
        },
      }),
      stringValues: t.field({
        type: ["String"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "string_values",
            typeFullName: "google.protobuf.StringValue",
          },
        },
      }),
      bytesValues: t.field({
        type: ["Byte"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "bytes_values",
            typeFullName: "google.protobuf.BytesValue",
          },
        },
      }),
      requiredTimestamp: t.field({
        type: "DateTime",
        required: true,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_timestamp",
            typeFullName: "google.protobuf.Timestamp",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.wktypes.Message",
        name: "Message",
        package: "testapis.wktypes",
      },
    },
  });

export type MessagePartialInput$Shape = {
  timestamp?: Message["timestamp"] | null;
  int32Value?: Message["int32Value"] | null;
  int64Value?: Message["int64Value"] | null;
  uint32Value?: Message["uint32Value"] | null;
  uint64Value?: Message["uint64Value"] | null;
  floatValue?: Message["floatValue"] | null;
  doubleValue?: Message["doubleValue"] | null;
  boolValue?: Message["boolValue"] | null;
  stringValue?: Message["stringValue"] | null;
  bytesValue?: Message["bytesValue"] | null;
  timestamps?: Message["timestamps"] | null;
  int32Values?: Message["int32Values"] | null;
  int64Values?: Message["int64Values"] | null;
  uint32Values?: Message["uint32Values"] | null;
  uint64Values?: Message["uint64Values"] | null;
  floatValues?: Message["floatValues"] | null;
  doubleValues?: Message["doubleValues"] | null;
  boolValues?: Message["boolValues"] | null;
  stringValues?: Message["stringValues"] | null;
  bytesValues?: Message["bytesValues"] | null;
  requiredTimestamp?: Message["requiredTimestamp"] | null;
};

export const MessagePartialInput$Ref: InputObjectRef<
  MessagePartialInput$Shape
> = builder.inputRef<MessagePartialInput$Shape>("MessagePartialInput")
  .implement({
    fields: (t) => ({
      timestamp: t.field({
        type: "DateTime",
        required: false,
        extensions: {
          protobufField: {
            name: "timestamp",
            typeFullName: "google.protobuf.Timestamp",
          },
        },
      }),
      int32Value: t.field({
        type: "Int",
        required: false,
        extensions: {
          protobufField: {
            name: "int32_value",
            typeFullName: "google.protobuf.Int32Value",
          },
        },
      }),
      int64Value: t.field({
        type: "String",
        required: false,
        extensions: {
          protobufField: {
            name: "int64_value",
            typeFullName: "google.protobuf.Int64Value",
          },
        },
      }),
      uint32Value: t.field({
        type: "Int",
        required: false,
        extensions: {
          protobufField: {
            name: "uint32_value",
            typeFullName: "google.protobuf.UInt32Value",
          },
        },
      }),
      uint64Value: t.field({
        type: "String",
        required: false,
        extensions: {
          protobufField: {
            name: "uint64_value",
            typeFullName: "google.protobuf.UInt64Value",
          },
        },
      }),
      floatValue: t.field({
        type: "Float",
        required: false,
        extensions: {
          protobufField: {
            name: "float_value",
            typeFullName: "google.protobuf.FloatValue",
          },
        },
      }),
      doubleValue: t.field({
        type: "Float",
        required: false,
        extensions: {
          protobufField: {
            name: "double_value",
            typeFullName: "google.protobuf.DoubleValue",
          },
        },
      }),
      boolValue: t.field({
        type: "Boolean",
        required: false,
        extensions: {
          protobufField: {
            name: "bool_value",
            typeFullName: "google.protobuf.BoolValue",
          },
        },
      }),
      stringValue: t.field({
        type: "String",
        required: false,
        extensions: {
          protobufField: {
            name: "string_value",
            typeFullName: "google.protobuf.StringValue",
          },
        },
      }),
      bytesValue: t.field({
        type: "Byte",
        required: false,
        extensions: {
          protobufField: {
            name: "bytes_value",
            typeFullName: "google.protobuf.BytesValue",
          },
        },
      }),
      timestamps: t.field({
        type: ["DateTime"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "timestamps",
            typeFullName: "google.protobuf.Timestamp",
          },
        },
      }),
      int32Values: t.field({
        type: ["Int"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "int32_values",
            typeFullName: "google.protobuf.Int32Value",
          },
        },
      }),
      int64Values: t.field({
        type: ["String"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "int64_values",
            typeFullName: "google.protobuf.Int64Value",
          },
        },
      }),
      uint32Values: t.field({
        type: ["Int"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "uint32_values",
            typeFullName: "google.protobuf.UInt32Value",
          },
        },
      }),
      uint64Values: t.field({
        type: ["String"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "uint64_values",
            typeFullName: "google.protobuf.UInt64Value",
          },
        },
      }),
      floatValues: t.field({
        type: ["Float"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "float_values",
            typeFullName: "google.protobuf.FloatValue",
          },
        },
      }),
      doubleValues: t.field({
        type: ["Float"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "double_values",
            typeFullName: "google.protobuf.DoubleValue",
          },
        },
      }),
      boolValues: t.field({
        type: ["Boolean"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "bool_values",
            typeFullName: "google.protobuf.BoolValue",
          },
        },
      }),
      stringValues: t.field({
        type: ["String"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "string_values",
            typeFullName: "google.protobuf.StringValue",
          },
        },
      }),
      bytesValues: t.field({
        type: ["Byte"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "bytes_values",
            typeFullName: "google.protobuf.BytesValue",
          },
        },
      }),
      requiredTimestamp: t.field({
        type: "DateTime",
        required: false,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_timestamp",
            typeFullName: "google.protobuf.Timestamp",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.wktypes.Message",
        name: "Message",
        package: "testapis.wktypes",
      },
    },
  });
",
    "name": "testapis/wktypes/well_known_types.pb.pothos.ts",
  },
]
`;

exports[`'testapis.wktypes' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/wktypes/well_known_types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import { Message } from "./testapis/wktypes/well_known_types";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    timestamp: t.expose("timestamp", {
      type: "DateTime",
      nullable: true,
      extensions: {
        protobufField: {
          name: "timestamp",
          typeFullName: "google.protobuf.Timestamp",
        },
      },
    }),
    int32Value: t.expose("int32Value", {
      type: "Int",
      nullable: true,
      extensions: {
        protobufField: {
          name: "int32_value",
          typeFullName: "google.protobuf.Int32Value",
        },
      },
    }),
    int64Value: t.expose("int64Value", {
      type: "String",
      nullable: true,
      extensions: {
        protobufField: {
          name: "int64_value",
          typeFullName: "google.protobuf.Int64Value",
        },
      },
    }),
    uint32Value: t.expose("uint32Value", {
      type: "Int",
      nullable: true,
      extensions: {
        protobufField: {
          name: "uint32_value",
          typeFullName: "google.protobuf.UInt32Value",
        },
      },
    }),
    uint64Value: t.expose("uint64Value", {
      type: "String",
      nullable: true,
      extensions: {
        protobufField: {
          name: "uint64_value",
          typeFullName: "google.protobuf.UInt64Value",
        },
      },
    }),
    floatValue: t.expose("floatValue", {
      type: "Float",
      nullable: true,
      extensions: {
        protobufField: {
          name: "float_value",
          typeFullName: "google.protobuf.FloatValue",
        },
      },
    }),
    doubleValue: t.expose("doubleValue", {
      type: "Float",
      nullable: true,
      extensions: {
        protobufField: {
          name: "double_value",
          typeFullName: "google.protobuf.DoubleValue",
        },
      },
    }),
    boolValue: t.expose("boolValue", {
      type: "Boolean",
      nullable: true,
      extensions: {
        protobufField: {
          name: "bool_value",
          typeFullName: "google.protobuf.BoolValue",
        },
      },
    }),
    stringValue: t.expose("stringValue", {
      type: "String",
      nullable: true,
      extensions: {
        protobufField: {
          name: "string_value",
          typeFullName: "google.protobuf.StringValue",
        },
      },
    }),
    bytesValue: t.field({
      type: "Byte",
      nullable: true,
      resolve: (source) => {
        return source.bytesValue == null
          ? null
          : Buffer.from(source.bytesValue);
      },
      extensions: {
        protobufField: {
          name: "bytes_value",
          typeFullName: "google.protobuf.BytesValue",
        },
      },
    }),
    timestamps: t.expose("timestamps", {
      type: ["DateTime"],
      nullable: { list: true, items: false },
      extensions: {
        protobufField: {
          name: "timestamps",
          typeFullName: "google.protobuf.Timestamp",
        },
      },
    }),
    int32Values: t.expose("int32Values", {
      type: ["Int"],
      nullable: { list: true, items: false },
      extensions: {
        protobufField: {
          name: "int32_values",
          typeFullName: "google.protobuf.Int32Value",
        },
      },
    }),
    int64Values: t.expose("int64Values", {
      type: ["String"],
      nullable: { list: true, items: false },
      extensions: {
        protobufField: {
          name: "int64_values",
          typeFullName: "google.protobuf.Int64Value",
        },
      },
    }),
    uint32Values: t.expose("uint32Values", {
      type: ["Int"],
      nullable: { list: true, items: false },
      extensions: {
        protobufField: {
          name: "uint32_values",
          typeFullName: "google.protobuf.UInt32Value",
        },
      },
    }),
    uint64Values: t.expose("uint64Values", {
      type: ["String"],
      nullable: { list: true, items: false },
      extensions: {
        protobufField: {
          name: "uint64_values",
          typeFullName: "google.protobuf.UInt64Value",
        },
      },
    }),
    floatValues: t.expose("floatValues", {
      type: ["Float"],
      nullable: { list: true, items: false },
      extensions: {
        protobufField: {
          name: "float_values",
          typeFullName: "google.protobuf.FloatValue",
        },
      },
    }),
    doubleValues: t.expose("doubleValues", {
      type: ["Float"],
      nullable: { list: true, items: false },
      extensions: {
        protobufField: {
          name: "double_values",
          typeFullName: "google.protobuf.DoubleValue",
        },
      },
    }),
    boolValues: t.expose("boolValues", {
      type: ["Boolean"],
      nullable: { list: true, items: false },
      extensions: {
        protobufField: {
          name: "bool_values",
          typeFullName: "google.protobuf.BoolValue",
        },
      },
    }),
    stringValues: t.expose("stringValues", {
      type: ["String"],
      nullable: { list: true, items: false },
      extensions: {
        protobufField: {
          name: "string_values",
          typeFullName: "google.protobuf.StringValue",
        },
      },
    }),
    bytesValues: t.field({
      type: ["Byte"],
      nullable: { list: true, items: false },
      resolve: (source) => {
        return source.bytesValues.map((v) => Buffer.from(v));
      },
      extensions: {
        protobufField: {
          name: "bytes_values",
          typeFullName: "google.protobuf.BytesValue",
        },
      },
    }),
    requiredTimestamp: t.field({
      type: "DateTime",
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.requiredTimestamp!;
      },
      extensions: {
        protobufField: {
          name: "required_timestamp",
          typeFullName: "google.protobuf.Timestamp",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Message | { $type: string & {}; }).$type ===
      "testapis.wktypes.Message";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.wktypes.Message",
      name: "Message",
      package: "testapis.wktypes",
    },
  },
});

export type MessageInput$Shape = {
  timestamp?: Message["timestamp"] | null;
  int32Value?: Message["int32Value"] | null;
  int64Value?: Message["int64Value"] | null;
  uint32Value?: Message["uint32Value"] | null;
  uint64Value?: Message["uint64Value"] | null;
  floatValue?: Message["floatValue"] | null;
  doubleValue?: Message["doubleValue"] | null;
  boolValue?: Message["boolValue"] | null;
  stringValue?: Message["stringValue"] | null;
  bytesValue?: Message["bytesValue"] | null;
  timestamps?: Message["timestamps"] | null;
  int32Values?: Message["int32Values"] | null;
  int64Values?: Message["int64Values"] | null;
  uint32Values?: Message["uint32Values"] | null;
  uint64Values?: Message["uint64Values"] | null;
  floatValues?: Message["floatValues"] | null;
  doubleValues?: Message["doubleValues"] | null;
  boolValues?: Message["boolValues"] | null;
  stringValues?: Message["stringValues"] | null;
  bytesValues?: Message["bytesValues"] | null;
  requiredTimestamp: NonNullable<Message["requiredTimestamp"]>;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement({
    fields: (t) => ({
      timestamp: t.field({
        type: "DateTime",
        required: false,
        extensions: {
          protobufField: {
            name: "timestamp",
            typeFullName: "google.protobuf.Timestamp",
          },
        },
      }),
      int32Value: t.field({
        type: "Int",
        required: false,
        extensions: {
          protobufField: {
            name: "int32_value",
            typeFullName: "google.protobuf.Int32Value",
          },
        },
      }),
      int64Value: t.field({
        type: "String",
        required: false,
        extensions: {
          protobufField: {
            name: "int64_value",
            typeFullName: "google.protobuf.Int64Value",
          },
        },
      }),
      uint32Value: t.field({
        type: "Int",
        required: false,
        extensions: {
          protobufField: {
            name: "uint32_value",
            typeFullName: "google.protobuf.UInt32Value",
          },
        },
      }),
      uint64Value: t.field({
        type: "String",
        required: false,
        extensions: {
          protobufField: {
            name: "uint64_value",
            typeFullName: "google.protobuf.UInt64Value",
          },
        },
      }),
      floatValue: t.field({
        type: "Float",
        required: false,
        extensions: {
          protobufField: {
            name: "float_value",
            typeFullName: "google.protobuf.FloatValue",
          },
        },
      }),
      doubleValue: t.field({
        type: "Float",
        required: false,
        extensions: {
          protobufField: {
            name: "double_value",
            typeFullName: "google.protobuf.DoubleValue",
          },
        },
      }),
      boolValue: t.field({
        type: "Boolean",
        required: false,
        extensions: {
          protobufField: {
            name: "bool_value",
            typeFullName: "google.protobuf.BoolValue",
          },
        },
      }),
      stringValue: t.field({
        type: "String",
        required: false,
        extensions: {
          protobufField: {
            name: "string_value",
            typeFullName: "google.protobuf.StringValue",
          },
        },
      }),
      bytesValue: t.field({
        type: "Byte",
        required: false,
        extensions: {
          protobufField: {
            name: "bytes_value",
            typeFullName: "google.protobuf.BytesValue",
          },
        },
      }),
      timestamps: t.field({
        type: ["DateTime"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "timestamps",
            typeFullName: "google.protobuf.Timestamp",
          },
        },
      }),
      int32Values: t.field({
        type: ["Int"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "int32_values",
            typeFullName: "google.protobuf.Int32Value",
          },
        },
      }),
      int64Values: t.field({
        type: ["String"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "int64_values",
            typeFullName: "google.protobuf.Int64Value",
          },
        },
      }),
      uint32Values: t.field({
        type: ["Int"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "uint32_values",
            typeFullName: "google.protobuf.UInt32Value",
          },
        },
      }),
      uint64Values: t.field({
        type: ["String"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "uint64_values",
            typeFullName: "google.protobuf.UInt64Value",
          },
        },
      }),
      floatValues: t.field({
        type: ["Float"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "float_values",
            typeFullName: "google.protobuf.FloatValue",
          },
        },
      }),
      doubleValues: t.field({
        type: ["Float"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "double_values",
            typeFullName: "google.protobuf.DoubleValue",
          },
        },
      }),
      boolValues: t.field({
        type: ["Boolean"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "bool_values",
            typeFullName: "google.protobuf.BoolValue",
          },
        },
      }),
      stringValues: t.field({
        type: ["String"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "string_values",
            typeFullName: "google.protobuf.StringValue",
          },
        },
      }),
      bytesValues: t.field({
        type: ["Byte"],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "bytes_values",
            typeFullName: "google.protobuf.BytesValue",
          },
        },
      }),
      requiredTimestamp: t.field({
        type: "DateTime",
        required: true,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_timestamp",
            typeFullName: "google.protobuf.Timestamp",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.wktypes.Message",
        name: "Message",
        package: "testapis.wktypes",
      },
    },
  });
",
    "name": "testapis/wktypes/well_known_types.pb.pothos.ts",
  },
]
`;
